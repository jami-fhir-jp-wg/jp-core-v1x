#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const commander_1 = require("commander");
const chalk_1 = __importDefault(require("chalk"));
const process_1 = __importDefault(require("process"));
const lodash_1 = require("lodash");
const export_1 = require("./export");
const ig_1 = require("./ig");
const fhirdefs_1 = require("./fhirdefs");
const fhirdefs_2 = require("./fhirdefs");
const utils_1 = require("./utils");
const FSH_VERSION = '3.0.0';
function logUnexpectedError(e) {
    utils_1.logger.error(`SUSHI encountered the following unexpected error: ${e.message}`);
    if (e.stack) {
        utils_1.logger.debug(e.stack);
    }
    process_1.default.exit(1);
}
app().catch(logUnexpectedError);
async function app() {
    const program = new commander_1.Command()
        .name('sushi')
        .version(getVersion(), '-v, --version', 'print SUSHI version')
        .showHelpAfterError();
    program
        .command('build', { isDefault: true })
        .description('build a SUSHI project')
        .argument('[path-to-fsh-project]', 'path to your FSH project (default: ".")')
        .addOption(new commander_1.Option('-l, --log-level <level>', 'specify the level of log messages (default: "info")').choices(['error', 'warn', 'info', 'debug']))
        .option('-o, --out <out>', 'the path to the output folder (default: "fsh-generated")')
        .option('-p, --preprocessed', 'output FSH produced by preprocessing steps')
        .option('-r, --require-latest', 'exit with error if this is not the latest version of SUSHI', false)
        .option('-s, --snapshot', 'generate snapshot in Structure Definition output', false)
        .option('-c, --config <config>', "override elements in sushi-config.yaml (supported: 'version', 'status', 'releaselabel') (eg: --config status:draft)", (value, previous = {}) => {
        const [k, ...v] = value.split(':');
        return Object.assign(previous, { [k]: v.join(':') });
    })
        .allowExcessArguments(false)
        .action(async function (projectPath, options) {
        setLogLevel(options);
        await runBuild(projectPath, options, program.helpInformation()).catch(logUnexpectedError);
    })
        // NOTE: This option is included give a nice error message when the old init option is used while we support
        // backwards compatibility of the build command.
        .addOption(new commander_1.Option('-i, --init', 'ERROR: --init option is moved to a separate command. Run: sushi init').hideHelp())
        .on('option:init', () => {
        // init was moved to a separate command, so log a message to indicate how to use it
        console.log('The --init option has been moved to a separate command. Instead, run the following command: sushi init');
        process_1.default.exit(1);
    });
    program
        .command('init')
        .description('initialize a SUSHI project')
        .argument('[name]', 'project name')
        .option('-c, --config <config>', "configure a specific property for the project (supported: 'id', 'canonical', 'status', 'version', 'releaselabel', 'publisher-name', 'publisher-url') (eg: --config status:draft)", (value, previous = {}) => {
        const [k, ...v] = value.split(':');
        return Object.assign(previous, { [k.toLowerCase()]: v.join(':') });
    })
        .option('-d, --default', 'accept all remaining defaults')
        .option('-a, --auto-initialize', 'automatically initialize the SUSHI project in the current directory')
        .addOption(new commander_1.Option('-l, --log-level <level>', 'specify the level of log messages (default: "info")').choices(['error', 'warn', 'info', 'debug']))
        .allowExcessArguments(false)
        .action(async function (projectName, options) {
        setLogLevel(options);
        await (0, utils_1.init)(projectName, options).catch(logUnexpectedError);
        process_1.default.exit(0);
    });
    program
        .command('update-dependencies')
        .description('update FHIR packages in project configuration')
        .argument('[path-to-fsh-project]', 'path to your FSH project (default: ".")')
        .addOption(new commander_1.Option('-l, --log-level <level>', 'specify the level of log messages (default: "info")').choices(['error', 'warn', 'info', 'debug']))
        .action(async function (projectPath, options) {
        setLogLevel(options);
        await runUpdateDependencies(projectPath).catch(logUnexpectedError);
        process_1.default.exit(0);
    });
    program.parse(process_1.default.argv).opts();
}
async function runUpdateDependencies(projectPath) {
    const input = (0, utils_1.ensureInputDir)(projectPath);
    const config = (0, utils_1.readConfig)(input);
    await (0, utils_1.updateExternalDependencies)(config);
}
async function runBuild(input, program, helpText) {
    var _a, _b;
    // NOTE: This is included to provide nicer handling for the previous CLI structure for building FSH projects.
    // Check the first argument passed into sushi. If it is not "build", then this is a legacy build,
    // in which case we should make sure that the first argument is a flag or a valid path.
    const arg = process_1.default.argv[2];
    if (arg != null && arg !== 'build' && !arg.startsWith('-') && !fs_extra_1.default.existsSync(arg)) {
        // It's not a flag or a path, so it's probably a typo of an existing command
        console.log(helpText);
        process_1.default.exit(1);
    }
    utils_1.logger.info(`Running ${getVersion()}`);
    utils_1.logger.info('Arguments:');
    if (program.logLevel) {
        utils_1.logger.info(`  --log-level ${program.logLevel}`);
    }
    if (program.preprocessed) {
        utils_1.logger.info('  --preprocessed');
    }
    if (program.snapshot) {
        utils_1.logger.info('  --snapshot');
    }
    if (program.requireLatest) {
        utils_1.logger.info('  --require-latest');
    }
    if (program.out) {
        utils_1.logger.info(`  --out ${path_1.default.resolve(program.out)}`);
    }
    if (program.config) {
        Object.entries(program.config).forEach(([k, v]) => utils_1.logger.info(`  --config ${k}:${v}`));
    }
    utils_1.logger.info(`  ${path_1.default.resolve(input || '.')}`);
    const sushiVersions = await (0, utils_1.checkSushiVersion)();
    if (program.requireLatest &&
        (sushiVersions.latest == null || sushiVersions.latest !== sushiVersions.current)) {
        utils_1.logger.error(`Current SUSHI version (${sushiVersions.current}) is not the latest version. Upgrade to the latest version (${(_a = sushiVersions.latest) !== null && _a !== void 0 ? _a : 'undetermined'}) or run SUSHI again without the --require-latest flag.`);
        process_1.default.exit(1);
    }
    input = (0, utils_1.ensureInputDir)(input);
    const rootIgnoreWarningsPath = path_1.default.join(input, 'sushi-ignoreWarnings.txt');
    const nestedIgnoreWarningsPath = path_1.default.join(input, 'input', 'sushi-ignoreWarnings.txt');
    if (fs_extra_1.default.existsSync(rootIgnoreWarningsPath)) {
        (0, utils_1.setIgnoredWarnings)(fs_extra_1.default.readFileSync(rootIgnoreWarningsPath, 'utf-8'));
        if (fs_extra_1.default.existsSync(nestedIgnoreWarningsPath)) {
            utils_1.logger.warn('Found sushi-ignoreWarnings.txt files in the following locations:\n\n' +
                ` - ${rootIgnoreWarningsPath}\n` +
                ` - ${nestedIgnoreWarningsPath}\n\n` +
                `Only the file at ${rootIgnoreWarningsPath} will be processed. ` +
                'Remove one of these files to avoid this warning.');
        }
    }
    else if (fs_extra_1.default.existsSync(nestedIgnoreWarningsPath)) {
        (0, utils_1.setIgnoredWarnings)(fs_extra_1.default.readFileSync(nestedIgnoreWarningsPath, 'utf-8'));
    }
    const originalInput = input;
    input = (0, utils_1.findInputDir)(input);
    // If an input/fsh subdirectory is used, we are in an IG Publisher context
    const fshFolder = path_1.default.basename(input) === 'fsh';
    const inputFshFolder = fshFolder && path_1.default.basename(path_1.default.dirname(input)) === 'input';
    if (!inputFshFolder) {
        // Since current supported tank configuration requires input/fsh folder,
        // both legacy IG publisher mode and legacy flat tank cases occur when
        // there is no input/fsh/ folder.
        // If we detect this case, things are about to go very wrong, so exit immediately.
        utils_1.logger.error('Migration to current SUSHI project structure is required. See above error message for details. Exiting.');
        process_1.default.exit(1);
    }
    const outDir = (0, utils_1.ensureOutputDir)(input, program.out);
    let tank;
    let config;
    try {
        let rawFSH;
        if (!fs_extra_1.default.existsSync(input)) {
            // If we have a path that ends with input/fsh but that folder does not exist,
            // we are in a sushi-config.yaml-only case (current tank configuration with no FSH files)
            // so we can safely say there are no FSH files and therefore rawFSH is empty.
            rawFSH = [];
        }
        else {
            rawFSH = (0, utils_1.getRawFSHes)(input);
        }
        if (rawFSH.length === 0 &&
            !(fs_extra_1.default.existsSync(path_1.default.join(originalInput, 'sushi-config.yaml')) ||
                fs_extra_1.default.existsSync(path_1.default.join(originalInput, 'sushi-config.yml')))) {
            utils_1.logger.info('No FSH files or sushi-config.yaml present.');
            process_1.default.exit(0);
        }
        config = (0, utils_1.readConfig)(originalInput);
        (0, utils_1.updateConfig)(config, program);
        tank = (0, utils_1.fillTank)(rawFSH, config);
    }
    catch (e) {
        // If no errors have been logged yet, log this exception so the user knows why we're exiting
        if (utils_1.stats.numError === 0) {
            utils_1.logger.error(`An unexpected error occurred: ${(_b = e.message) !== null && _b !== void 0 ? _b : e}`);
            if (e.stack) {
                utils_1.logger.debug(e.stack);
            }
        }
        process_1.default.exit(1);
    }
    // Load dependencies
    const defs = new fhirdefs_2.FHIRDefinitions();
    await (0, utils_1.loadExternalDependencies)(defs, config);
    // Load custom resources. In current tank configuration (input/fsh), resources will be in input/
    (0, fhirdefs_1.loadCustomResources)(path_1.default.join(input, '..'), originalInput, config.parameters, defs);
    // Check for StructureDefinition
    const structDef = defs.fishForFHIR('StructureDefinition', utils_1.Type.Resource);
    if (structDef == null || !(0, utils_1.isSupportedFHIRVersion)(structDef.version)) {
        utils_1.logger.error('Valid StructureDefinition resource not found. The FHIR package in your local cache' +
            ' may be corrupt. Local FHIR cache can be found at <home-directory>/.fhir/packages.' +
            ' For more information, see https://wiki.hl7.org/FHIR_Package_Cache#Location.');
        process_1.default.exit(1);
    }
    utils_1.logger.info('Converting FSH to FHIR resources...');
    const outPackage = (0, export_1.exportFHIR)(tank, defs);
    const { skippedResources } = (0, utils_1.writeFHIRResources)(outDir, outPackage, defs, program.snapshot);
    (0, utils_1.writeFSHIndex)(outDir, outPackage, input, skippedResources);
    if (program.preprocessed) {
        utils_1.logger.info('Writing preprocessed FSH...');
        (0, utils_1.writePreprocessedFSH)(outDir, input, tank);
    }
    // If FSHOnly is true in the config, do not generate IG content, otherwise, generate IG content
    if (config.FSHOnly) {
        utils_1.logger.info('Exporting FSH definitions only. No IG related content will be exported.');
    }
    else {
        const igFilesPath = path_1.default.resolve(input, '..', '..');
        utils_1.logger.info('Assembling Implementation Guide sources...');
        const igExporter = new ig_1.IGExporter(outPackage, defs, igFilesPath);
        igExporter.export(outDir);
        utils_1.logger.info('Assembled Implementation Guide sources; ready for IG Publisher.');
        if (!fs_extra_1.default
            .readdirSync(outDir)
            .some(file => file.startsWith('_genonce') || file.startsWith('_updatePublisher'))) {
            utils_1.logger.info('The sample-ig located at https://github.com/FHIR/sample-ig contains scripts useful for downloading and running the IG Publisher.');
        }
    }
    console.log();
    printResults(outPackage, sushiVersions);
    console.log();
    process_1.default.exit(utils_1.stats.numError);
}
function getVersion() {
    const sushiVersion = (0, utils_1.getLocalSushiVersion)();
    if (sushiVersion !== null) {
        return `SUSHI v${sushiVersion} (implements FHIR Shorthand specification v${FSH_VERSION})`;
    }
    return 'unknown';
}
function setLogLevel(options) {
    // Set the log level. If no level is specified, logger defaults to info
    if (options.logLevel != null) {
        // options.logLevel has only valid log levels because the CLI sets the choices
        utils_1.logger.level = options.logLevel;
    }
}
function printResults(pkg, sushiVersions) {
    // NOTE: These variables are creatively names to align well in the strings below while keeping prettier happy
    const profileNum = (0, lodash_1.pad)(pkg.profiles.length.toString(), 13);
    const extentNum = (0, lodash_1.pad)(pkg.extensions.length.toString(), 12);
    const logiclNum = (0, lodash_1.pad)(pkg.logicals.length.toString(), 12);
    const resourcNum = (0, lodash_1.pad)(pkg.resources.length.toString(), 13);
    const valueSetsNumber = (0, lodash_1.pad)(pkg.valueSets.length.toString(), 18);
    const codeSystemsNum = (0, lodash_1.pad)(pkg.codeSystems.length.toString(), 17);
    const instancesNumber = (0, lodash_1.pad)(pkg.instances.length.toString(), 18);
    const errorNumMsg = (0, lodash_1.pad)(`${utils_1.stats.numError} Error${utils_1.stats.numError !== 1 ? 's' : ''}`, 13);
    const wrNumMsg = (0, lodash_1.padStart)(`${utils_1.stats.numWarn} Warning${utils_1.stats.numWarn !== 1 ? 's' : ''}`, 12);
    const aWittyMessageInvolvingABadFishPun = (0, lodash_1.padEnd)((0, utils_1.getRandomPun)(utils_1.stats.numError, utils_1.stats.numWarn), 36);
    const clr = utils_1.stats.numError > 0 ? chalk_1.default.red : utils_1.stats.numWarn > 0 ? chalk_1.default.rgb(179, 98, 0) : chalk_1.default.green;
    // NOTE: Doing some funky things w/ strings on some lines to keep overall alignment in the code
    const results = [
        clr('╔' + '════════════════════════ SUSHI RESULTS ══════════════════════════' + '' + '╗'),
        clr('║') + ' ╭───────────────┬──────────────┬──────────────┬───────────────╮ ' + clr('║'),
        clr('║') + ' │    Profiles   │  Extensions  │   Logicals   │   Resources   │ ' + clr('║'),
        clr('║') + ' ├───────────────┼──────────────┼──────────────┼───────────────┤ ' + clr('║'),
        clr('║') + ` │ ${profileNum} │ ${extentNum} │ ${logiclNum} │ ${resourcNum} │ ` + clr('║'),
        clr('║') + ' ╰───────────────┴──────────────┴──────────────┴───────────────╯ ' + clr('║'),
        clr('║') + ' ╭────────────────────┬───────────────────┬────────────────────╮ ' + clr('║'),
        clr('║') + ' │      ValueSets     │    CodeSystems    │     Instances      │ ' + clr('║'),
        clr('║') + ' ├────────────────────┼───────────────────┼────────────────────┤ ' + clr('║'),
        clr('║') + ` │ ${valueSetsNumber} │ ${codeSystemsNum} │ ${instancesNumber} │ ` + clr('║'),
        clr('║') + ' ╰────────────────────┴───────────────────┴────────────────────╯ ' + clr('║'),
        clr('║' + '                                                                 ' + '' + '║'),
        clr('╠' + '═════════════════════════════════════════════════════════════════' + '' + '╣'),
        clr('║') + ` ${aWittyMessageInvolvingABadFishPun} ${errorNumMsg} ${wrNumMsg} ` + clr('║'),
        clr('╚' + '═════════════════════════════════════════════════════════════════' + '' + '╝')
    ];
    const { latest, current } = sushiVersions;
    if (latest != null && current != null && latest !== current) {
        const endline = results.pop();
        // prettier-ignore
        results.push(clr('╠' + '═════════════════════════════════════════════════════════════════' + '╣'), clr('║') + (0, lodash_1.pad)(`You are using SUSHI version ${current}, but the latest stable`, 65) + clr('║'), clr('║') + (0, lodash_1.pad)(`release is version ${latest}. To install the latest release, run:`, 65) + clr('║'), clr('║') + (0, lodash_1.pad)('npm install -g fsh-sushi', 65) + clr('║'), endline);
    }
    else if (latest == null || current == null) {
        const endline = results.pop();
        // prettier-ignore
        results.push(clr('╠' + '═════════════════════════════════════════════════════════════════' + '╣'), clr('║') + (0, lodash_1.pad)('SUSHI cannot determine if it is running the latest version.', 65) + clr('║'), clr('║') + (0, lodash_1.pad)('To see a listing of releases, including the latest, visit:', 65) + clr('║'), clr('║') + (0, lodash_1.pad)('https://github.com/FHIR/sushi/releases', 65) + clr('║'), endline);
    }
    const convertChars = !supportsFancyCharacters();
    results.forEach(r => {
        if (convertChars) {
            r = r
                .replace(/[╔╝╚╗╠╣═]/g, '=')
                .replace(/[╭╯╰╮]/g, ' ')
                .replace(/[─┬┼┴]/g, '-')
                .replace(/[║│├┤]/g, '|');
        }
        console.log(r);
    });
}
function supportsFancyCharacters() {
    // There is no sure-fire way, but we know that most problems are when running in the IG Publisher,
    // so try to detect that situation (which is still actually pretty tricky and not guaranteed).
    // 1. If the user wants the fancy characters, allow them
    if (Object.keys(process_1.default.env).some(k => k === 'FORCE_FANCY_CHARACTERS') &&
        /(true|1)/i.test(process_1.default.env.FORCE_FANCY_CHARACTERS)) {
        return true;
    }
    // 2. Many JVM will insert an environment variable indicating the main Java class being run.
    //      E.g., JAVA_MAIN_CLASS_25538=org.hl7.fhir.igtools.publisher.Publisher
    //    We won't check the actual class; we'll just assume that if it's run in Java, best not take chances.
    if (Object.keys(process_1.default.env).some(k => /^JAVA_MAIN_CLASS/.test(k))) {
        return false;
    }
    // 3. It appears that in a Java-launched process, certain aspects of stdout aren't available, so
    //    use that to test if it's likely the fancy chars will be supported.
    if (process_1.default.stdout.hasColors === undefined) {
        return false;
    }
    // Otherwise, I guess (?) we're OK.  Worst case scenario: user gets rubbish characters in the summary
    return true;
}
//# sourceMappingURL=app.js.map