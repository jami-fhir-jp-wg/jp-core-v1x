"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MappingExporter = void 0;
const utils_1 = require("../utils");
const fhirtypes_1 = require("../fhirtypes");
const errors_1 = require("../errors");
const common_1 = require("../fhirtypes/common");
const lodash_1 = require("lodash");
class MappingExporter {
    constructor(tank, pkg, fisher) {
        this.tank = tank;
        this.pkg = pkg;
        this.fisher = fisher;
    }
    /**
     * Sets the mapping on the StructureDefinition
     * @param {StructureDefinition} structDef - The StructureDefinition to set the mapping on
     * @param {Mapping} fshDefinition - The Mapping definition
     * @throws {InvalidFHIRIdError} when the id on the fshDefinition is not valid in FHIR
     */
    setMetadata(structDef, fshDefinition) {
        if (structDef.mapping == null) {
            structDef.mapping = [];
        }
        if (!fhirtypes_1.idRegex.test(fshDefinition.id)) {
            throw new errors_1.InvalidFHIRIdError(fshDefinition.id);
        }
        structDef.mapping.push({
            identity: fshDefinition.id,
            ...(fshDefinition.title && { name: fshDefinition.title }),
            ...(fshDefinition.target && { uri: fshDefinition.target }),
            ...(fshDefinition.description && { comment: fshDefinition.description })
        });
    }
    /**
     * Applies mapping rules to the individual ElementDefinitions on the SD
     * @param {StructureDefinition} structDef - The StructureDefinition to apply rules on
     * @param {Mapping} fshDefinition - The Mapping definition
     */
    setMappingRules(structDef, fshDefinition) {
        (0, utils_1.resolveSoftIndexing)(fshDefinition.rules);
        for (const rule of fshDefinition.rules) {
            const element = structDef.findElementByPath(rule.path, this.fisher);
            if (element) {
                try {
                    element.applyMapping(fshDefinition.id, rule.map, rule.comment, rule.language);
                }
                catch (e) {
                    utils_1.logger.error(e.message, rule.sourceInfo);
                    if (e.stack) {
                        utils_1.logger.debug(e.stack);
                    }
                }
            }
            else {
                utils_1.logger.error(`No element found at path ${rule.path} for ${fshDefinition.name}, skipping rule`, rule.sourceInfo);
            }
        }
    }
    applyInsertRules() {
        const mappings = this.tank.getAllMappings();
        for (const mapping of mappings) {
            (0, common_1.applyInsertRules)(mapping, this.tank);
        }
    }
    /**
     * Exports a Mapping by finding the Source StructureDefinition and applying rules
     * @param {Mapping} fshDefinition - The Mapping definition to apply
     */
    exportMapping(fshDefinition) {
        var _a;
        const sourceStructDef = this.pkg.fish(fshDefinition.source, utils_1.Type.Profile, utils_1.Type.Extension, utils_1.Type.Resource, utils_1.Type.Logical);
        if (sourceStructDef) {
            const parent = this.fisher.fishForFHIR(sourceStructDef.baseDefinition, utils_1.Type.Resource, utils_1.Type.Type, utils_1.Type.Profile, utils_1.Type.Extension, utils_1.Type.Logical);
            const matchingParentMapping = (_a = parent === null || parent === void 0 ? void 0 : parent.mapping) === null || _a === void 0 ? void 0 : _a.find((m) => m.identity === fshDefinition.id);
            if (matchingParentMapping != null) {
                const isMatchingTitle = fshDefinition.title
                    ? fshDefinition.title === matchingParentMapping.name
                    : true;
                const isMatchingTarget = fshDefinition.target
                    ? fshDefinition.target === matchingParentMapping.uri
                    : true;
                if (!isMatchingTitle || !isMatchingTarget) {
                    // If the mapping identity matches one on the parent, all other metadata must also match in order to merge MappingRules
                    utils_1.logger.error(`Unable to add Mapping ${fshDefinition.name} because it conflicts with one already on the parent of ${fshDefinition.source}.`, fshDefinition.sourceInfo);
                    return;
                }
                else {
                    // Update parent mapping with additional or changed metadata (comment is the only property this can be the case for)
                    const inheritedMapping = sourceStructDef.mapping.find(m => m.identity === fshDefinition.id);
                    if (fshDefinition.description) {
                        inheritedMapping.comment = fshDefinition.description;
                    }
                }
            }
            else {
                // Only add metadata if it does not already exist on the parent
                this.setMetadata(sourceStructDef, fshDefinition);
            }
            this.setMappingRules(sourceStructDef, fshDefinition);
        }
        else {
            utils_1.logger.error(`Unable to find source "${fshDefinition.source}".`, fshDefinition.sourceInfo);
        }
    }
    export() {
        const mappings = this.tank.getAllMappings();
        for (const mapping of mappings) {
            try {
                this.exportMapping(mapping);
            }
            catch (e) {
                utils_1.logger.error(e.message, mapping.sourceInfo);
                if (e.stack) {
                    utils_1.logger.debug(e.stack);
                }
            }
        }
        // The mappings on each Structure Definition should have a unique id
        const groupedMappings = (0, lodash_1.groupBy)(mappings, 'source');
        for (const sd in groupedMappings) {
            const duplicateMappings = (0, lodash_1.pickBy)((0, lodash_1.groupBy)(groupedMappings[sd], 'id'), m => m.length > 1);
            for (const duplicateId in duplicateMappings) {
                // show error for each time the id was used after the first
                duplicateMappings[duplicateId].slice(1).forEach(m => {
                    utils_1.logger.error(`Multiple mappings on ${sd} found with id ${m.id}`, m.sourceInfo);
                });
            }
        }
    }
}
exports.MappingExporter = MappingExporter;
//# sourceMappingURL=MappingExporter.js.map