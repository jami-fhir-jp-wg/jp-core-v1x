"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeSystemExporter = void 0;
const fhirtypes_1 = require("../fhirtypes");
const common_1 = require("../fhirtypes/common");
const rules_1 = require("../fshtypes/rules");
const FSHLogger_1 = require("../utils/FSHLogger");
const utils_1 = require("../utils");
const _1 = require(".");
const errors_1 = require("../errors");
const lodash_1 = require("lodash");
class CodeSystemExporter {
    constructor(tank, pkg, fisher) {
        this.tank = tank;
        this.pkg = pkg;
        this.fisher = fisher;
    }
    setMetadata(codeSystem, fshDefinition) {
        codeSystem.setName(fshDefinition);
        codeSystem.setId(fshDefinition);
        if (fshDefinition.title == '') {
            FSHLogger_1.logger.warn(`Code system ${fshDefinition.name} has a title field that should not be empty.`);
        }
        if (fshDefinition.description == '') {
            FSHLogger_1.logger.warn(`Code system ${fshDefinition.name} has a description field that should not be empty.`);
        }
        if (fshDefinition.title)
            codeSystem.title = fshDefinition.title;
        if (fshDefinition.description)
            codeSystem.description = fshDefinition.description;
        if (this.tank.config.FSHOnly) {
            codeSystem.version = this.tank.config.version;
        }
        else {
            delete codeSystem.version; // deleting to allow the IG Publisher default to take hold
        }
        codeSystem.status = this.tank.config.status;
        codeSystem.url = `${this.tank.config.canonical}/CodeSystem/${codeSystem.id}`;
    }
    setConcepts(codeSystem, concepts) {
        if (concepts.length > 0) {
            codeSystem.concept = [];
            const existingConcepts = new Map();
            concepts.forEach(concept => {
                const existingConcept = existingConcepts.get(concept.code);
                if (existingConcept) {
                    // if this concept has only a code (and optionally, a hierarchy),
                    // and the existing concept has the same code and hierarchy,
                    // this concept may just be used to establish path context, which is fine.
                    if (!(concept.display == null &&
                        concept.definition == null &&
                        (0, lodash_1.isEqual)(concept.hierarchy, existingConcept.hierarchy))) {
                        // duplicates are prohibited: http://hl7.org/fhir/codesystem.html#invs
                        FSHLogger_1.logger.error(`CodeSystem ${codeSystem.id} already contains code ${concept.code}.`, concept.sourceInfo);
                    }
                }
                else {
                    let conceptContainer = codeSystem.concept;
                    const newConcept = { code: concept.code };
                    if (concept.display) {
                        newConcept.display = concept.display;
                    }
                    if (concept.definition) {
                        newConcept.definition = concept.definition;
                    }
                    for (const ancestorCode of concept.hierarchy) {
                        const ancestorConcept = conceptContainer.find(ancestorConcept => ancestorConcept.code === ancestorCode);
                        if (ancestorConcept) {
                            if (!ancestorConcept.concept) {
                                ancestorConcept.concept = [];
                            }
                            conceptContainer = ancestorConcept.concept;
                        }
                        else {
                            FSHLogger_1.logger.error(`Could not find ${ancestorCode} in concept hierarchy to use as ancestor of ${concept.code}.`, concept.sourceInfo);
                            return;
                        }
                    }
                    conceptContainer.push(newConcept);
                    existingConcepts.set(concept.code, concept);
                }
            });
        }
    }
    setCaretPathRules(codeSystem, rules) {
        // soft index resolution relies on the rule's path attribute.
        // a CaretValueRule is created with an empty path, so first
        // transform its arrayPath into a path.
        // Because this.findConceptPath can potentially throw an error,
        // build a list of successful rules that will actually be applied.
        const successfulRules = [];
        rules.forEach(rule => {
            try {
                rule.path = this.findConceptPath(codeSystem, rule.pathArray);
                successfulRules.push(rule);
                if (rule.path) {
                    rule.isCodeCaretRule = true;
                }
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, rule.sourceInfo);
                if (e.stack) {
                    FSHLogger_1.logger.debug(e.stack);
                }
            }
        });
        (0, utils_1.resolveSoftIndexing)(successfulRules);
        // a codesystem is a specific case where the only implied values are going to be extension urls.
        // so, we only need to track rules that involve an extension.
        const ruleMap = new Map();
        const codeSystemSD = codeSystem.getOwnStructureDefinition(this.fisher);
        const successfulRulesWithInstances = successfulRules
            .map(rule => {
            if (rule.isInstance) {
                const instanceExporter = new _1.InstanceExporter(this.tank, this.pkg, this.fisher);
                const instance = instanceExporter.fishForFHIR(rule.value);
                if (instance == null) {
                    FSHLogger_1.logger.error(`Cannot find definition for Instance: ${rule.value}. Skipping rule.`, rule.sourceInfo);
                    return null;
                }
                rule.value = instance;
            }
            const path = rule.path.length > 1 ? `${rule.path}.${rule.caretPath}` : rule.caretPath;
            try {
                const replacedRule = (0, common_1.replaceReferences)(rule, this.tank, this.fisher);
                const { pathParts } = codeSystemSD.validateValueAtPath(path, replacedRule.value, this.fisher);
                if (pathParts.some(part => (0, common_1.isExtension)(part.base))) {
                    ruleMap.set((0, utils_1.assembleFSHPath)(pathParts).replace(/\[0+\]/g, ''), { pathParts });
                }
                return replacedRule;
            }
            catch (originalErr) {
                // if an Instance has an id that looks like a number, bigint, or boolean,
                // we may have tried to assign that value instead of an Instance.
                // try to fish up an Instance with the rule's raw value.
                // if we find one, try assigning that instead.
                if (originalErr instanceof errors_1.MismatchedTypeError &&
                    ['number', 'bigint', 'boolean'].includes(typeof rule.value)) {
                    const instanceExporter = new _1.InstanceExporter(this.tank, this.pkg, this.fisher);
                    const { instance, pathParts } = (0, common_1.validateInstanceFromRawValue)(codeSystem, rule, instanceExporter, this.fisher, originalErr);
                    rule.value = instance;
                    if (pathParts.some(part => (0, common_1.isExtension)(part.base))) {
                        ruleMap.set((0, utils_1.assembleFSHPath)(pathParts).replace(/\[0+\]/g, ''), { pathParts });
                    }
                    return rule;
                }
                else {
                    FSHLogger_1.logger.error(originalErr.message, rule.sourceInfo);
                    if (originalErr.stack) {
                        FSHLogger_1.logger.debug(originalErr.stack);
                    }
                    return null;
                }
            }
        })
            .filter(rule => rule);
        const knownSlices = (0, common_1.determineKnownSlices)(codeSystemSD, ruleMap, this.fisher);
        (0, common_1.setImpliedPropertiesOnInstance)(codeSystem, codeSystemSD, [...ruleMap.keys()], [], this.fisher, knownSlices);
        for (const rule of successfulRulesWithInstances) {
            try {
                (0, common_1.setPropertyOnDefinitionInstance)(codeSystem, rule.path.length > 1 ? `${rule.path}.${rule.caretPath}` : rule.caretPath, rule.value, this.fisher);
            }
            catch (err) {
                FSHLogger_1.logger.error(err.message, rule.sourceInfo);
                if (err.stack) {
                    FSHLogger_1.logger.debug(err.stack);
                }
            }
        }
    }
    findConceptPath(codeSystem, codePath) {
        var _a, _b;
        const conceptIndices = [];
        let conceptList = (_a = codeSystem.concept) !== null && _a !== void 0 ? _a : [];
        for (const codeStep of codePath) {
            const stepIndex = conceptList.findIndex(concept => `#${concept.code}` === codeStep);
            if (stepIndex === -1) {
                throw new errors_1.CannotResolvePathError(codePath.join(' '));
            }
            conceptIndices.push(stepIndex);
            conceptList = (_b = conceptList[stepIndex].concept) !== null && _b !== void 0 ? _b : [];
        }
        return conceptIndices.map(conceptIndex => `concept[${conceptIndex}]`).join('.');
    }
    countConcepts(concepts) {
        if (concepts) {
            return (concepts.length +
                concepts
                    .map(concept => this.countConcepts(concept.concept))
                    .reduce((sum, next) => sum + next, 0));
        }
        else {
            return 0;
        }
    }
    updateCount(codeSystem, fshDefinition) {
        var _a;
        // We can only derive a true count if the content is #complete
        if (codeSystem.content === 'complete') {
            const actualCount = this.countConcepts(codeSystem.concept) || undefined;
            if (codeSystem.count == null && actualCount != null) {
                codeSystem.count = actualCount;
            }
            else if (codeSystem.count !== actualCount) {
                const countRule = fshDefinition.rules.find(r => r instanceof rules_1.CaretValueRule && r.caretPath === 'count');
                const sourceInfo = (_a = countRule === null || countRule === void 0 ? void 0 : countRule.sourceInfo) !== null && _a !== void 0 ? _a : fshDefinition.sourceInfo;
                FSHLogger_1.logger.warn(`The user-specified ^count (${codeSystem.count}) does not match the specified number of concepts ` +
                    `(${actualCount !== null && actualCount !== void 0 ? actualCount : 0}). If this is not a "complete" CodeSystem, set the ^content property to the appropriate ` +
                    'value; otherwise fix or remove the ^count.', sourceInfo);
            }
        }
    }
    applyInsertRules() {
        const codeSystems = this.tank.getAllCodeSystems();
        for (const cs of codeSystems) {
            (0, common_1.applyInsertRules)(cs, this.tank);
        }
    }
    exportCodeSystem(fshDefinition) {
        if (this.pkg.codeSystems.some(cs => cs.name === fshDefinition.name)) {
            return;
        }
        const codeSystem = new fhirtypes_1.CodeSystem();
        this.setMetadata(codeSystem, fshDefinition);
        this.setConcepts(codeSystem, fshDefinition.rules.filter(rule => rule instanceof rules_1.ConceptRule));
        this.setCaretPathRules(codeSystem, fshDefinition.rules.filter(rule => rule instanceof rules_1.CaretValueRule));
        // check for another code system with the same id
        // see https://www.hl7.org/fhir/resource.html#id
        if (this.pkg.codeSystems.some(cs => codeSystem.id === cs.id)) {
            FSHLogger_1.logger.error(`Multiple code systems with id ${codeSystem.id}. Each code system must have a unique id.`, fshDefinition.sourceInfo);
        }
        (0, common_1.cleanResource)(codeSystem, (prop) => ['_sliceName', '_primitive'].includes(prop));
        this.updateCount(codeSystem, fshDefinition);
        this.pkg.codeSystems.push(codeSystem);
        this.pkg.fshMap.set(codeSystem.getFileName(), {
            ...fshDefinition.sourceInfo,
            fshName: fshDefinition.name,
            fshType: 'CodeSystem'
        });
        return codeSystem;
    }
    export() {
        const codeSystems = this.tank.getAllCodeSystems();
        for (const cs of codeSystems) {
            try {
                this.exportCodeSystem(cs);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, cs.sourceInfo);
                if (e.stack) {
                    FSHLogger_1.logger.debug(e.stack);
                }
            }
        }
        if (codeSystems.length > 0) {
            FSHLogger_1.logger.info(`Converted ${codeSystems.length} FHIR CodeSystems.`);
        }
        return this.pkg;
    }
}
exports.CodeSystemExporter = CodeSystemExporter;
//# sourceMappingURL=CodeSystemExporter.js.map