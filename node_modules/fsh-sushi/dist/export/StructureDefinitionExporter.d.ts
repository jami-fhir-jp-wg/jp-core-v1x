import { StructureDefinition } from '../fhirtypes';
import { Extension, Logical, Profile, Resource } from '../fshtypes';
import { FSHTank } from '../import';
import { MismatchedTypeError } from '../errors';
import { BindingRule, CaretValueRule } from '../fshtypes/rules';
import { Type, Fishable, Metadata, MasterFisher } from '../utils';
import { Package } from './Package';
/**
 * The StructureDefinitionExporter is the class for exporting Logical models, Profiles, Extensions,
 * and Resources. The operations and structure of these exporters are very similar, so they
 * currently share an exporter.
 */
export declare class StructureDefinitionExporter implements Fishable {
    private readonly tank;
    private readonly pkg;
    private readonly fisher;
    deferredCaretRules: Map<StructureDefinition, {
        rule: CaretValueRule;
        originalErr?: MismatchedTypeError;
    }[]>;
    knownBindingRules: Map<StructureDefinition, {
        rule: BindingRule;
        isInline: boolean;
        url?: string;
    }[]>;
    private typeCharacteristicCodes;
    private commaSeparatedCharacteristics;
    constructor(tank: FSHTank, pkg: Package, fisher: MasterFisher);
    /**
     * Checks generated resources for any custom resources which are not in the
     * http://hl7.org/fhir/StructureDefinition namespace, and are therefore not
     * conformant.
     */
    private warnOnNonConformantResourceDefinitions;
    /**
     * Processes the fshDefinition's parent, validating it according to its type.
     * Returns the parent's StructureDefinition as the basis for the new StructureDefinition
     * for the provided fshDefinition.
     * @param {Extension | Profile | Logical | Resource} fshDefinition - The definition
     *        to be preprocessed. It is updated directly based on this processing.
     * @returns {StructureDefinition} for this fshDefinition
     * @private
     */
    private getStructureDefinition;
    /**
     * Sets the metadata for the StructureDefinition.  This includes clearing metadata that was copied from the parent
     * that may not be relevant to the child StructureDefinition.  Overall approach was discussed on Zulip.  This
     * function represents implementation of that approach plus setting extra metadata provided by FSH.
     * This essentially aligns closely with the approach that Forge uses (ensuring some consistency across tools).
     * @see {@link https://chat.fhir.org/#narrow/stream/179252-IG-creation/topic/Bad.20links.20on.20Detailed.20Description.20tab/near/186766845}
     * @param {StructureDefinition} structDef - The StructureDefinition to set metadata on
     * @param {Profile | Extension | Logical | Resource} fshDefinition - The definition we are exporting
     * @private
     */
    private setMetadata;
    private setContext;
    /**
     * When setting context for a complex extension, the path to the contained extension
     * is based on the urls for each contained extension, like this:
     * extensionUrl#childExtension.grandchildExtension
     * See https://chat.fhir.org/#narrow/stream/179252-IG-creation/topic/Extension.20Contexts/near/361378342
     */
    private setContextForComplexExtension;
    private setCharacteristics;
    /**
     * At this point, 'structDef' contains the parent's ElementDefinitions. For profiles
     * and extensions, these ElementDefinitions are mostly correct, so little processing is
     * necessary. For logical models and resources, the id and path attributes need to be
     * changed to reflect the type of the logical model/resource. By definition for logical
     * models and resources, the 'type' is the same as the 'id'. Therefore, the elements
     * must be changed to reflect the new StructureDefinition type.
     * @param {StructureDefinition} structDef - The StructureDefinition to set metadata on
     * @param {Profile | Extension | Logical | Resource} fshDefinition - The definition we are exporting
     * @private
     */
    private resetParentElements;
    /**
     * Sets the rules for the StructureDefinition
     * @param {StructureDefinition} structDef - The StructureDefinition to set rules on
     * @param {Profile | Extension} fshDefinition - The Profile or Extension we are exporting
     * @private
     */
    private setRules;
    applyDeferredRules(): void;
    /**
     * Handles a ContainsRule that is on an extension path, appropriately exporting it as a reference to a standalone
     * extension or an inline extension.
     * @param {Profile | Extension | Logical | Resource} fshDefinition - the FSH Definition the rule is on
     * @param {ContainsRule} rule - the ContainsRule that is on an extension element
     * @param {StructureDefinition} structDef - the StructDef of the resulting profile or element
     * @param {ElementDefinition} element - the element to apply the rule to
     * @private
     */
    private handleExtensionContainsRule;
    /**
     * Does any necessary preprocessing of profiles, extensions, logical models, and resources.
     * @param {Extension | Profile | Logical | Resource} fshDefinition - The definition
     *        to do preprocessing on. It is updated directly based on processing.
     * @param {boolean} isExtension - fshDefinition is/is not an Extension
     * @private
     */
    private preprocessStructureDefinition;
    fishForFHIR(item: string, ...types: Type[]): any;
    fishForMetadata(item: string, ...types: Type[]): Metadata;
    applyInsertRules(): void;
    /**
     * Exports Profile, Extension, Logical model, and custom Resource to StructureDefinition
     * @param {Profile | Extension | Logical | Resource} fshDefinition - The Profile or Extension
     *         or Logical model or custom Resource we are exporting
     * @returns {StructureDefinition}
     * @throws {ParentDeclaredAsNameError} when the fshDefinition declares itself as the parent
     * @throws {ParentDeclaredAsIdError} when the fshDefinition declares itself as the parent
     * @throws {ParentNotDefinedError} when the fshDefinition's parent is not found
     * @throws {InvalidExtensionParentError} when Extension does not have valid parent
     * @throws {InvalidLogicalParentError} when Logical does not have valid parent
     */
    exportStructDef(fshDefinition: Profile | Extension | Logical | Resource): StructureDefinition;
    /**
     * Checks invariants to ensure they have the required values (human and severity) and that
     * the values are appropriate. In order to avoid excessive logging, this is done once, as a group,
     * rather than each time an invariant is applied
     */
    private checkInvariants;
    /**
     * Exports Profiles, Extensions, Logical models, and Resources to StructureDefinitions
     * @returns {Package}
     */
    export(): Package;
}
