"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MasterFisher = void 0;
const import_1 = require("../import");
const FSHLogger_1 = require("./FSHLogger");
const fshtypes_1 = require("../fshtypes");
/**
 * The MasterFisher can fish from the tank, the FHIR definitions, and the package that is currently
 * being exported. When the MasterFisher fishes, it fishes in the package first, then the tank, and
 * then the FHIRDefinitions.  This essentially prefers local definitions first (when there are naming
 * clashes).
 *
 * The MasterFisher also uses its knowledge of these Fishable locations to do some necessary magic.
 * For instance, the FSHTank has no knowledge of FHIRDefinitions, so it cannot provide the correct
 * sdType for its metadata results.  When the MasterFisher detects this has happened, it uses the
 * other Fishable locations to determine the proper sdType (even for an item that currently exists
 * only in the tank).
 */
class MasterFisher {
    constructor(tank, fhir, pkg) {
        var _a, _b, _c;
        this.tank = tank;
        this.fhir = fhir;
        this.pkg = pkg;
        this.defaultFHIRVersion =
            (_b = (_a = fhir === null || fhir === void 0 ? void 0 : fhir.fishForFHIR('StructureDefinition')) === null || _a === void 0 ? void 0 : _a.fhirVersion) !== null && _b !== void 0 ? _b : (_c = tank === null || tank === void 0 ? void 0 : tank.config.fhirVersion) === null || _c === void 0 ? void 0 : _c[0];
    }
    /**
     * Searches for the FHIR JSON by name/id/url.  It will first search through the local package
     * (which contains FHIR artifacts exported so far), then through the external FHIR definitions.
     * @param {string} item - the item name/id/url to fish for
     * @param types - the allowable types to fish for
     */
    fishForFHIR(item, ...types) {
        var _a, _b, _c, _d, _e;
        // Resolve the alias if necessary
        item = (_b = (_a = this.tank) === null || _a === void 0 ? void 0 : _a.resolveAlias(item)) !== null && _b !== void 0 ? _b : item;
        let result = this.fhir.fishForPredefinedResource(item, ...types);
        if (result != null)
            return result;
        // First check for it in the package
        result = (_c = this.pkg) === null || _c === void 0 ? void 0 : _c.fishForFHIR(item, ...types);
        if (result == null) {
            // If it is in the tank, return undefined. We don't want to return the external FHIR
            // definition, even if it exists -- because it won't match what is in the tank.  This
            // ensures consistency between the outputs of fishForFHIR and fishForMetadata.
            if ((_d = this.tank) === null || _d === void 0 ? void 0 : _d.fish(item, ...types)) {
                return;
            }
            result = (_e = this.fhir) === null || _e === void 0 ? void 0 : _e.fishForFHIR(item, ...types);
        }
        return result;
    }
    /**
     * Searches for the Metadata associated with the passed in name/id/url.  It will first search
     * through the local package (which contains FHIR artifacts exported so far), then through the
     * tank, then through the external FHIR definitions. This function is useful because it gets
     * commonly used information without having to force an export. This helps to reduce the risk
     * of circular dependencies causing problems.
     * @param item - the item/name/id url to fish for
     * @param types - the allowable types to fish for
     */
    fishForMetadata(item, ...types) {
        var _a, _b, _c;
        // Resolve the alias if necessary
        item = (_b = (_a = this.tank) === null || _a === void 0 ? void 0 : _a.resolveAlias(item)) !== null && _b !== void 0 ? _b : item;
        let result = this.fhir.fishForPredefinedResourceMetadata(item, ...types);
        if (result != null)
            return result;
        const fishables = [this.pkg, this.tank, this.fhir].filter(f => f != null);
        for (const fishable of fishables) {
            result = fishable.fishForMetadata(item, ...types);
            if (result) {
                // If it came from the tank, we need to get the sdType because the tank doesn't know.
                if (fishable instanceof import_1.FSHTank) {
                    result.sdType = this.findSdType(result, types, fishables);
                }
                // When an Instance comes from the FSHTank, the FSHTank doesn't know its resourceType,
                // only its InstanceOf. But here we have access to the other fishers, so we can try
                // to figure that resourceType out here
                if (fishable instanceof import_1.FSHTank && !result.resourceType) {
                    const fshDefinition = fishable.fish(item, ...types);
                    if (fshDefinition instanceof fshtypes_1.Instance) {
                        result.resourceType = (_c = this.fishForMetadata(fshDefinition.instanceOf)) === null || _c === void 0 ? void 0 : _c.sdType;
                    }
                }
                // Add url to metadata for non-inline Instances
                if (!result.url && result.instanceUsage !== 'Inline') {
                    result.url = `${this.pkg.config.canonical}/${result.resourceType}/${result.id}`;
                }
                return result;
            }
        }
    }
    findSdType(meta, types, fishables) {
        var _a, _b, _c, _d, _e, _f;
        const history = [meta];
        let [sdType, parent] = [meta.sdType, meta.parent];
        while (sdType == null && parent != null) {
            // Resolve the alias if necessary
            parent = (_b = (_a = this.tank) === null || _a === void 0 ? void 0 : _a.resolveAlias(parent)) !== null && _b !== void 0 ? _b : parent;
            let parentResult;
            for (const fishable of fishables) {
                parentResult = fishable.fishForMetadata(parent, ...types);
                if (parentResult != null) {
                    if (history.some(md => md.url === parentResult.url)) {
                        let message = 'Circular dependency detected on parent relationships: ' +
                            [...history, parentResult].map(l => l.name).join(' < ');
                        const fhirMeta = (_d = (_c = this.fhir) === null || _c === void 0 ? void 0 : _c.fishForMetadata(parentResult.name)) !== null && _d !== void 0 ? _d : (_e = this.fhir) === null || _e === void 0 ? void 0 : _e.fishForMetadata(parentResult.id);
                        if (fhirMeta) {
                            message += `\n  If the parent ${parentResult.name} is intended to refer to the FHIR resource, use its URL: ${fhirMeta.url}`;
                        }
                        FSHLogger_1.logger.error(message, fishable instanceof import_1.FSHTank ? (_f = fishable.fish(parent)) === null || _f === void 0 ? void 0 : _f.sourceInfo : undefined);
                        return;
                    }
                    history.push(parentResult);
                    break; // break out of fishables loop
                }
            }
            [sdType, parent] = [parentResult === null || parentResult === void 0 ? void 0 : parentResult.sdType, parentResult === null || parentResult === void 0 ? void 0 : parentResult.parent];
        }
        return sdType;
    }
}
exports.MasterFisher = MasterFisher;
//# sourceMappingURL=MasterFisher.js.map