"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AUTOMATIC_DEPENDENCIES = void 0;
exports.isSupportedFHIRVersion = isSupportedFHIRVersion;
exports.ensureInputDir = ensureInputDir;
exports.hasFshFiles = hasFshFiles;
exports.findInputDir = findInputDir;
exports.ensureOutputDir = ensureOutputDir;
exports.readConfig = readConfig;
exports.updateConfig = updateConfig;
exports.updateExternalDependencies = updateExternalDependencies;
exports.loadExternalDependencies = loadExternalDependencies;
exports.loadAutomaticDependencies = loadAutomaticDependencies;
exports.getRawFSHes = getRawFSHes;
exports.fillTank = fillTank;
exports.checkNullValuesOnArray = checkNullValuesOnArray;
exports.writeFHIRResources = writeFHIRResources;
exports.writeFSHIndex = writeFSHIndex;
exports.writePreprocessedFSH = writePreprocessedFSH;
exports.init = init;
exports.getFilesRecursive = getFilesRecursive;
exports.getLocalSushiVersion = getLocalSushiVersion;
exports.getLatestSushiVersion = getLatestSushiVersion;
exports.checkSushiVersion = checkSushiVersion;
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const readline_sync_1 = __importDefault(require("readline-sync"));
const yaml_1 = __importDefault(require("yaml"));
const child_process_1 = require("child_process");
const types_1 = require("yaml/types");
const lodash_1 = require("lodash");
const fhir_package_loader_1 = require("fhir-package-loader");
const os_1 = require("os");
const FSHLogger_1 = require("./FSHLogger");
const fhirdefs_1 = require("../fhirdefs");
const import_1 = require("../import");
const axiosUtils_1 = require("./axiosUtils");
const FHIRVersionUtils_1 = require("../utils/FHIRVersionUtils");
const text_table_1 = __importDefault(require("text-table"));
const EXT_PKG_TO_FHIR_PKG_MAP = {
    'hl7.fhir.extensions.r2': 'hl7.fhir.r2.core#1.0.2',
    'hl7.fhir.extensions.r3': 'hl7.fhir.r3.core#3.0.2',
    'hl7.fhir.extensions.r4': 'hl7.fhir.r4.core#4.0.1',
    'hl7.fhir.extensions.r5': 'hl7.fhir.r5.core#5.0.0'
};
const CERTIFICATE_MESSAGE = '\n\nSometimes this error occurs in corporate or educational environments that use proxies and/or SSL ' +
    'inspection.\nTroubleshooting tips:\n' +
    '  1. If a non-proxied network is available, consider connecting to that network instead.\n' +
    '  2. Set NODE_EXTRA_CA_CERTS as described at https://bit.ly/3ghJqJZ (RECOMMENDED).\n' +
    '  3. Disable certificate validation as described at https://bit.ly/3syjzm7 (NOT RECOMMENDED).\n';
// For some context on implicit packages, see: https://chat.fhir.org/#narrow/stream/179239-tooling/topic/New.20Implicit.20Package/near/325318949
exports.AUTOMATIC_DEPENDENCIES = [
    {
        packageId: 'hl7.fhir.uv.tools',
        version: 'current'
    },
    {
        packageId: 'hl7.terminology.r4',
        version: 'latest',
        fhirVersions: ['R4', 'R4B']
    },
    {
        packageId: 'hl7.terminology.r5',
        version: 'latest',
        fhirVersions: ['R5']
    },
    {
        packageId: 'hl7.fhir.uv.extensions.r4',
        version: 'latest',
        fhirVersions: ['R4', 'R4B']
    },
    {
        packageId: 'hl7.fhir.uv.extensions.r5',
        version: 'latest',
        fhirVersions: ['R5']
    }
];
function isSupportedFHIRVersion(version) {
    // For now, allow current or any 4.x/5.x/6.x version of FHIR except 4.0.0. This is a quick check; not a guarantee.  If a user passes
    // in an invalid version that passes this test (e.g., 4.99.0), it is still expected to fail when we load dependencies.
    return version !== '4.0.0' && /^(current|[456]\.\d+.\d+(-.+)?)$/.test(version);
}
function ensureInputDir(input) {
    // If no input folder is specified, set default to current directory
    if (!input) {
        input = '.';
        FSHLogger_1.logger.info('path-to-fsh-defs defaulted to current working directory');
    }
    return input;
}
function hasFshFiles(path) {
    try {
        fs_extra_1.default.statSync(path);
        const files = getFilesRecursive(path).filter(file => file.endsWith('.fsh'));
        return files.length > 0;
    }
    catch (_a) {
        return false;
    }
}
function findInputDir(input) {
    const originalInput = input;
    const inputFshSubdirectoryPath = path_1.default.join(originalInput, 'input', 'fsh');
    const fshSubdirectoryPath = path_1.default.join(originalInput, 'fsh');
    const rootIgDataPath = path_1.default.join(originalInput, 'ig-data');
    const currentTankWithNoFsh = !fs_extra_1.default.existsSync(inputFshSubdirectoryPath) &&
        !fs_extra_1.default.existsSync(fshSubdirectoryPath) &&
        !fs_extra_1.default.existsSync(rootIgDataPath) &&
        !hasFshFiles(originalInput);
    // Use input/fsh/ subdirectory if not already specified and present
    // or when in the current tank configuration without FSH files
    if (fs_extra_1.default.existsSync(inputFshSubdirectoryPath) || currentTankWithNoFsh) {
        input = path_1.default.join(originalInput, 'input', 'fsh');
    }
    // TODO: Error about unsupported features. Remove when message no longer needed.
    // Use fsh/ subdirectory if not already specified and present
    if (!fs_extra_1.default.existsSync(inputFshSubdirectoryPath) && !currentTankWithNoFsh) {
        let msg = '\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n';
        if (fs_extra_1.default.existsSync(fshSubdirectoryPath)) {
            msg +=
                '\nSUSHI detected a "fsh" directory that will be used in the input path.\n' +
                    'Use of this folder is NO LONGER SUPPORTED.\n' +
                    'To migrate to the new folder structure, make the following changes:\n' +
                    `  - move fsh${path_1.default.sep}config.yaml to .${path_1.default.sep}sushi-config.yaml\n` +
                    `  - move fsh${path_1.default.sep}*.fsh files to .${path_1.default.sep}input${path_1.default.sep}fsh${path_1.default.sep}*.fsh\n`;
            if (fs_extra_1.default.existsSync(path_1.default.join(input, 'fsh', 'ig-data'))) {
                msg += `  - move fsh${path_1.default.sep}ig-data${path_1.default.sep}* files and folders to .${path_1.default.sep}*\n`;
            }
        }
        else {
            msg +=
                '\nSUSHI has adopted a new folder structure for FSH tanks (a.k.a. SUSHI projects).\n' +
                    'Support for other folder structures is NO LONGER SUPPORTED.\n' +
                    'To migrate to the new folder structure, make the following changes:\n' +
                    `  - rename .${path_1.default.sep}config.yaml to .${path_1.default.sep}sushi-config.yaml\n` +
                    `  - move .${path_1.default.sep}*.fsh files to .${path_1.default.sep}input${path_1.default.sep}fsh${path_1.default.sep}*.fsh\n`;
            if (fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data'))) {
                msg += `  - move .${path_1.default.sep}ig-data${path_1.default.sep}* files and folders to .${path_1.default.sep}*\n`;
            }
        }
        if (!fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data', 'ig.ini'))) {
            msg += `  - if you used the "template" property in your config, remove it and manage .${path_1.default.sep}ig.ini directly\n`;
        }
        if (!fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data', 'package-list.json'))) {
            msg += `  - if you used the "history" property in your config, remove it and manage .${path_1.default.sep}package-list.json directly\n`;
        }
        msg +=
            '  - ensure your .gitignore file is not configured to ignore the sources in their new locations\n' +
                '  - add /fsh-generated to your .gitignore file to prevent SUSHI output from being checked into source control\n\n' +
                `NOTE: After you make these changes, the default output folder for SUSHI will change to .${path_1.default.sep}fsh-generated.\n\n` +
                'For detailed migration instructions, see: https://fshschool.org/docs/sushi/migration/\n\n';
        FSHLogger_1.logger.error(msg);
    }
    return input;
}
function ensureOutputDir(input, output) {
    let outDir = output;
    if (!output) {
        // Default output is the parent folder of the input/fsh folder
        outDir = path_1.default.join(input, '..', '..');
        FSHLogger_1.logger.info(`No output path specified. Output to ${outDir}`);
    }
    fs_extra_1.default.ensureDirSync(outDir);
    // If the outDir contains a fsh-generated folder, we ensure that folder is empty
    const fshGeneratedFolder = path_1.default.join(outDir, 'fsh-generated');
    if (fs_extra_1.default.existsSync(fshGeneratedFolder)) {
        try {
            fs_extra_1.default.emptyDirSync(fshGeneratedFolder);
        }
        catch (e) {
            FSHLogger_1.logger.error(`Unable to empty existing fsh-generated folder because of the following error: ${e.message}`);
            if (e.stack) {
                FSHLogger_1.logger.debug(e.stack);
            }
        }
    }
    return outDir;
}
function readConfig(input) {
    const configPath = (0, import_1.ensureConfiguration)(input);
    let config;
    if (configPath == null || !fs_extra_1.default.existsSync(configPath)) {
        config = (0, import_1.loadConfigurationFromIgResource)(input);
    }
    else {
        const configYaml = fs_extra_1.default.readFileSync(configPath, 'utf8');
        config = (0, import_1.importConfiguration)(configYaml, configPath);
    }
    if (!config) {
        FSHLogger_1.logger.error(`No sushi-config.yaml in ${input} folder, and no configuration could` +
            ' be extracted from an ImplementationGuide resource.');
        throw Error;
    }
    if (!config.fhirVersion.some(v => isSupportedFHIRVersion(v))) {
        FSHLogger_1.logger.error(`The ${path_1.default.basename(config.filePath)} must specify a supported version of FHIR. Be sure to` +
            ` add "fhirVersion: 4.0.1" (or 4.x.y, 5.0.0-snapshot1, etc., as appropriate) to the ${path_1.default.basename(config.filePath)} file.`);
        throw Error;
    }
    return config;
}
function updateConfig(config, program) {
    if (program.config) {
        if (program.config.version) {
            config.version = program.config.version;
        }
        if (program.config.status) {
            config.status = program.config.status;
        }
        if (program.config.releaselabel) {
            const labelIndex = config.parameters.findIndex(p => p.code === 'releaselabel');
            if (labelIndex !== -1) {
                config.parameters[labelIndex].value = program.config.releaselabel;
            }
            else {
                config.parameters.push({
                    code: 'releaselabel',
                    value: program.config.releaselabel
                });
            }
        }
    }
}
async function updateExternalDependencies(config) {
    var _a;
    // only try to update if we got the config from sushi-config.yaml, and not from an IG
    const changedVersions = new Map();
    if (config.filePath == null) {
        FSHLogger_1.logger.info('Cannot update dependencies: no sushi-config.yaml file available.');
        return true;
    }
    if (!((_a = config.dependencies) === null || _a === void 0 ? void 0 : _a.length)) {
        FSHLogger_1.logger.info('Cannot update dependencies: no dependencies present in configuration.');
        return true;
    }
    const promises = config.dependencies.map(async (dep) => {
        var _a, _b, _c, _d, _e, _f;
        // current and dev have special meanings, so don't try to update those dependencies
        if (dep.version != 'current' && dep.version != 'dev') {
            let res;
            let latestVersion;
            if (process_1.default.env.FPL_REGISTRY) {
                try {
                    res = await (0, axiosUtils_1.axiosGet)(`${process_1.default.env.FPL_REGISTRY}/${dep.packageId}`);
                    latestVersion = (_b = (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a['dist-tags']) === null || _b === void 0 ? void 0 : _b.latest;
                }
                catch (_g) {
                    FSHLogger_1.logger.warn(`Could not get version info for package ${dep.packageId} from custom FHIR package registry ${process_1.default.env.FPL_REGISTRY}.`);
                    return;
                }
            }
            else {
                try {
                    res = await (0, axiosUtils_1.axiosGet)(`https://packages.fhir.org/${dep.packageId}`);
                    latestVersion = (_d = (_c = res === null || res === void 0 ? void 0 : res.data) === null || _c === void 0 ? void 0 : _c['dist-tags']) === null || _d === void 0 ? void 0 : _d.latest;
                }
                catch (_h) {
                    try {
                        res = await (0, axiosUtils_1.axiosGet)(`https://packages2.fhir.org/packages/${dep.packageId}`);
                        latestVersion = (_f = (_e = res === null || res === void 0 ? void 0 : res.data) === null || _e === void 0 ? void 0 : _e['dist-tags']) === null || _f === void 0 ? void 0 : _f.latest;
                    }
                    catch (_j) {
                        FSHLogger_1.logger.warn(`Could not get version info for package ${dep.packageId}`);
                        return;
                    }
                }
            }
            if (latestVersion) {
                if (dep.version !== latestVersion) {
                    dep.version = latestVersion;
                    changedVersions.set(dep.packageId, dep.version);
                }
            }
            else {
                FSHLogger_1.logger.warn(`Could not determine latest version for package ${dep.packageId}`);
            }
        }
    });
    await Promise.all(promises);
    if (changedVersions.size > 0) {
        // before changing the file, check with the user
        const continuationChoice = readline_sync_1.default.keyInYNStrict([
            'Updates to dependency versions detected:',
            ...Array.from(changedVersions.entries()).map(([packageId, version]) => `- ${packageId}: ${version}`),
            'SUSHI can apply these updates to your sushi-config.yaml file.',
            'This may affect the formatting of your file.',
            'Do you want to apply these updates?',
            '- [Y]es, apply updates to sushi-config.yaml',
            '- [N]o, quit without applying updates',
            'Choose one: '
        ].join('\n'));
        if (continuationChoice === true) {
            const configText = fs_extra_1.default.readFileSync(config.filePath, 'utf8');
            const configTree = yaml_1.default.parseDocument(configText);
            if (configTree.errors.length === 0) {
                const dependencyMap = configTree.get('dependencies');
                if (dependencyMap instanceof types_1.YAMLMap) {
                    dependencyMap.items.forEach(depPair => {
                        const configDep = config.dependencies.find(cd => cd.packageId === depPair.key.value);
                        if (configDep) {
                            if (depPair.value instanceof types_1.Collection) {
                                depPair.value.set('version', configDep.version);
                            }
                            else {
                                depPair.value.value = configDep.version;
                            }
                        }
                    });
                    fs_extra_1.default.writeFileSync(config.filePath, configTree.toString(), 'utf8');
                    FSHLogger_1.logger.info('Updated dependency versions in configuration to latest available versions.');
                }
            }
        }
        else {
            FSHLogger_1.logger.info('Dependencies not updated.');
            return false;
        }
    }
    else {
        FSHLogger_1.logger.info('No dependency updates available.');
    }
    return true;
}
async function loadExternalDependencies(defs, config) {
    var _a;
    // Add FHIR to the dependencies so it is loaded
    const dependencies = ((_a = config.dependencies) !== null && _a !== void 0 ? _a : []).slice(); // slice so we don't modify actual config;
    const fhirVersionInfo = config.fhirVersion
        .map(v => (0, FHIRVersionUtils_1.getFHIRVersionInfo)(v))
        .find(v => v.isSupported);
    if (fhirVersionInfo.isPreRelease) {
        FSHLogger_1.logger.warn('SUSHI support for pre-release versions of FHIR is experimental. Use at your own risk!');
    }
    dependencies.push({ packageId: fhirVersionInfo.packageId, version: fhirVersionInfo.version });
    // Load automatic dependencies first so they have lowest priority in resolution
    await loadAutomaticDependencies(fhirVersionInfo.version, dependencies, defs);
    // Then load configured dependencies, with FHIR core last so it has highest priority in resolution
    await loadConfiguredDependencies(dependencies, fhirVersionInfo.version, config.filePath, defs);
}
async function loadAutomaticDependencies(fhirVersion, configuredDependencies, defs) {
    const fhirVersionName = (0, FHIRVersionUtils_1.getFHIRVersionInfo)(fhirVersion).name;
    // Load dependencies serially so dependency loading order is predictable and repeatable
    for (const dep of exports.AUTOMATIC_DEPENDENCIES) {
        // Skip dependencies not intended for this version of FHIR
        if (dep.fhirVersions && !dep.fhirVersions.includes(fhirVersionName)) {
            continue;
        }
        const alreadyConfigured = configuredDependencies.some(cd => {
            // hl7.some.package, hl7.some.package.r4, and hl7.some.package.r5 all represent the same content,
            // so they are essentially interchangeable and we should allow for any of them in the config.
            // See: https://chat.fhir.org/#narrow/stream/179239-tooling/topic/New.20Implicit.20Package/near/325488084
            const [configRootId, packageRootId] = [cd.packageId, dep.packageId].map(id => /\.r[4-9]$/.test(id) ? id.slice(0, -3) : id);
            return configRootId === packageRootId;
        });
        if (!alreadyConfigured) {
            try {
                await (0, fhir_package_loader_1.mergeDependency)(dep.packageId, dep.version, defs, undefined, FSHLogger_1.logMessage);
            }
            catch (e) {
                let message = `Failed to load automatically-provided ${dep.packageId}#${dep.version}`;
                if (process_1.default.env.FPL_REGISTRY) {
                    message += ` from custom FHIR package registry ${process_1.default.env.FPL_REGISTRY}.`;
                }
                message += `: ${e.message}`;
                if (/certificate/.test(e.message)) {
                    message += CERTIFICATE_MESSAGE;
                }
                FSHLogger_1.logger.warn(message);
                if (e.stack) {
                    FSHLogger_1.logger.debug(e.stack);
                }
            }
        }
    }
}
async function loadConfiguredDependencies(dependencies, fhirVersion, configPath, defs) {
    var _a;
    // Load dependencies serially so dependency loading order is predictable and repeatable
    for (const dep of dependencies) {
        if (dep.version == null) {
            FSHLogger_1.logger.error(`Failed to load ${dep.packageId}: No version specified. To specify the version in your ` +
                `${path_1.default.basename(configPath)}, either use the simple dependency format:\n\n` +
                'dependencies:\n' +
                `  ${dep.packageId}: current\n\n` +
                'or use the detailed dependency format to specify other properties as well:\n\n' +
                'dependencies:\n' +
                `  ${dep.packageId}:\n` +
                `    uri: ${(_a = dep.uri) !== null && _a !== void 0 ? _a : 'http://my-fhir-ig.org/ImplementationGuide/123'}\n` +
                '    version: current');
            continue;
        }
        else if (EXT_PKG_TO_FHIR_PKG_MAP[dep.packageId]) {
            // It is a special "virtual" FHIR extensions package indicating we need to load supplemental
            // FHIR versions to support "implied extensions".
            if (dep.version !== fhirVersion) {
                FSHLogger_1.logger.warn(`Incorrect package version: ${dep.packageId}#${dep.version}. FHIR extensions packages ` +
                    "should use the same version as the implementation guide's fhirVersion. Version " +
                    `${fhirVersion} will be used instead. Update the dependency version in ` +
                    'sushi-config.yaml to eliminate this warning.');
            }
            FSHLogger_1.logger.info(`Loading supplemental version of FHIR to support extensions from ${dep.packageId}`);
            await (0, fhirdefs_1.loadSupplementalFHIRPackage)(EXT_PKG_TO_FHIR_PKG_MAP[dep.packageId], defs);
        }
        else {
            await (0, fhir_package_loader_1.mergeDependency)(dep.packageId, dep.version, defs, undefined, FSHLogger_1.logMessage).catch(e => {
                let message = `Failed to load ${dep.packageId}#${dep.version}: ${e.message}`;
                if (/certificate/.test(e.message)) {
                    message += CERTIFICATE_MESSAGE;
                }
                FSHLogger_1.logger.error(message);
                if (e.stack) {
                    FSHLogger_1.logger.debug(e.stack);
                }
            });
        }
    }
}
function getRawFSHes(input) {
    let files;
    try {
        fs_extra_1.default.statSync(input);
        files = getFilesRecursive(input);
    }
    catch (_a) {
        FSHLogger_1.logger.error('Invalid path to FSH definition folder.');
        throw Error;
    }
    const rawFSHes = files
        .filter(file => file.endsWith('.fsh'))
        .map(file => {
        const filePath = path_1.default.resolve(file);
        const fileContent = fs_extra_1.default.readFileSync(filePath, 'utf8');
        return new import_1.RawFSH(fileContent, filePath);
    });
    return rawFSHes;
}
function fillTank(rawFSHes, config) {
    FSHLogger_1.logger.info('Importing FSH text...');
    const docs = (0, import_1.importText)(rawFSHes);
    return new import_1.FSHTank(docs, config);
}
function checkNullValuesOnArray(resource, parentName = '', priorPath = '') {
    var _a;
    const resourceName = parentName ? parentName : ((_a = resource.id) !== null && _a !== void 0 ? _a : resource.name);
    for (const propertyKey in resource) {
        const property = resource[propertyKey];
        const currentPath = !priorPath ? propertyKey : priorPath.concat(`.${propertyKey}`);
        // If a property's key begins with "_", we'll want to ignore null values on it's top level
        // but still check any nested objects for null values
        if (propertyKey.startsWith('_')) {
            if ((0, lodash_1.isPlainObject)(property)) {
                // If we encounter an object property, we'll want to check its properties as well
                checkNullValuesOnArray(property, resourceName, currentPath);
            }
            if (Array.isArray(property)) {
                property.forEach((element, index) => {
                    if ((0, lodash_1.isPlainObject)(element)) {
                        // If we encounter an object property, we'll want to check its properties as well
                        checkNullValuesOnArray(element, resourceName, `${currentPath}[${index}]`);
                    }
                });
            }
        }
        else {
            if ((0, lodash_1.isPlainObject)(property)) {
                // If we encounter an object property, we'll want to check its properties as well
                checkNullValuesOnArray(property, resourceName, currentPath);
            }
            if (Array.isArray(property)) {
                const nullIndexes = [];
                const hasUnderscoreArray = Array.isArray(resource[`_${propertyKey}`]);
                property.forEach((element, index) => {
                    // if property is a primitive array, also check the corresponding index in the underscore property
                    if (element === null &&
                        (!hasUnderscoreArray || resource[`_${propertyKey}`][index] == null)) {
                        nullIndexes.push(index);
                    }
                    if ((0, lodash_1.isPlainObject)(element)) {
                        // If we encounter an object property, we'll want to check its properties as well
                        checkNullValuesOnArray(element, resourceName, `${currentPath}[${index}]`);
                    }
                });
                if (nullIndexes.length > 0) {
                    FSHLogger_1.logger.warn(`The array '${currentPath}' in ${resourceName} is missing values at the following indices: ${nullIndexes}`);
                }
            }
        }
    }
}
function writeFHIRResources(outDir, outPackage, defs, snapshot) {
    FSHLogger_1.logger.info('Exporting FHIR resources as JSON...');
    let count = 0;
    const skippedResources = [];
    const predefinedResources = defs.allPredefinedResources(false);
    const writeResources = (resources) => {
        const exportDir = path_1.default.join(outDir, 'fsh-generated', 'resources');
        resources.forEach(resource => {
            var _a;
            if (!predefinedResources.find(predef => predef.url === resource.url &&
                predef.resourceType === resource.resourceType &&
                predef.id === resource.id)) {
                checkNullValuesOnArray(resource);
                fs_extra_1.default.outputJSONSync(path_1.default.join(exportDir, resource.getFileName()), resource.toJSON(snapshot), {
                    spaces: 2
                });
                count++;
            }
            else {
                FSHLogger_1.logger.error(`Ignoring FSH definition for ${(_a = resource.url) !== null && _a !== void 0 ? _a : `${resource.resourceType}/${resource.id}`} since it duplicates existing pre-defined resource. ` +
                    'To use the FSH definition, remove the conflicting file from "input". ' +
                    'If you do want the FSH definition to be ignored, please comment the definition out ' +
                    'to remove this error.');
                skippedResources.push(resource.getFileName());
            }
        });
    };
    writeResources(outPackage.profiles);
    writeResources(outPackage.extensions);
    writeResources(outPackage.logicals);
    // WARNING: While custom resources are written to disk, the IG Publisher does not
    //          accept newly defined resources. However, it is configured to automatically
    //          search the fsh-generated directory for StructureDefinitions rather than using
    //          the StructureDefinitions defined in the exported implementation guide. So, be
    //          aware that the IG Publisher will attempt to process custom resources.
    //          NOTE: To mitigate against this, the parameter 'autoload-resources = false' is
    //          injected automatically into the IG array pf parameters if the parameter was
    //          not already defined and only if the custom resources were generated by Sushi.
    writeResources(outPackage.resources);
    writeResources([...outPackage.valueSets, ...outPackage.codeSystems]);
    // Filter out inline instances
    writeResources(outPackage.instances.filter(i => i._instanceMeta.usage !== 'Inline'));
    FSHLogger_1.logger.info(`Exported ${count} FHIR resources as JSON.`);
    return { skippedResources };
}
function writeFSHIndex(outDir, outPackage, inputDir, skippedResources = []) {
    const textIndex = [];
    const jsonIndex = [];
    [...outPackage.fshMap.keys()]
        .filter(fileName => !skippedResources.includes(fileName))
        .sort()
        .forEach(fileName => {
        const fshInfo = outPackage.fshMap.get(fileName);
        const relativeInput = path_1.default.relative(inputDir, fshInfo.file);
        textIndex.push([
            fileName,
            fshInfo.fshName,
            fshInfo.fshType,
            relativeInput,
            `${fshInfo.location.startLine} - ${fshInfo.location.endLine}`
        ]);
        jsonIndex.push({
            outputFile: fileName,
            fshName: fshInfo.fshName,
            fshType: fshInfo.fshType,
            fshFile: relativeInput,
            startLine: fshInfo.location.startLine,
            endLine: fshInfo.location.endLine
        });
    });
    // write txt with nice formatting
    textIndex.unshift(['Output File', 'Name', 'Type', 'FSH File', 'Lines']);
    fs_extra_1.default.outputFileSync(path_1.default.join(outDir, 'fsh-generated', 'fsh-index.txt'), (0, text_table_1.default)(textIndex));
    // write json for machine usage
    fs_extra_1.default.outputJsonSync(path_1.default.join(outDir, 'fsh-generated', 'fsh-index.json'), jsonIndex, { spaces: 2 });
}
function writePreprocessedFSH(outDir, inDir, tank) {
    const preprocessedPath = path_1.default.join(outDir, '_preprocessed');
    fs_extra_1.default.ensureDirSync(preprocessedPath);
    // Because this is the FSH that exists after processing, some entities from the original FSH are gone.
    // Specifically, RuleSets have already been applied.
    // Aliases have already been resolved for most cases, but since they may still
    // be used in a slice name, they are included.
    tank.docs.forEach(doc => {
        let fileContent = '';
        // First, get all Aliases. They don't have source information.
        if (doc.aliases.size > 0) {
            doc.aliases.forEach((url, alias) => {
                fileContent += `Alias: ${alias} = ${url}${os_1.EOL}`;
            });
            fileContent += os_1.EOL;
        }
        // Then, get all other applicable entities. They will have source information.
        const entities = [
            ...doc.profiles.values(),
            ...doc.extensions.values(),
            ...doc.logicals.values(),
            ...doc.resources.values(),
            ...doc.instances.values(),
            ...doc.valueSets.values(),
            ...doc.codeSystems.values(),
            ...doc.invariants.values(),
            ...doc.mappings.values()
        ];
        // Sort entities by original line number, then write them out.
        (0, lodash_1.sortBy)(entities, 'sourceInfo.location.startLine').forEach(entity => {
            fileContent += `// Originally defined on lines ${entity.sourceInfo.location.startLine} - ${entity.sourceInfo.location.endLine}${os_1.EOL}`;
            fileContent += `${entity.toFSH()}${os_1.EOL}${os_1.EOL}`;
        });
        if (fileContent.length === 0) {
            fileContent = '// This file has no content after preprocessing.';
        }
        const outPath = path_1.default.relative(inDir, doc.file);
        fs_extra_1.default.ensureFileSync(path_1.default.join(preprocessedPath, outPath));
        fs_extra_1.default.writeFileSync(path_1.default.join(preprocessedPath, outPath), fileContent);
    });
    FSHLogger_1.logger.info(`Wrote preprocessed FSH to ${preprocessedPath}`);
}
/**
 * Initializes an empty sample FSH within a user specified subdirectory of the current working directory
 */
async function init(name = null, options = {}) {
    console.log('\n╭───────────────────────────────────────────────────────────╮\n' +
        '│ This interactive tool will use your answers to create a   │\n' +
        "│ working SUSHI project configured with your project's      │\n" +
        '│ basic information. Any answers provided as command line   │\n' +
        '│ options will be used automatically.                       │\n' +
        '╰───────────────────────────────────────────────────────────╯\n');
    const configDoc = yaml_1.default.parseDocument(fs_extra_1.default.readFileSync(path_1.default.join(__dirname, 'init-project', 'sushi-config.yaml'), 'utf-8'));
    // Accept user input for certain fields directly or from CLI options
    ['name', 'id', 'canonical', 'status', 'version', 'releaseLabel'].forEach(field => {
        var _a;
        let userValue;
        if (((_a = options.config) === null || _a === void 0 ? void 0 : _a[field.toLowerCase()]) != null) {
            userValue = options.config[field.toLowerCase()];
            console.log(`${(0, lodash_1.startCase)(field)}: ${options.config[field.toLowerCase()]}`);
        }
        else if (field === 'name' && name != null) {
            // name is an argument on the CLI (not an option) so handle it separately
            userValue = name;
            console.log(`Name: ${name}`);
        }
        else if (options.default) {
            console.log(`${(0, lodash_1.startCase)(field)}: ${configDoc.get(field)}`);
        }
        else {
            userValue = readline_sync_1.default.question(`${(0, lodash_1.startCase)(field)} (Default: ${configDoc.get(field)}): `);
        }
        if (userValue) {
            if (field === 'status') {
                const node = yaml_1.default.createNode(userValue);
                node.comment = ' draft | active | retired | unknown';
                configDoc.set(field, node);
            }
            else {
                configDoc.set(field, userValue);
            }
        }
    });
    // And for nested publisher fields
    ['name', 'url'].forEach(field => {
        var _a;
        let userValue;
        if (((_a = options.config) === null || _a === void 0 ? void 0 : _a[`publisher-${field}`]) != null) {
            userValue = options.config[`publisher-${field}`];
            console.log(`Publisher ${(0, lodash_1.upperFirst)(field)}: ${options.config[`publisher-${field}`]}`);
        }
        else if (options.default) {
            console.log(`Publisher ${(0, lodash_1.upperFirst)(field)}: ${configDoc.get('publisher').get(field)}`);
        }
        else {
            userValue = readline_sync_1.default.question(`Publisher ${(0, lodash_1.upperFirst)(field)} (Default: ${configDoc.get('publisher').get(field)}): `);
        }
        if (userValue) {
            configDoc.get('publisher').set(field, userValue);
        }
    });
    // Ensure copyrightYear is accurate
    configDoc.set('copyrightYear', `${new Date().getFullYear()}+`);
    const projectName = configDoc.get('name');
    // Write init directory out, including user made sushi-config.yaml and files in utils/init-project
    const outputDir = path_1.default.resolve('.', projectName);
    const initProjectDir = path_1.default.join(__dirname, 'init-project');
    if (options.autoInitialize) {
        console.log(`Initializing SUSHI project in ${outputDir}`);
    }
    else if (!readline_sync_1.default.keyInYN(`Initialize SUSHI project in ${outputDir}?`)) {
        console.log('\nAborting Initialization.\n');
        return;
    }
    // Add index.md content, updating to reflect the user given name
    const indexPageContent = fs_extra_1.default
        .readFileSync(path_1.default.join(initProjectDir, 'index.md'), 'utf-8')
        .replace('ExampleIG', projectName);
    fs_extra_1.default.ensureDirSync(path_1.default.join(outputDir, 'input', 'pagecontent'));
    fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, 'input', 'pagecontent', 'index.md'), indexPageContent);
    // Add ig.ini, updating to reflect the user given id
    const iniContent = fs_extra_1.default
        .readFileSync(path_1.default.join(initProjectDir, 'ig.ini'), 'utf-8')
        .replace('fhir.example', configDoc.get('id'));
    fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, 'ig.ini'), iniContent);
    // Add the config
    fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, 'sushi-config.yaml'), configDoc.toString());
    // Copy over remaining static files
    fs_extra_1.default.ensureDirSync(path_1.default.join(outputDir, 'input', 'fsh'));
    fs_extra_1.default.copyFileSync(path_1.default.join(initProjectDir, 'patient.fsh'), path_1.default.join(outputDir, 'input', 'fsh', 'patient.fsh'));
    fs_extra_1.default.copyFileSync(path_1.default.join(initProjectDir, 'init-gitignore.txt'), path_1.default.join(outputDir, '.gitignore'));
    fs_extra_1.default.copyFileSync(path_1.default.join(initProjectDir, 'ignoreWarnings.txt'), path_1.default.join(outputDir, 'input', 'ignoreWarnings.txt'));
    // Add the _updatePublisher, _genonce, and _gencontinuous scripts
    console.log('Downloading publisher scripts from https://github.com/HL7/ig-publisher-scripts');
    for (const script of [
        '_genonce.bat',
        '_genonce.sh',
        '_updatePublisher.bat',
        '_updatePublisher.sh'
    ]) {
        const url = `https://raw.githubusercontent.com/HL7/ig-publisher-scripts/main/${script}`;
        try {
            const res = await (0, axiosUtils_1.axiosGet)(url);
            fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, script), res.data);
            if (script.endsWith('.sh')) {
                fs_extra_1.default.chmodSync(path_1.default.join(outputDir, script), 0o755);
            }
        }
        catch (e) {
            FSHLogger_1.logger.error(`Unable to download ${script} from ${url}: ${e.message}`);
            if (e.stack) {
                FSHLogger_1.logger.debug(e.stack);
            }
        }
    }
    const maxLength = 32;
    const printName = projectName.length > maxLength ? projectName.slice(0, maxLength - 3) + '...' : projectName;
    console.log('\n╭───────────────────────────────────────────────────────────╮\n' +
        `│ Project initialized at: ./${(0, lodash_1.padEnd)(printName, maxLength)}│\n` +
        '├───────────────────────────────────────────────────────────┤\n' +
        '│ Now try this:                                             │\n' +
        '│                                                           │\n' +
        `│ > cd ${(0, lodash_1.padEnd)(printName, maxLength + 21)}│\n` +
        '│ > sushi .                                                 │\n' +
        '│                                                           │\n' +
        '│ For guidance on project structure and configuration see   │\n' +
        '│ the SUSHI documentation: https://fshschool.org/docs/sushi │\n' +
        '╰───────────────────────────────────────────────────────────╯\n');
}
function getFilesRecursive(dir) {
    // always return absolute paths
    const absPath = path_1.default.resolve(dir);
    try {
        if (fs_extra_1.default.statSync(absPath).isDirectory()) {
            const descendants = fs_extra_1.default
                .readdirSync(absPath, 'utf8')
                .map(f => getFilesRecursive(path_1.default.join(absPath, f)));
            return [].concat(...descendants);
        }
        else {
            return [absPath];
        }
    }
    catch (_a) {
        return [];
    }
}
function getLocalSushiVersion() {
    var _a;
    const packageJSONPath = path_1.default.join(__dirname, '..', '..', 'package.json');
    if (fs_extra_1.default.existsSync(packageJSONPath)) {
        return (_a = fs_extra_1.default.readJSONSync(packageJSONPath)) === null || _a === void 0 ? void 0 : _a.version;
    }
    return null;
}
async function getLatestSushiVersionFallback() {
    FSHLogger_1.logger.info('Attempting fallback to determine version of sushi.');
    try {
        const res = await (0, axiosUtils_1.axiosGet)('https://registry.npmjs.org/fsh-sushi');
        const latestVer = res.data['dist-tags'].latest;
        if (latestVer.match(/^[0-9\.]*$/)) {
            return latestVer;
        }
        else {
            FSHLogger_1.logger.warn('Unable to determine the latest version of sushi.');
        }
    }
    catch (e) {
        FSHLogger_1.logger.warn(`Unable to determine the latest version of sushi: ${e.message}`);
        if (e.stack) {
            FSHLogger_1.logger.debug(e.stack);
        }
    }
}
async function getLatestSushiVersion() {
    var _a, _b;
    let latestVer = undefined;
    const getRegistryCmd = 'npm view fsh-sushi version';
    try {
        const execResult = (_b = (_a = (0, child_process_1.execSync)(getRegistryCmd)) === null || _a === void 0 ? void 0 : _a.toString()) === null || _b === void 0 ? void 0 : _b.replace(/\s*$/, '');
        if (execResult.match(/^[0-9\.]*$/)) {
            latestVer = execResult;
        }
    }
    catch (e) {
        FSHLogger_1.logger.info(`Unable to determine the latest version of sushi: ${e.message}`);
        if (e.stack) {
            FSHLogger_1.logger.debug(e.stack);
        }
    }
    if (latestVer === undefined) {
        latestVer = await getLatestSushiVersionFallback();
    }
    return latestVer;
}
async function checkSushiVersion() {
    const latest = await getLatestSushiVersion();
    const current = getLocalSushiVersion();
    return { latest, current };
}
//# sourceMappingURL=Processing.js.map