"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fishForFHIRBestVersion = fishForFHIRBestVersion;
exports.fishForMetadataBestVersion = fishForMetadataBestVersion;
exports.fishInTankBestVersion = fishInTankBestVersion;
const fshtypes_1 = require("../fshtypes");
const common_1 = require("../fhirtypes/common");
const FSHLogger_1 = require("./FSHLogger");
// Use the provided fisher to fish for the item, which might have a |version appended.
// If found, return it. If not found, try to remove any |version info and fish for any available version.
function fishForFHIRBestVersion(fisher, item, sourceInfo, ...types) {
    let result = fisher.fishForFHIR(item, ...types);
    // If the item was not found, try slicing off a version and searching for any version
    if (result == null && (item === null || item === void 0 ? void 0 : item.includes('|'))) {
        const [base, ...versionParts] = item.split('|');
        const version = versionParts.join('|') || null;
        result = fisher.fishForFHIR(base, ...types);
        if (version != null && (result === null || result === void 0 ? void 0 : result.version) != null && version != result.version) {
            FSHLogger_1.logger.warn(`${item} was requested, but SUSHI found ${base}|${result.version}`, sourceInfo);
        }
    }
    return result;
}
// Use the provided fisher to fish for the item's metadata.
// If found, return it. If not found, try to remove any |version info and fish for any available version.
function fishForMetadataBestVersion(fisher, item, sourceInfo, ...types) {
    if (fisher == null) {
        return;
    }
    let metadata = fisher.fishForMetadata(item, ...types);
    // If the item was not found, try slicing off a version and searching for any version
    if (metadata == null && (item === null || item === void 0 ? void 0 : item.includes('|'))) {
        const [base, ...versionParts] = item.split('|');
        const version = versionParts.join('|') || null;
        metadata = fisher.fishForMetadata(base, ...types);
        if (version != null && (metadata === null || metadata === void 0 ? void 0 : metadata.version) != null && version != metadata.version) {
            FSHLogger_1.logger.warn(`${item} was requested, but SUSHI found ${base}|${metadata.version}`, sourceInfo);
        }
    }
    return metadata;
}
// Use the provided tank to fish for the item, which might have a |version appended.
// If the specified version is found, return it. If not found, try to remove any |version info and fish for any available version.
function fishInTankBestVersion(tank, item, sourceInfo, ...types) {
    let result = tank.fish(item, ...types);
    // If the item was not found, try slicing off a version and searching for any version
    if (result == null && item != null && item.includes('|')) {
        const [base, ...versionParts] = item.split('|');
        const version = versionParts.join('|') || null;
        result = tank.fish(base, ...types);
        if (result != null) {
            let resultVersion = tank.config.version;
            if (!(result instanceof fshtypes_1.Invariant || result instanceof fshtypes_1.RuleSet || result instanceof fshtypes_1.Mapping)) {
                resultVersion = (0, common_1.getVersionFromFshDefinition)(result, tank.config.version);
            }
            if (version != null && resultVersion != null && version != resultVersion) {
                FSHLogger_1.logger.warn(`${item} was requested, but SUSHI found ${base}|${resultVersion}`, sourceInfo);
            }
        }
    }
    return result;
}
//# sourceMappingURL=FishingUtils.js.map