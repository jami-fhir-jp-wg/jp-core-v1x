import * as pc from './parserContexts';
import { FSHDocument } from './FSHDocument';
import { RawFSH } from './RawFSH';
import FSHVisitor from './generated/FSHVisitor';
import { FshCanonical, FshCode, FshQuantity, FshRatio, FshReference, InstanceUsage, ValueSetComponentFrom, ValueSetFilter, ValueSetFilterValue, ParamRuleSet, ExtensionContext } from '../fshtypes';
import { CardRule, FlagRule, BindingRule, AssignmentRule, AssignmentValueType, OnlyRule, ContainsRule, CaretValueRule, ObeysRule, MappingRule, InsertRule, ConceptRule, ValueSetComponentRule, SdRule, LrRule, AddElementRule, PathRule } from '../fshtypes/rules';
import { ParserRuleContext } from 'antlr4';
declare enum SdMetadataKey {
    Id = "Id",
    Parent = "Parent",
    Title = "Title",
    Description = "Description",
    Unknown = "Unknown"
}
declare enum InstanceMetadataKey {
    InstanceOf = "InstanceOf",
    Title = "Title",
    Description = "Description",
    Usage = "Usage",
    Unknown = "Unknown"
}
declare enum VsMetadataKey {
    Id = "Id",
    Title = "Title",
    Description = "Description",
    Unknown = "Unknown"
}
declare enum CsMetadataKey {
    Id = "Id",
    Title = "Title",
    Description = "Description",
    Unknown = "Unknown"
}
declare enum InvariantMetadataKey {
    Description = "Description",
    Expression = "Expression",
    XPath = "XPath",
    Severity = "Severity",
    Unknown = "Unknown"
}
declare enum MappingMetadataKey {
    Id = "Id",
    Source = "Source",
    Target = "Target",
    Description = "Description",
    Title = "Title",
    Unknown = "Unknown"
}
declare enum Flag {
    MustSupport = 0,
    Summary = 1,
    Modifier = 2,
    TrialUse = 3,
    Normative = 4,
    Draft = 5,
    Unknown = 6
}
/**
 * FSHImporter handles the parsing of FSH documents, constructing the data into FSH types.
 * FSHImporter uses a visitor pattern approach with some accomodations due to the ANTLR4
 * implementation and TypeScript requirements.  For example, the `accept` functions that
 * each `ctx` has cannot be used because their signatures return `void` by default. Instead,
 * we must call the explicit visitX functions.
 */
export declare class FSHImporter extends FSHVisitor {
    private docs;
    private currentFile;
    private currentDoc;
    private allAliases;
    paramRuleSets: Map<string, ParamRuleSet>;
    private topLevelParse;
    private pathContext;
    constructor();
    import(rawFSHes: RawFSH[]): FSHDocument[];
    visitDoc(ctx: pc.DocContext): void;
    visitEntity(ctx: pc.EntityContext): void;
    visitProfile(ctx: pc.ProfileContext): void;
    visitExtension(ctx: pc.ExtensionContext): void;
    private parseProfileOrExtension;
    visitResource(ctx: pc.ResourceContext): void;
    visitLogical(ctx: pc.LogicalContext): void;
    private parseResourceOrLogical;
    visitInstance(ctx: pc.InstanceContext): void;
    private parseInstance;
    visitValueSet(ctx: pc.ValueSetContext): void;
    private parseValueSet;
    visitCodeSystem(ctx: pc.CodeSystemContext): void;
    private parseCodeSystem;
    visitInvariant(ctx: pc.InvariantContext): void;
    private parseInvariant;
    visitRuleSet(ctx: pc.RuleSetContext): void;
    private parseRuleSet;
    visitParamRuleSet(ctx: pc.ParamRuleSetContext): void;
    visitParamRuleSetContent(ctx: pc.ParamRuleSetContentContext): string;
    visitMapping(ctx: pc.MappingContext): void;
    private parseMapping;
    visitSdMetadata(ctx: pc.SdMetadataContext): {
        key: SdMetadataKey;
        value: string | string[];
    };
    visitInstanceMetadata(ctx: pc.InstanceMetadataContext): {
        key: InstanceMetadataKey;
        value: string | string[];
    };
    visitVsMetadata(ctx: pc.VsMetadataContext): {
        key: VsMetadataKey;
        value: string;
    };
    visitCsMetadata(ctx: pc.CsMetadataContext): {
        key: CsMetadataKey;
        value: string;
    };
    visitInvariantMetadata(ctx: pc.InvariantMetadataContext): {
        key: InvariantMetadataKey;
        value: string | FshCode;
    };
    visitMappingMetadata(ctx: pc.MappingMetadataContext): {
        key: MappingMetadataKey;
        value: string;
    };
    visitId(ctx: pc.IdContext): string;
    visitParent(ctx: pc.ParentContext): string;
    visitTitle(ctx: pc.TitleContext): string;
    visitDescription(ctx: pc.DescriptionContext): string;
    visitInstanceOf(ctx: pc.InstanceOfContext): string;
    visitUsage(ctx: pc.UsageContext): InstanceUsage;
    visitExpression(ctx: pc.ExpressionContext): string;
    visitXpath(ctx: pc.XpathContext): string;
    visitSeverity(ctx: pc.SeverityContext): FshCode;
    visitSource(ctx: pc.SourceContext): string;
    visitTarget(ctx: pc.TargetContext): string;
    visitContext(ctx: pc.ContextContext): ExtensionContext[];
    visitCharacteristics(ctx: pc.CharacteristicsContext): string[];
    private parseCodeLexeme;
    visitLrRule(ctx: pc.LrRuleContext): LrRule[];
    visitAddElementRule(ctx: pc.AddElementRuleContext): AddElementRule;
    visitAddCRElementRule(ctx: pc.AddCRElementRuleContext): AddElementRule;
    private parseNewElement;
    visitSdRule(ctx: pc.SdRuleContext): SdRule[];
    visitInstanceRule(ctx: pc.InstanceRuleContext): AssignmentRule | InsertRule | PathRule;
    visitVsRule(ctx: pc.VsRuleContext): ValueSetComponentRule | CaretValueRule | InsertRule;
    visitCsRule(ctx: pc.CsRuleContext): ConceptRule | CaretValueRule | InsertRule;
    visitInvariantRule(ctx: pc.InvariantRuleContext): AssignmentRule | InsertRule;
    visitMappingEntityRule(ctx: pc.MappingEntityRuleContext): MappingRule | InsertRule;
    getPathWithContext(path: string, parentCtx: ParserRuleContext, isPathRule?: boolean, isInstanceRule?: boolean): string;
    getArrayPathWithContext(pathArray: string[], parentCtx: ParserRuleContext, isPathRule?: boolean, isInstanceRule?: boolean, suppressError?: boolean): string[];
    visitPath(ctx: pc.PathContext): string;
    visitCaretPath(ctx: pc.CaretPathContext): string;
    visitCardRule(ctx: pc.CardRuleContext): (CardRule | FlagRule)[];
    private parseCard;
    visitFlagRule(ctx: pc.FlagRuleContext): FlagRule[];
    private parseFlags;
    visitFlag(ctx: pc.FlagContext): Flag;
    visitValueSetRule(ctx: pc.ValueSetRuleContext): BindingRule;
    visitStrength(ctx: pc.StrengthContext): string;
    visitFixedValueRule(ctx: pc.FixedValueRuleContext): AssignmentRule;
    visitValue(ctx: pc.ValueContext): AssignmentValueType;
    visitCode(ctx: pc.CodeContext): FshCode;
    visitConcept(ctx: pc.ConceptContext): ConceptRule;
    visitQuantity(ctx: pc.QuantityContext): FshQuantity;
    visitRatio(ctx: pc.RatioContext): FshRatio;
    visitRatioPart(ctx: pc.RatioPartContext): FshQuantity;
    visitReference(ctx: pc.ReferenceContext): FshReference;
    private parseOrReference;
    visitCanonical(ctx: pc.CanonicalContext): FshCanonical[];
    visitBool(ctx: pc.BoolContext): boolean;
    visitOnlyRule(ctx: pc.OnlyRuleContext): OnlyRule;
    private parseTargetType;
    visitContainsRule(ctx: pc.ContainsRuleContext): (ContainsRule | CardRule | FlagRule)[];
    visitCaretValueRule(ctx: pc.CaretValueRuleContext): CaretValueRule;
    visitCodeCaretValueRule(ctx: pc.CodeCaretValueRuleContext, keepSystem?: boolean): CaretValueRule;
    visitObeysRule(ctx: pc.ObeysRuleContext): ObeysRule[];
    visitPathRule(ctx: pc.PathRuleContext, isInstanceRule?: boolean): PathRule;
    visitCodeInsertRule(ctx: pc.CodeInsertRuleContext, keepSystem?: boolean): InsertRule;
    visitInsertRule(ctx: pc.InsertRuleContext, withPathArray?: boolean): InsertRule;
    private parseRuleSetReference;
    private parseInsertRuleParams;
    private applyRuleSetParams;
    private parseGeneratedRuleSet;
    visitMappingRule(ctx: pc.MappingRuleContext): MappingRule;
    visitVsComponent(ctx: pc.VsComponentContext): ValueSetComponentRule;
    visitVsConceptComponent(ctx: pc.VsConceptComponentContext): [FshCode[], ValueSetComponentFrom];
    visitVsFilterComponent(ctx: pc.VsFilterComponentContext): [ValueSetFilter[], ValueSetComponentFrom];
    visitVsComponentFrom(ctx: pc.VsComponentFromContext): ValueSetComponentFrom;
    /**
     * The replace makes FSH permissive in regards to the official specifications,
     * which spells operator "descendant-of" as "descendent-of".
     * @see {@link http://hl7.org/fhir/valueset-filter-operator.html}
     */
    visitVsFilterDefinition(ctx: pc.VsFilterDefinitionContext): ValueSetFilter;
    visitVsFilterValue(ctx: pc.VsFilterValueContext): ValueSetFilterValue;
    private validateAliasResolves;
    private aliasAwareValue;
    /**
     * Given a path and the context containing it, apply the path context indicated by the path's indent
     * @param path - The path to apply context to
     * @param parentCtx - The parent element containing the path
     * @returns {string[]} - The path with context prepended
     */
    private prependPathContext;
    private isValidContext;
    private extractString;
    private unescapeQuotedString;
    /**
     * Multiline strings receive special handling:
     * - if the first line contains only whitespace (including newline), toss it
     * - if the last line contains only whitespace (including newline), toss it
     * - if another line contains only whitespace, truncate it
     * - for all other non-whitespace lines, detect the shortest number of leading spaces and always trim that off;
     *   this allows authors to indent a whole block of text, but not have it indented in the output.
     */
    private extractMultilineString;
    private extractNumberValue;
    private extractStartStop;
    private getStarContextStartColumn;
    private parseDoc;
}
export {};
