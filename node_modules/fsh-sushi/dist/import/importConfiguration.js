"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importConfiguration = importConfiguration;
const yaml_1 = __importDefault(require("yaml"));
const ajv_1 = __importDefault(require("ajv"));
const YAMLschema_json_1 = __importDefault(require("./YAMLschema.json"));
const FSHLogger_1 = require("../utils/FSHLogger");
const parseCodeLexeme_1 = require("./parseCodeLexeme");
const lodash_1 = require("lodash");
// Minimal properties needed for any FSH project
const MINIMAL_CONFIG_PROPERTIES = ['canonical', 'fhirVersion'];
// Additional minimal properties needed for an IG-producing project (i.e. FSHOnly === false)
const MINIMAL_IG_ONLY_PROPERTIES = ['id', 'name', 'status', 'copyrightYear', 'releaseLabel'];
// Allowed properties for FSH Only projects (all other properties are irrelevant)
const ALLOWED_FSH_ONLY_PROPERTIES = [
    ...MINIMAL_CONFIG_PROPERTIES,
    'version',
    'status',
    'dependencies',
    'instanceOptions',
    'applyExtensionMetadataToRoot',
    'FSHOnly'
];
/**
 * Imports the YAML Configuration format (as a YAML string or already parsed JSON) and returns
 * the normalized FSH Configuration object.
 * @param {YAMLConfiguration | string} yaml - the YAML config as a string or JSON document
 * @param {string} file - the path to the configuration file (used for logging source info)
 * @returns {Configuration} - the FSH configuration representing the parsed config
 */
function importConfiguration(yaml, file) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (typeof yaml === 'string') {
        let parsed;
        try {
            parsed = yaml_1.default.parse(yaml);
        }
        catch (e) {
            FSHLogger_1.logger.error(`Error parsing configuration: ${e.message}.`, { file });
            if (e.stack) {
                FSHLogger_1.logger.debug(e.stack);
            }
            throw new Error('Invalid configuration YAML');
        }
        if (typeof parsed !== 'object' || parsed === null) {
            FSHLogger_1.logger.error('Configuration is not a valid YAML object.', { file });
            throw new Error('Invalid configuration YAML');
        }
        return importConfiguration(parsed, file);
    }
    // There are a few properties that are absolutely required if we are to have *any* success at all
    const minimalProperties = yaml.FSHOnly
        ? MINIMAL_CONFIG_PROPERTIES
        : [...MINIMAL_CONFIG_PROPERTIES, ...MINIMAL_IG_ONLY_PROPERTIES];
    const missingProperties = minimalProperties.filter((p) => yaml[p] == null || (Array.isArray(yaml[p]) && yaml[p].length === 0));
    // the copyrightYear and releaseLabel properties permit alternate spellings as all lowercase,
    // so if only those are missing, check for the lowercase version before logging an error.
    if (missingProperties.includes('copyrightYear') && yaml.copyrightyear) {
        missingProperties.splice(missingProperties.indexOf('copyrightYear'), 1);
    }
    if (missingProperties.includes('releaseLabel') && yaml.releaselabel) {
        missingProperties.splice(missingProperties.indexOf('releaseLabel'), 1);
    }
    if (missingProperties.length > 0) {
        FSHLogger_1.logger.error(`SUSHI minimally requires the following configuration properties to ${yaml.FSHOnly ? 'start processing FSH' : 'generate an IG'}: ` +
            minimalProperties.join(', ') +
            '.', { file });
        throw new Error('Minimal config not met');
    }
    const config = {
        filePath: file,
        canonical: yaml.canonical, // minimum config property
        id: yaml.id, // minimum config property
        meta: parseMeta(yaml.meta, file),
        implicitRules: yaml.implicitRules,
        language: parseSimpleCode(yaml.language, 'language', file),
        text: parseText(yaml.text, file),
        contained: yaml.contained,
        extension: yaml.extension,
        modifierExtension: yaml.modifierExtension,
        url: (_a = yaml.url) !== null && _a !== void 0 ? _a : `${yaml.canonical}/ImplementationGuide/${yaml.id}`,
        version: normalizeToString(yaml.version), // minimum config property
        name: yaml.FSHOnly ? yaml.name : required(yaml.name, 'name', file),
        title: yaml.title,
        // Default status to 'draft' on FSHOnly IGs so exported resources inherit the property
        status: parseCodeWithRequiredValues(yaml.FSHOnly ? ((_b = yaml.status) !== null && _b !== void 0 ? _b : 'draft') : ((_c = required(yaml.status, 'status', file)) !== null && _c !== void 0 ? _c : 'draft'), ['draft', 'active', 'retired', 'unknown'], 'status', file),
        experimental: yaml.experimental,
        date: normalizeToString(yaml.date),
        publisher: (_e = (_d = normalizeToArray(yaml.publisher)) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.name,
        contact: parseContact(yaml, file),
        description: yaml.description,
        useContext: parseUsageContext(yaml.useContext, file),
        jurisdiction: parseJurisdiction(yaml.jurisdiction, file),
        copyright: yaml.copyright,
        copyrightLabel: yaml.copyrightLabel,
        versionAlgorithmString: yaml.versionAlgorithmString,
        versionAlgorithmCoding: parseCoding(yaml.versionAlgorithmCoding, 'versionAlgorithmCoding', file),
        packageId: (_f = yaml.packageId) !== null && _f !== void 0 ? _f : yaml.id,
        license: parseSimpleCode(yaml.license, 'license', file),
        fhirVersion: (_g = normalizeToArray(yaml.fhirVersion)) === null || _g === void 0 ? void 0 : _g.map(v => parseSimpleCode(v, 'fhirVersion', file)), // minimum config property
        dependencies: parseDependencies(yaml.dependencies),
        global: parseGlobal(yaml.global),
        groups: parseGroups(yaml.groups),
        definition: parseDefinition(yaml.definition),
        resources: parseResources(yaml.resources, file),
        pages: parsePages(yaml.pages, file),
        parameters: parseParameters(yaml, yaml.FSHOnly, file),
        templates: parseTemplates(yaml.templates, file),
        template: yaml.template,
        menu: parseMenu(yaml.menu),
        history: parseHistory(yaml, file),
        indexPageContent: yaml.indexPageContent,
        FSHOnly: (_h = yaml.FSHOnly) !== null && _h !== void 0 ? _h : false,
        applyExtensionMetadataToRoot: (_j = yaml.applyExtensionMetadataToRoot) !== null && _j !== void 0 ? _j : true,
        instanceOptions: parseInstanceOptions(yaml.instanceOptions, file)
    };
    detectPotentialMistakes(yaml);
    // Remove all undefined variables (mainly helpful for test assertions)
    removeUndefinedValues(config);
    if (yaml.FSHOnly) {
        // If no IG is being generated, emit warning when IG specific properties are used in config
        const unusedProperties = Object.keys(yaml).filter((p) => !ALLOWED_FSH_ONLY_PROPERTIES.includes(p));
        if (unusedProperties.length > 0) {
            FSHLogger_1.logger.warn(`The FSHOnly property is set to true, so no output specific to IG creation will be generated. The following properties are unused and only relevant for IG creation: ${unusedProperties.join(', ')}. Consider removing these properties from sushi-config.yaml.`, { file });
        }
    }
    return config;
}
function required(value, property, file) {
    if (value == null || (Array.isArray(value) && value.length === 0)) {
        FSHLogger_1.logger.error(`Configuration missing required property: ${property}`, { file });
    }
    return value;
}
function normalizeToString(yamlValue) {
    if (yamlValue == null) {
        return;
    }
    return `${yamlValue}`;
}
function normalizeToArray(yamlValue) {
    if (yamlValue == null) {
        return;
    }
    return Array.isArray(yamlValue) ? yamlValue : [yamlValue];
}
function parseSimpleCode(yamlCode, property, file) {
    var _a;
    return (yamlCode === null || yamlCode === void 0 ? void 0 : yamlCode.startsWith('#')) ? (_a = parseFshCode(yamlCode, property, file)) === null || _a === void 0 ? void 0 : _a.code : yamlCode;
}
function parseFshCode(yamlCode, property, file) {
    // If it has a display, we need to split it out and handle it separately
    const m = yamlCode.match(/^(.*\S)(\s+"(([^"]|\\")*)")$/);
    if (m) {
        const concept = (0, parseCodeLexeme_1.parseCodeLexeme)(m[1]);
        concept.display = m[3].replace(/\\"/g, '"');
        return concept;
    }
    const concept = (0, parseCodeLexeme_1.parseCodeLexeme)(yamlCode);
    if (concept.system == null && concept.code === '') {
        FSHLogger_1.logger.error(`Invalid code format for ${property}: ${yamlCode}`, { file });
        // don't return an invalid code
        return;
    }
    return concept;
}
function parseCodingArray(codings, property, file) {
    if (codings == null) {
        return;
    }
    const result = codings === null || codings === void 0 ? void 0 : codings.map(c => parseCoding(c, property, file)).filter(c => c != null);
    if (result.length === 0 && codings.length > 0) {
        // in the case that all inputs were invalid, return undefined instead of empty array
        return;
    }
    return result;
}
function parseCoding(coding, property, file) {
    var _a;
    if (coding == null) {
        return;
    }
    if (typeof coding === 'string') {
        return (_a = parseFshCode(coding, property, file)) === null || _a === void 0 ? void 0 : _a.toFHIRCoding();
    }
    // It's a coding object
    const fixed = {
        ...coding,
        version: normalizeToString(coding.version),
        code: parseSimpleCode(coding.code, property, file)
    };
    return removeUndefinedValues(fixed);
}
function parseCodeableConceptArray(concepts, property, file) {
    if (concepts == null) {
        return;
    }
    const result = concepts === null || concepts === void 0 ? void 0 : concepts.map(c => parseCodeableConcept(c, property, file)).filter(c => c != null);
    if (result.length === 0 && concepts.length > 0) {
        // in the case that all inputs were invalid, return undefined instead of empty array
        return;
    }
    return result;
}
function parseCodeableConcept(concept, property, file) {
    if (concept == null) {
        return;
    }
    if (typeof concept === 'string') {
        const coding = parseCoding(concept, property, file);
        if (coding == null) {
            // return undefined instead of an empty concept
            return;
        }
        return {
            coding: [coding]
        };
    }
    // It's a CodeableConcept object
    const fixed = {
        ...concept,
        coding: parseCodingArray(concept.coding, property, file)
    };
    return removeUndefinedValues(fixed);
}
function parseCodeWithRequiredValues(yamlCode, allowedValues, property, file) {
    if (yamlCode == null) {
        return;
    }
    const code = parseSimpleCode(yamlCode, property, file);
    const match = allowedValues.find(c => c === code);
    if (match) {
        return match;
    }
    FSHLogger_1.logger.error(`Invalid ${property} value: '${code}'. Must be one of: ${allowedValues
        .map(c => `'${c}'`)
        .join(',')}.`, {
        file
    });
}
function parseQuantity(yamlQuantity, property, file) {
    if (yamlQuantity == null) {
        return;
    }
    if (typeof yamlQuantity === 'string') {
        const m = yamlQuantity.match(/^(\d*(\.\d+)?)(\s+'([^']+)')?$/);
        if (m == null) {
            FSHLogger_1.logger.error(`Invalid ${property} value: ${yamlQuantity}`, { file });
            return;
        }
        const quantity = {
            value: parseFloat(m[1])
        };
        if (m[4] && m[4].length > 0) {
            quantity.system = 'http://unitsofmeasure.org';
            quantity.code = m[4];
        }
        return quantity;
    }
    const quantity = {
        ...yamlQuantity,
        code: parseSimpleCode(yamlQuantity.code, `${property}.code`, file),
        comparator: parseCodeWithRequiredValues(yamlQuantity.comparator, ['<', '<=', '>=', '>'], `${property}.comparator`, file)
    };
    removeUndefinedValues(quantity);
    return quantity;
}
function parseRange(yamlRange, property, file) {
    if (yamlRange == null) {
        return;
    }
    const range = {
        ...yamlRange,
        low: parseQuantity(yamlRange.low, `${property}.low`, file),
        high: parseQuantity(yamlRange.high, `${property}.high`, file)
    };
    removeUndefinedValues(range);
    return range;
}
function parseReference(yamlReference, property, file) {
    if (yamlReference == null) {
        return;
    }
    const reference = {
        ...yamlReference,
        identifier: parseIdentifier(yamlReference.identifier, `${property}.identifier`, file)
    };
    removeUndefinedValues(reference);
    return reference;
}
function parseIdentifier(yamlIdentifier, property, file) {
    if (yamlIdentifier == null) {
        return;
    }
    const identifier = {
        ...yamlIdentifier,
        use: parseCodeWithRequiredValues(yamlIdentifier.use, ['usual', 'official', 'temp', 'secondary', 'old'], `${property}.use`, file),
        type: parseCodeableConcept(yamlIdentifier.type, `${property}.type`, file),
        assigner: parseReference(yamlIdentifier.assigner, `${property}.assigner`, file)
    };
    removeUndefinedValues(identifier);
    return identifier;
}
function parseMeta(yamlMeta, file) {
    if (yamlMeta == null) {
        return;
    }
    const fixed = {
        ...yamlMeta,
        security: parseCodingArray(yamlMeta.security, 'meta.security', file),
        tag: parseCodingArray(yamlMeta.tag, 'meta.tag', file)
    };
    return removeUndefinedValues(fixed);
}
function parseText(yamlText, file) {
    if (yamlText == null) {
        return;
    }
    const fixed = {
        ...yamlText,
        status: parseCodeWithRequiredValues(yamlText.status, ['generated', 'extensions', 'additional', 'empty'], 'text.status', file)
    };
    return removeUndefinedValues(fixed);
}
function parseContact(yamlConfig, file) {
    const contacts = [];
    const publishers = normalizeToArray(yamlConfig.publisher);
    if (publishers) {
        publishers.forEach((p, i) => {
            const contact = { name: p.name };
            if (p.url || p.email) {
                contact.telecom = [];
                if (p.url) {
                    contact.telecom.push({ system: 'url', value: p.url });
                }
                if (p.email) {
                    contact.telecom.push({ system: 'email', value: p.email });
                }
            }
            else if (i === 0) {
                // This was the first publisher and there was no additional contact detail, so skip it
                return;
            }
            contacts.push(contact);
        });
    }
    if (yamlConfig.contact) {
        contacts.push(...normalizeToArray(yamlConfig.contact).map(yamlContact => {
            const contact = {
                ...yamlContact,
                telecom: normalizeToArray(yamlContact.telecom).map(yamlTelecom => {
                    const contactPoint = {
                        ...yamlTelecom,
                        system: parseCodeWithRequiredValues(yamlTelecom.system, ['phone', 'fax', 'email', 'pager', 'url', 'sms', 'other'], 'contact.telecom.system', file),
                        use: parseCodeWithRequiredValues(yamlTelecom.use, ['home', 'work', 'temp', 'old', 'mobile'], 'contact.telecom.use', file)
                    };
                    removeUndefinedValues(contactPoint);
                    return contactPoint;
                })
            };
            if (contact.telecom.length === 0) {
                delete contact.telecom;
            }
            return contact;
        }));
    }
    if (contacts.length === 0) {
        return;
    }
    return contacts;
}
function parseUsageContext(yamlUsageContext, file) {
    var _a;
    return (_a = normalizeToArray(yamlUsageContext)) === null || _a === void 0 ? void 0 : _a.map(yaml => {
        const usageContext = {
            code: parseCoding(required(yaml.code, 'useContext.code', file), 'useContext.code', file),
            valueCodeableConcept: parseCodeableConcept(yaml.valueCodeableConcept, 'useContext.valueCodeableConcept', file),
            valueQuantity: parseQuantity(yaml.valueQuantity, 'useContext.valueQuantity', file),
            valueRange: parseRange(yaml.valueRange, 'useContext.valueRange', file),
            valueReference: parseReference(yaml.valueReference, 'useContext.valueReference', file)
        };
        const valueFields = [
            'valueCodeableConcept',
            'valueQuantity',
            'valueRange',
            'valueReference'
        ].filter((v) => yaml[v] != null);
        if (valueFields.length === 0) {
            // at least one is required, so force the 'required' error
            required(undefined, 'useContext.value[x]', file);
        }
        else if (valueFields.length > 1) {
            // more than one value is not allowed since it is a value[x] choice
            FSHLogger_1.logger.error(`Only one useContext.value[x] is allowed but found multiple: ${valueFields.join(', ')}`, {
                file
            });
        }
        removeUndefinedValues(usageContext);
        return usageContext;
    });
}
function parseJurisdiction(yamlJurisdiction, file) {
    return parseCodeableConceptArray(normalizeToArray(yamlJurisdiction), 'jurisdiction', file);
}
function parseDependencies(yamlDependencies) {
    if (yamlDependencies == null) {
        return;
    }
    return Object.entries(yamlDependencies).map(([packageId, versionOrDetails]) => {
        if (/[A-Z]/.test(packageId)) {
            FSHLogger_1.logger.warn(`${packageId} contains uppercase characters, which is discouraged. SUSHI will use ${packageId.toLowerCase()} as the package name.`);
            packageId = packageId.toLowerCase();
        }
        if (typeof versionOrDetails === 'string' || typeof versionOrDetails === 'number') {
            return { packageId, version: `${versionOrDetails}` };
        }
        else if (versionOrDetails == null) {
            // this is an error condition, but we'll just make it an incomplete dependency and
            // handle the error later
            return { packageId };
        }
        // else it's the complex object
        return removeUndefinedValues({
            id: versionOrDetails.id,
            packageId,
            uri: versionOrDetails.uri,
            version: typeof versionOrDetails.version === 'string' || typeof versionOrDetails.version === 'number'
                ? `${versionOrDetails.version}`
                : undefined,
            reason: versionOrDetails.reason,
            extension: versionOrDetails.extension
        });
    });
}
function parseGlobal(yamlGlobal) {
    if (yamlGlobal == null) {
        return;
    }
    const global = [];
    for (const [type, profiles] of Object.entries(yamlGlobal)) {
        normalizeToArray(profiles).forEach(profile => global.push({ type, profile }));
    }
    return global;
}
function parseGroups(yamlGroups) {
    if (yamlGroups == null) {
        return;
    }
    return Object.entries(yamlGroups).map(([id, groupObj]) => {
        if (groupObj.name === undefined) {
            groupObj.name = id;
        }
        return {
            id: id,
            name: groupObj.name,
            description: groupObj.description,
            resources: groupObj.resources
        };
    });
}
function parseDefinition(yamlDefinition) {
    // NOTE: extension is the only property allowed to be set directly on definition in config file
    if (yamlDefinition == null || yamlDefinition.extension == null) {
        return;
    }
    return { extension: yamlDefinition.extension };
}
function parseResources(yamlResources, file) {
    if (yamlResources == null) {
        return;
    }
    return Object.entries(yamlResources).map(([reference, details]) => {
        var _a;
        if (details === 'omit' || details === '#omit') {
            return { reference: { reference }, omit: true };
        }
        return {
            reference: { reference },
            ...details,
            profile: normalizeToArray(details.profile),
            fhirVersion: (_a = normalizeToArray(details.fhirVersion)) === null || _a === void 0 ? void 0 : _a.map(v => parseSimpleCode(v, `resource[${reference}].fhirVersion`, file))
        };
    });
}
function parsePages(yamlPages, file) {
    if (yamlPages == null) {
        return;
    }
    return Object.entries(yamlPages).map(([nameUrl, details]) => {
        return parsePage(nameUrl, details, `pages[${nameUrl}]`, file);
    });
}
function parsePage(nameUrl, details, property, file) {
    const page = { nameUrl };
    if (details === null || details === void 0 ? void 0 : details.title) {
        page.title = details.title;
    }
    if (details === null || details === void 0 ? void 0 : details.generation) {
        page.generation = parseCodeWithRequiredValues(details.generation, ['html', 'markdown', 'xml', 'generated'], `${property}.generation`, file);
    }
    if (details === null || details === void 0 ? void 0 : details.sourceUrl) {
        page.sourceUrl = details.sourceUrl;
    }
    if (details === null || details === void 0 ? void 0 : details.sourceString) {
        page.sourceString = details.sourceString;
    }
    if (details === null || details === void 0 ? void 0 : details.sourceMarkdown) {
        page.sourceMarkdown = details.sourceMarkdown;
    }
    if (details === null || details === void 0 ? void 0 : details.name) {
        page.name = details.name;
    }
    if (details === null || details === void 0 ? void 0 : details.extension) {
        page.extension = details.extension;
    }
    if (details === null || details === void 0 ? void 0 : details.modifierExtension) {
        page.modifierExtension = details.modifierExtension;
    }
    if (details != null) {
        Object.entries(details).forEach(([key, value]) => {
            if (key == 'title' ||
                key == 'generation' ||
                key == 'sourceUrl' ||
                key == 'sourceString' ||
                key == 'sourceMarkdown' ||
                key == 'extension' ||
                key == 'modifierExtension') {
                return;
            }
            if (page.page == null) {
                page.page = [];
            }
            // We only want to recursively parse the page if it defines another page
            // Unfortunately, we can't just check typeof page === YAMLConfigurationPage so do our best
            // This will ensure the recursion ends eventually because calling Object.entries('string') will loop forever
            if (typeof value === 'object') {
                page.page.push(parsePage(key, value, `${property}[${key}]`, file));
            }
        });
    }
    return page;
}
function parseParameters(yamlConfig, FSHOnly, file) {
    var _a, _b, _c, _d, _e;
    const parameters = [];
    // copyrightYear and releaseLabel are only required when generating an IG
    const copyrightYear = FSHOnly
        ? ((_a = yamlConfig.copyrightYear) !== null && _a !== void 0 ? _a : yamlConfig.copyrightyear)
        : required((_b = yamlConfig.copyrightYear) !== null && _b !== void 0 ? _b : yamlConfig.copyrightyear, 'copyrightYear', file);
    const releaseLabel = FSHOnly
        ? ((_c = yamlConfig.releaseLabel) !== null && _c !== void 0 ? _c : yamlConfig.releaselabel)
        : required((_d = yamlConfig.releaseLabel) !== null && _d !== void 0 ? _d : yamlConfig.releaselabel, 'releaseLabel', file);
    if (copyrightYear) {
        parameters.push({
            code: 'copyrightyear',
            value: copyrightYear.toString()
        });
    }
    if (releaseLabel) {
        parameters.push({
            code: 'releaselabel',
            value: releaseLabel
        });
    }
    if (yamlConfig.parameters) {
        for (const [code, values] of Object.entries(yamlConfig.parameters)) {
            (_e = normalizeToArray(values)) === null || _e === void 0 ? void 0 : _e.forEach(value => parameters.push({ code, value: `${value}` }));
        }
    }
    else if (parameters.length === 0) {
        return; // return undefined rather than an empty []
    }
    return parameters;
}
function parseTemplates(yamlTemplates, file) {
    var _a;
    return (_a = normalizeToArray(yamlTemplates)) === null || _a === void 0 ? void 0 : _a.map(t => {
        const template = {
            ...t,
            code: parseSimpleCode(required(t.code, 'templates.code', file), 'templates.code', file),
            source: required(t.source, 'templates.source', file)
        };
        removeUndefinedValues(template);
        return template;
    });
}
function parseMenu(yamlMenu) {
    if (yamlMenu == null) {
        return;
    }
    return Object.entries(yamlMenu).map(([name, value]) => {
        const item = { name };
        if (typeof value === 'string') {
            // Set menu item attributes based on keywords
            if (value.includes('new-tab ')) {
                item.openInNewTab = true;
                value = value.replace('new-tab', '');
            }
            if (value.includes('external ')) {
                FSHLogger_1.logger.warn('The "external" keyword in menu configuration has been deprecated. The IG Publisher' +
                    ' will detect external links and add the external link icon automatically. To resolve' +
                    ` this warning, remove the "external" keyword from the "${name}" menu item.`);
                value = value.replace('external', '');
            }
            // Trim off any white space left after using keywords. URL is remaining value.
            item.url = value.trim();
        }
        else {
            item.subMenu = parseMenu(value);
        }
        return item;
    });
}
function parseHistory(yamlConfig, file) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const yamlHistory = yamlConfig.history;
    if (yamlHistory == null) {
        return;
    }
    const history = {
        'package-id': (_b = (_a = yamlHistory['package-id']) !== null && _a !== void 0 ? _a : yamlConfig.packageId) !== null && _b !== void 0 ? _b : yamlConfig.id,
        canonical: (_c = yamlHistory.canonical) !== null && _c !== void 0 ? _c : yamlConfig.canonical,
        title: (_d = yamlHistory.title) !== null && _d !== void 0 ? _d : yamlConfig.title,
        introduction: (_e = yamlHistory.introduction) !== null && _e !== void 0 ? _e : yamlConfig.description,
        list: []
    };
    if (yamlHistory.current) {
        if (typeof yamlHistory.current === 'string') {
            history.list.push({
                version: 'current',
                desc: 'Continuous Integration Build (latest in version control)',
                path: yamlHistory.current,
                status: 'ci-build',
                current: true
            });
        }
        else {
            history.list.push({
                version: 'current',
                date: normalizeToString(yamlHistory.current.date),
                desc: (_f = yamlHistory.current.desc) !== null && _f !== void 0 ? _f : 'Continuous Integration Build (latest in version control)',
                path: required(yamlHistory.current.path, 'history[current].path', file),
                changes: yamlHistory.current.changes,
                status: parseCodeWithRequiredValues((_g = yamlHistory.current.status) !== null && _g !== void 0 ? _g : 'ci-build', allowedHistoryStatus, 'history[current].status', file),
                sequence: yamlHistory.current.sequence,
                fhirversion: yamlHistory.current.fhirversion,
                current: (_h = yamlHistory.current.current) !== null && _h !== void 0 ? _h : true
            });
        }
    }
    for (const [key, value] of Object.entries(yamlHistory)) {
        if (['package-id', 'canonical', 'title', 'introduction', 'current'].indexOf(key) !== -1) {
            continue;
        }
        const item = value;
        history.list.push({
            version: key,
            date: required(item.date, `history[${key}].date`, file),
            desc: required(item.desc, `history[${key}].desc`, file),
            path: required(item.path, `history[${key}].path`, file),
            changes: item.changes,
            status: parseCodeWithRequiredValues(required(item.status, `history[${key}].status`, file), allowedHistoryStatus, `history[${key}].status`, file),
            sequence: required(item.sequence, `history[${key}].sequence`, file),
            fhirversion: required(item.fhirversion, `history[${key}].fhirVersion`, file),
            current: item.current
        });
    }
    history.list.forEach(item => removeUndefinedValues(item));
    return history;
}
const allowedHistoryStatus = [
    'ci-build',
    'preview',
    'ballot',
    'trial-use',
    'update',
    'normative',
    'trial-use+normative'
];
function parseInstanceOptions(yamlInstanceOptions, file) {
    var _a;
    return {
        setMetaProfile: parseCodeWithRequiredValues(yamlInstanceOptions === null || yamlInstanceOptions === void 0 ? void 0 : yamlInstanceOptions.setMetaProfile, ['always', 'never', 'inline-only', 'standalone-only'], 'instanceOptions.setMetaProfile', file) || 'always',
        setId: parseCodeWithRequiredValues(yamlInstanceOptions === null || yamlInstanceOptions === void 0 ? void 0 : yamlInstanceOptions.setId, ['always', 'standalone-only'], 'instanceOptions.setId', file) || 'always',
        manualSliceOrdering: (_a = yamlInstanceOptions === null || yamlInstanceOptions === void 0 ? void 0 : yamlInstanceOptions.manualSliceOrdering) !== null && _a !== void 0 ? _a : false
    };
}
function detectPotentialMistakes(yaml) {
    const ajv = new ajv_1.default({ allowUnionTypes: true, allowMatchingProperties: true, allErrors: true });
    const validate = ajv.compile(YAMLschema_json_1.default);
    const result = validate(yaml);
    if (!result) {
        const errorCollection = (0, lodash_1.groupBy)(validate.errors, validationError => validationError.instancePath);
        for (const instancePath in errorCollection) {
            // a validation error on additionalProperties usually represents incorrect spelling or indentation.
            // for other types of validation errors, just report the name of the property.
            const additionalPropertiesErrors = errorCollection[instancePath].filter(validationError => validationError.keyword === 'additionalProperties');
            if (additionalPropertiesErrors.length > 0) {
                const parentProperty = instancePath === '' ? '' : `property ${instancePath.slice(1)} `;
                const singular = additionalPropertiesErrors.length === 1;
                const additionalPropertyNames = additionalPropertiesErrors
                    .map(validationError => validationError.params.additionalProperty)
                    .join(', ');
                let recommendation = `Check that ${singular ? 'this property is' : 'these properties are'} spelled, capitalized, and indented correctly.`;
                if (instancePath.startsWith('/pages')) {
                    recommendation += ` If ${singular ? 'this is a page, it' : 'these are pages, they'} should end with .md, .xml, or .html.`;
                }
                else if (instancePath.startsWith('/definition')) {
                    recommendation =
                        'Only the extension property is allowed under definition. All other definition ' +
                            'properties are represented at the top-level of the configuration.';
                }
                FSHLogger_1.logger.warn(`Configuration ${parentProperty}contains unexpected ${singular ? 'property' : 'properties'}: ${additionalPropertyNames}. ${recommendation}`);
            }
            else {
                FSHLogger_1.logger.warn(`Configuration property ${instancePath.slice(1)} has a value with an unexpected type.`);
            }
        }
    }
}
function removeUndefinedValues(incoming) {
    Object.keys(incoming).forEach((k) => {
        // @ts-ignore Element implicitly has an 'any' type
        if (typeof incoming[k] === 'undefined') {
            // @ts-ignore Element implicitly has an 'any' type
            delete incoming[k];
        }
    });
    return incoming;
}
//# sourceMappingURL=importConfiguration.js.map