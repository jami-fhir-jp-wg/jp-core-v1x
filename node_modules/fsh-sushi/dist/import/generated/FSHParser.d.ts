declare class FSHParser extends antlr4.Parser {
    static grammarFileName: string;
    static literalNames: string[];
    static symbolicNames: string[];
    static ruleNames: string[];
    constructor(input: any);
    _interp: any;
    ruleNames: string[];
    literalNames: string[];
    symbolicNames: string[];
    doc(): DocContext;
    entity(): EntityContext;
    alias(): AliasContext;
    profile(): ProfileContext;
    extension(): ExtensionContext;
    logical(): LogicalContext;
    resource(): ResourceContext;
    sdMetadata(): SdMetadataContext;
    sdRule(): SdRuleContext;
    lrRule(): LrRuleContext;
    instance(): InstanceContext;
    instanceMetadata(): InstanceMetadataContext;
    instanceRule(): InstanceRuleContext;
    invariant(): InvariantContext;
    invariantMetadata(): InvariantMetadataContext;
    invariantRule(): InvariantRuleContext;
    valueSet(): ValueSetContext;
    vsMetadata(): VsMetadataContext;
    vsRule(): VsRuleContext;
    codeSystem(): CodeSystemContext;
    csMetadata(): CsMetadataContext;
    csRule(): CsRuleContext;
    ruleSet(): RuleSetContext;
    ruleSetRule(): RuleSetRuleContext;
    paramRuleSet(): ParamRuleSetContext;
    paramRuleSetRef(): ParamRuleSetRefContext;
    parameter(): ParameterContext;
    lastParameter(): LastParameterContext;
    paramRuleSetContent(): ParamRuleSetContentContext;
    mapping(): MappingContext;
    mappingMetadata(): MappingMetadataContext;
    mappingEntityRule(): MappingEntityRuleContext;
    parent(): ParentContext;
    id(): IdContext;
    title(): TitleContext;
    description(): DescriptionContext;
    expression(): ExpressionContext;
    xpath(): XpathContext;
    severity(): SeverityContext;
    instanceOf(): InstanceOfContext;
    usage(): UsageContext;
    source(): SourceContext;
    target(): TargetContext;
    context(): ContextContext;
    contextItem(): ContextItemContext;
    lastContextItem(): LastContextItemContext;
    characteristics(): CharacteristicsContext;
    cardRule(): CardRuleContext;
    flagRule(): FlagRuleContext;
    valueSetRule(): ValueSetRuleContext;
    fixedValueRule(): FixedValueRuleContext;
    containsRule(): ContainsRuleContext;
    onlyRule(): OnlyRuleContext;
    obeysRule(): ObeysRuleContext;
    caretValueRule(): CaretValueRuleContext;
    codeCaretValueRule(): CodeCaretValueRuleContext;
    mappingRule(): MappingRuleContext;
    insertRule(): InsertRuleContext;
    codeInsertRule(): CodeInsertRuleContext;
    addCRElementRule(): AddCRElementRuleContext;
    addElementRule(): AddElementRuleContext;
    pathRule(): PathRuleContext;
    vsComponent(): VsComponentContext;
    vsConceptComponent(): VsConceptComponentContext;
    vsFilterComponent(): VsFilterComponentContext;
    vsComponentFrom(): VsComponentFromContext;
    vsFromSystem(): VsFromSystemContext;
    vsFromValueset(): VsFromValuesetContext;
    vsFilterList(): VsFilterListContext;
    vsFilterDefinition(): VsFilterDefinitionContext;
    vsFilterOperator(): VsFilterOperatorContext;
    vsFilterValue(): VsFilterValueContext;
    name(): NameContext;
    path(): PathContext;
    caretPath(): CaretPathContext;
    flag(): FlagContext;
    strength(): StrengthContext;
    value(): ValueContext;
    item(): ItemContext;
    code(): CodeContext;
    concept(): ConceptContext;
    quantity(): QuantityContext;
    ratio(): RatioContext;
    reference(): ReferenceContext;
    referenceType(): ReferenceTypeContext;
    codeableReferenceType(): CodeableReferenceTypeContext;
    canonical(): CanonicalContext;
    ratioPart(): RatioPartContext;
    bool(): BoolContext;
    targetType(): TargetTypeContext;
    mostAlphaKeywords(): MostAlphaKeywordsContext;
}
declare namespace FSHParser {
    export let EOF: number;
    export let KW_ALIAS: number;
    export let KW_PROFILE: number;
    export let KW_EXTENSION: number;
    export let KW_INSTANCE: number;
    export let KW_INSTANCEOF: number;
    export let KW_INVARIANT: number;
    export let KW_VALUESET: number;
    export let KW_CODESYSTEM: number;
    export let KW_RULESET: number;
    export let KW_MAPPING: number;
    export let KW_LOGICAL: number;
    export let KW_RESOURCE: number;
    export let KW_PARENT: number;
    export let KW_ID: number;
    export let KW_TITLE: number;
    export let KW_DESCRIPTION: number;
    export let KW_EXPRESSION: number;
    export let KW_XPATH: number;
    export let KW_SEVERITY: number;
    export let KW_USAGE: number;
    export let KW_SOURCE: number;
    export let KW_TARGET: number;
    export let KW_CONTEXT: number;
    export let KW_CHARACTERISTICS: number;
    export let KW_MOD: number;
    export let KW_MS: number;
    export let KW_SU: number;
    export let KW_TU: number;
    export let KW_NORMATIVE: number;
    export let KW_DRAFT: number;
    export let KW_FROM: number;
    export let KW_EXAMPLE: number;
    export let KW_PREFERRED: number;
    export let KW_EXTENSIBLE: number;
    export let KW_REQUIRED: number;
    export let KW_CONTAINS: number;
    export let KW_NAMED: number;
    export let KW_AND: number;
    export let KW_ONLY: number;
    export let KW_OR: number;
    export let KW_OBEYS: number;
    export let KW_TRUE: number;
    export let KW_FALSE: number;
    export let KW_INCLUDE: number;
    export let KW_EXCLUDE: number;
    export let KW_CODES: number;
    export let KW_WHERE: number;
    export let KW_VSREFERENCE: number;
    export let KW_SYSTEM: number;
    export let KW_EXACTLY: number;
    export let KW_INSERT: number;
    export let KW_CONTENTREFERENCE: number;
    export let EQUAL: number;
    export let STAR: number;
    export let COLON: number;
    export let COMMA: number;
    export let ARROW: number;
    export let STRING: number;
    export let MULTILINE_STRING: number;
    export let NUMBER: number;
    export let UNIT: number;
    export let CODE: number;
    export let CONCEPT_STRING: number;
    export let DATETIME: number;
    export let TIME: number;
    export let CARD: number;
    export let REFERENCE: number;
    export let CODEABLE_REFERENCE: number;
    export let CANONICAL: number;
    export let CARET_SEQUENCE: number;
    export let REGEX: number;
    export let BLOCK_COMMENT: number;
    export let SEQUENCE: number;
    export let WHITESPACE: number;
    export let LINE_COMMENT: number;
    export let PARAM_RULESET_REFERENCE: number;
    export let RULESET_REFERENCE: number;
    export let BRACKETED_PARAM: number;
    export let LAST_BRACKETED_PARAM: number;
    export let PLAIN_PARAM: number;
    export let LAST_PLAIN_PARAM: number;
    export let QUOTED_CONTEXT: number;
    export let LAST_QUOTED_CONTEXT: number;
    export let UNQUOTED_CONTEXT: number;
    export let LAST_UNQUOTED_CONTEXT: number;
    export let CONTEXT_WHITESPACE: number;
    export let CODE_ITEM: number;
    export let LAST_CODE_ITEM: number;
    export let CODE_LIST_WHITESPACE: number;
    export let RULE_doc: number;
    export let RULE_entity: number;
    export let RULE_alias: number;
    export let RULE_profile: number;
    export let RULE_extension: number;
    export let RULE_logical: number;
    export let RULE_resource: number;
    export let RULE_sdMetadata: number;
    export let RULE_sdRule: number;
    export let RULE_lrRule: number;
    export let RULE_instance: number;
    export let RULE_instanceMetadata: number;
    export let RULE_instanceRule: number;
    export let RULE_invariant: number;
    export let RULE_invariantMetadata: number;
    export let RULE_invariantRule: number;
    export let RULE_valueSet: number;
    export let RULE_vsMetadata: number;
    export let RULE_vsRule: number;
    export let RULE_codeSystem: number;
    export let RULE_csMetadata: number;
    export let RULE_csRule: number;
    export let RULE_ruleSet: number;
    export let RULE_ruleSetRule: number;
    export let RULE_paramRuleSet: number;
    export let RULE_paramRuleSetRef: number;
    export let RULE_parameter: number;
    export let RULE_lastParameter: number;
    export let RULE_paramRuleSetContent: number;
    export let RULE_mapping: number;
    export let RULE_mappingMetadata: number;
    export let RULE_mappingEntityRule: number;
    export let RULE_parent: number;
    export let RULE_id: number;
    export let RULE_title: number;
    export let RULE_description: number;
    export let RULE_expression: number;
    export let RULE_xpath: number;
    export let RULE_severity: number;
    export let RULE_instanceOf: number;
    export let RULE_usage: number;
    export let RULE_source: number;
    export let RULE_target: number;
    export let RULE_context: number;
    export let RULE_contextItem: number;
    export let RULE_lastContextItem: number;
    export let RULE_characteristics: number;
    export let RULE_cardRule: number;
    export let RULE_flagRule: number;
    export let RULE_valueSetRule: number;
    export let RULE_fixedValueRule: number;
    export let RULE_containsRule: number;
    export let RULE_onlyRule: number;
    export let RULE_obeysRule: number;
    export let RULE_caretValueRule: number;
    export let RULE_codeCaretValueRule: number;
    export let RULE_mappingRule: number;
    export let RULE_insertRule: number;
    export let RULE_codeInsertRule: number;
    export let RULE_addCRElementRule: number;
    export let RULE_addElementRule: number;
    export let RULE_pathRule: number;
    export let RULE_vsComponent: number;
    export let RULE_vsConceptComponent: number;
    export let RULE_vsFilterComponent: number;
    export let RULE_vsComponentFrom: number;
    export let RULE_vsFromSystem: number;
    export let RULE_vsFromValueset: number;
    export let RULE_vsFilterList: number;
    export let RULE_vsFilterDefinition: number;
    export let RULE_vsFilterOperator: number;
    export let RULE_vsFilterValue: number;
    export let RULE_name: number;
    export let RULE_path: number;
    export let RULE_caretPath: number;
    export let RULE_flag: number;
    export let RULE_strength: number;
    export let RULE_value: number;
    export let RULE_item: number;
    export let RULE_code: number;
    export let RULE_concept: number;
    export let RULE_quantity: number;
    export let RULE_ratio: number;
    export let RULE_reference: number;
    export let RULE_referenceType: number;
    export let RULE_codeableReferenceType: number;
    export let RULE_canonical: number;
    export let RULE_ratioPart: number;
    export let RULE_bool: number;
    export let RULE_targetType: number;
    export let RULE_mostAlphaKeywords: number;
    export { DocContext };
    export { EntityContext };
    export { AliasContext };
    export { ProfileContext };
    export { ExtensionContext };
    export { LogicalContext };
    export { ResourceContext };
    export { SdMetadataContext };
    export { SdRuleContext };
    export { LrRuleContext };
    export { InstanceContext };
    export { InstanceMetadataContext };
    export { InstanceRuleContext };
    export { InvariantContext };
    export { InvariantMetadataContext };
    export { InvariantRuleContext };
    export { ValueSetContext };
    export { VsMetadataContext };
    export { VsRuleContext };
    export { CodeSystemContext };
    export { CsMetadataContext };
    export { CsRuleContext };
    export { RuleSetContext };
    export { RuleSetRuleContext };
    export { ParamRuleSetContext };
    export { ParamRuleSetRefContext };
    export { ParameterContext };
    export { LastParameterContext };
    export { ParamRuleSetContentContext };
    export { MappingContext };
    export { MappingMetadataContext };
    export { MappingEntityRuleContext };
    export { ParentContext };
    export { IdContext };
    export { TitleContext };
    export { DescriptionContext };
    export { ExpressionContext };
    export { XpathContext };
    export { SeverityContext };
    export { InstanceOfContext };
    export { UsageContext };
    export { SourceContext };
    export { TargetContext };
    export { ContextContext };
    export { ContextItemContext };
    export { LastContextItemContext };
    export { CharacteristicsContext };
    export { CardRuleContext };
    export { FlagRuleContext };
    export { ValueSetRuleContext };
    export { FixedValueRuleContext };
    export { ContainsRuleContext };
    export { OnlyRuleContext };
    export { ObeysRuleContext };
    export { CaretValueRuleContext };
    export { CodeCaretValueRuleContext };
    export { MappingRuleContext };
    export { InsertRuleContext };
    export { CodeInsertRuleContext };
    export { AddCRElementRuleContext };
    export { AddElementRuleContext };
    export { PathRuleContext };
    export { VsComponentContext };
    export { VsConceptComponentContext };
    export { VsFilterComponentContext };
    export { VsComponentFromContext };
    export { VsFromSystemContext };
    export { VsFromValuesetContext };
    export { VsFilterListContext };
    export { VsFilterDefinitionContext };
    export { VsFilterOperatorContext };
    export { VsFilterValueContext };
    export { NameContext };
    export { PathContext };
    export { CaretPathContext };
    export { FlagContext };
    export { StrengthContext };
    export { ValueContext };
    export { ItemContext };
    export { CodeContext };
    export { ConceptContext };
    export { QuantityContext };
    export { RatioContext };
    export { ReferenceContext };
    export { ReferenceTypeContext };
    export { CodeableReferenceTypeContext };
    export { CanonicalContext };
    export { RatioPartContext };
    export { BoolContext };
    export { TargetTypeContext };
    export { MostAlphaKeywordsContext };
}
export default FSHParser;
import antlr4 from 'antlr4';
declare class DocContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EOF(): antlr4.TerminalNode;
    entity: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EntityContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    alias(): AliasContext;
    profile(): ProfileContext;
    extension(): ExtensionContext;
    invariant(): InvariantContext;
    instance(): InstanceContext;
    valueSet(): ValueSetContext;
    codeSystem(): CodeSystemContext;
    ruleSet(): RuleSetContext;
    paramRuleSet(): ParamRuleSetContext;
    mapping(): MappingContext;
    logical(): LogicalContext;
    resource(): ResourceContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AliasContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_ALIAS(): antlr4.TerminalNode;
    name(): NameContext;
    EQUAL(): antlr4.TerminalNode;
    SEQUENCE(): antlr4.TerminalNode;
    CODE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ProfileContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_PROFILE(): antlr4.TerminalNode;
    name(): NameContext;
    sdMetadata: (i: any) => any;
    sdRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExtensionContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_EXTENSION(): antlr4.TerminalNode;
    name(): NameContext;
    sdMetadata: (i: any) => any;
    context: (i: any) => any;
    sdRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LogicalContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_LOGICAL(): antlr4.TerminalNode;
    name(): NameContext;
    sdMetadata: (i: any) => any;
    characteristics: (i: any) => any;
    lrRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ResourceContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_RESOURCE(): antlr4.TerminalNode;
    name(): NameContext;
    sdMetadata: (i: any) => any;
    lrRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SdMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    parent(): ParentContext;
    id(): IdContext;
    title(): TitleContext;
    description(): DescriptionContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SdRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    cardRule(): CardRuleContext;
    flagRule(): FlagRuleContext;
    valueSetRule(): ValueSetRuleContext;
    fixedValueRule(): FixedValueRuleContext;
    containsRule(): ContainsRuleContext;
    onlyRule(): OnlyRuleContext;
    obeysRule(): ObeysRuleContext;
    caretValueRule(): CaretValueRuleContext;
    insertRule(): InsertRuleContext;
    pathRule(): PathRuleContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LrRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    sdRule(): SdRuleContext;
    addElementRule(): AddElementRuleContext;
    addCRElementRule(): AddCRElementRuleContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_INSTANCE(): antlr4.TerminalNode;
    name(): NameContext;
    instanceMetadata: (i: any) => any;
    instanceRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    instanceOf(): InstanceOfContext;
    title(): TitleContext;
    description(): DescriptionContext;
    usage(): UsageContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    fixedValueRule(): FixedValueRuleContext;
    insertRule(): InsertRuleContext;
    pathRule(): PathRuleContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InvariantContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_INVARIANT(): antlr4.TerminalNode;
    name(): NameContext;
    invariantMetadata: (i: any) => any;
    invariantRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InvariantMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    description(): DescriptionContext;
    expression(): ExpressionContext;
    xpath(): XpathContext;
    severity(): SeverityContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InvariantRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    fixedValueRule(): FixedValueRuleContext;
    insertRule(): InsertRuleContext;
    pathRule(): PathRuleContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ValueSetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_VALUESET(): antlr4.TerminalNode;
    name(): NameContext;
    vsMetadata: (i: any) => any;
    vsRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    id(): IdContext;
    title(): TitleContext;
    description(): DescriptionContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    vsComponent(): VsComponentContext;
    caretValueRule(): CaretValueRuleContext;
    codeCaretValueRule(): CodeCaretValueRuleContext;
    insertRule(): InsertRuleContext;
    codeInsertRule(): CodeInsertRuleContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CodeSystemContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_CODESYSTEM(): antlr4.TerminalNode;
    name(): NameContext;
    csMetadata: (i: any) => any;
    csRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CsMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    id(): IdContext;
    title(): TitleContext;
    description(): DescriptionContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CsRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    concept(): ConceptContext;
    codeCaretValueRule(): CodeCaretValueRuleContext;
    codeInsertRule(): CodeInsertRuleContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RuleSetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_RULESET(): antlr4.TerminalNode;
    RULESET_REFERENCE(): antlr4.TerminalNode;
    ruleSetRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RuleSetRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    sdRule(): SdRuleContext;
    addElementRule(): AddElementRuleContext;
    addCRElementRule(): AddCRElementRuleContext;
    concept(): ConceptContext;
    codeCaretValueRule(): CodeCaretValueRuleContext;
    codeInsertRule(): CodeInsertRuleContext;
    vsComponent(): VsComponentContext;
    mappingRule(): MappingRuleContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParamRuleSetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_RULESET(): antlr4.TerminalNode;
    paramRuleSetRef(): ParamRuleSetRefContext;
    paramRuleSetContent(): ParamRuleSetContentContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParamRuleSetRefContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PARAM_RULESET_REFERENCE(): antlr4.TerminalNode;
    lastParameter(): LastParameterContext;
    parameter: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParameterContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BRACKETED_PARAM(): antlr4.TerminalNode;
    PLAIN_PARAM(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LastParameterContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LAST_BRACKETED_PARAM(): antlr4.TerminalNode;
    LAST_PLAIN_PARAM(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParamRuleSetContentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    KW_PROFILE: (i: any) => any;
    KW_ALIAS: (i: any) => any;
    KW_EXTENSION: (i: any) => any;
    KW_INSTANCE: (i: any) => any;
    KW_INVARIANT: (i: any) => any;
    KW_VALUESET: (i: any) => any;
    KW_CODESYSTEM: (i: any) => any;
    KW_RULESET: (i: any) => any;
    KW_MAPPING: (i: any) => any;
    KW_LOGICAL: (i: any) => any;
    KW_RESOURCE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MappingContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_MAPPING(): antlr4.TerminalNode;
    name(): NameContext;
    mappingMetadata: (i: any) => any;
    mappingEntityRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MappingMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    id(): IdContext;
    source(): SourceContext;
    target(): TargetContext;
    description(): DescriptionContext;
    title(): TitleContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MappingEntityRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    mappingRule(): MappingRuleContext;
    insertRule(): InsertRuleContext;
    pathRule(): PathRuleContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_PARENT(): antlr4.TerminalNode;
    name(): NameContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_ID(): antlr4.TerminalNode;
    name(): NameContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TitleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_TITLE(): antlr4.TerminalNode;
    STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DescriptionContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_DESCRIPTION(): antlr4.TerminalNode;
    STRING(): antlr4.TerminalNode;
    MULTILINE_STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExpressionContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_EXPRESSION(): antlr4.TerminalNode;
    STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XpathContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_XPATH(): antlr4.TerminalNode;
    STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SeverityContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_SEVERITY(): antlr4.TerminalNode;
    CODE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceOfContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_INSTANCEOF(): antlr4.TerminalNode;
    name(): NameContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UsageContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_USAGE(): antlr4.TerminalNode;
    CODE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SourceContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_SOURCE(): antlr4.TerminalNode;
    name(): NameContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TargetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_TARGET(): antlr4.TerminalNode;
    STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ContextContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_CONTEXT(): antlr4.TerminalNode;
    lastContextItem(): LastContextItemContext;
    contextItem: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ContextItemContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    QUOTED_CONTEXT(): antlr4.TerminalNode;
    UNQUOTED_CONTEXT(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LastContextItemContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LAST_QUOTED_CONTEXT(): antlr4.TerminalNode;
    LAST_UNQUOTED_CONTEXT(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CharacteristicsContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_CHARACTERISTICS(): antlr4.TerminalNode;
    LAST_CODE_ITEM(): antlr4.TerminalNode;
    CODE_ITEM: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CardRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    path(): PathContext;
    CARD(): antlr4.TerminalNode;
    flag: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FlagRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    path: (i: any) => any;
    KW_AND: (i: any) => any;
    flag: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ValueSetRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    path(): PathContext;
    KW_FROM(): antlr4.TerminalNode;
    name(): NameContext;
    strength(): StrengthContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FixedValueRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    path(): PathContext;
    EQUAL(): antlr4.TerminalNode;
    value(): ValueContext;
    KW_EXACTLY(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ContainsRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    path(): PathContext;
    KW_CONTAINS(): antlr4.TerminalNode;
    item: (i: any) => any;
    KW_AND: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OnlyRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    path(): PathContext;
    KW_ONLY(): antlr4.TerminalNode;
    targetType: (i: any) => any;
    KW_OR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ObeysRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    KW_OBEYS(): antlr4.TerminalNode;
    name: (i: any) => any;
    path(): PathContext;
    KW_AND: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaretValueRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    caretPath(): CaretPathContext;
    EQUAL(): antlr4.TerminalNode;
    value(): ValueContext;
    path(): PathContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CodeCaretValueRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    caretPath(): CaretPathContext;
    EQUAL(): antlr4.TerminalNode;
    value(): ValueContext;
    CODE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MappingRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    ARROW(): antlr4.TerminalNode;
    STRING: (i: any) => any;
    path(): PathContext;
    CODE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InsertRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    KW_INSERT(): antlr4.TerminalNode;
    RULESET_REFERENCE(): antlr4.TerminalNode;
    paramRuleSetRef(): ParamRuleSetRefContext;
    path(): PathContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CodeInsertRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    KW_INSERT(): antlr4.TerminalNode;
    RULESET_REFERENCE(): antlr4.TerminalNode;
    paramRuleSetRef(): ParamRuleSetRefContext;
    CODE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AddCRElementRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    path(): PathContext;
    CARD(): antlr4.TerminalNode;
    KW_CONTENTREFERENCE(): antlr4.TerminalNode;
    STRING: (i: any) => any;
    SEQUENCE(): antlr4.TerminalNode;
    CODE(): antlr4.TerminalNode;
    flag: (i: any) => any;
    MULTILINE_STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AddElementRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    path(): PathContext;
    CARD(): antlr4.TerminalNode;
    targetType: (i: any) => any;
    STRING: (i: any) => any;
    flag: (i: any) => any;
    KW_OR: (i: any) => any;
    MULTILINE_STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PathRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    path(): PathContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsComponentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    vsConceptComponent(): VsConceptComponentContext;
    vsFilterComponent(): VsFilterComponentContext;
    KW_INCLUDE(): antlr4.TerminalNode;
    KW_EXCLUDE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsConceptComponentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    code(): CodeContext;
    vsComponentFrom(): VsComponentFromContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterComponentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_CODES(): antlr4.TerminalNode;
    vsComponentFrom(): VsComponentFromContext;
    KW_WHERE(): antlr4.TerminalNode;
    vsFilterList(): VsFilterListContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsComponentFromContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_FROM(): antlr4.TerminalNode;
    vsFromSystem(): VsFromSystemContext;
    vsFromValueset(): VsFromValuesetContext;
    KW_AND(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFromSystemContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_SYSTEM(): antlr4.TerminalNode;
    name(): NameContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFromValuesetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_VSREFERENCE(): antlr4.TerminalNode;
    name: (i: any) => any;
    KW_AND: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterListContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    vsFilterDefinition: (i: any) => any;
    KW_AND: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterDefinitionContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    name(): NameContext;
    vsFilterOperator(): VsFilterOperatorContext;
    vsFilterValue(): VsFilterValueContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterOperatorContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EQUAL(): antlr4.TerminalNode;
    SEQUENCE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterValueContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    code(): CodeContext;
    KW_TRUE(): antlr4.TerminalNode;
    KW_FALSE(): antlr4.TerminalNode;
    REGEX(): antlr4.TerminalNode;
    STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NameContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SEQUENCE(): antlr4.TerminalNode;
    NUMBER(): antlr4.TerminalNode;
    DATETIME(): antlr4.TerminalNode;
    TIME(): antlr4.TerminalNode;
    mostAlphaKeywords(): MostAlphaKeywordsContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PathContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SEQUENCE(): antlr4.TerminalNode;
    NUMBER(): antlr4.TerminalNode;
    DATETIME(): antlr4.TerminalNode;
    TIME(): antlr4.TerminalNode;
    mostAlphaKeywords(): MostAlphaKeywordsContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaretPathContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CARET_SEQUENCE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FlagContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_MOD(): antlr4.TerminalNode;
    KW_MS(): antlr4.TerminalNode;
    KW_SU(): antlr4.TerminalNode;
    KW_TU(): antlr4.TerminalNode;
    KW_NORMATIVE(): antlr4.TerminalNode;
    KW_DRAFT(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StrengthContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_EXAMPLE(): antlr4.TerminalNode;
    KW_PREFERRED(): antlr4.TerminalNode;
    KW_EXTENSIBLE(): antlr4.TerminalNode;
    KW_REQUIRED(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ValueContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STRING(): antlr4.TerminalNode;
    MULTILINE_STRING(): antlr4.TerminalNode;
    NUMBER(): antlr4.TerminalNode;
    DATETIME(): antlr4.TerminalNode;
    TIME(): antlr4.TerminalNode;
    reference(): ReferenceContext;
    canonical(): CanonicalContext;
    code(): CodeContext;
    quantity(): QuantityContext;
    ratio(): RatioContext;
    bool(): BoolContext;
    name(): NameContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ItemContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    name: (i: any) => any;
    CARD(): antlr4.TerminalNode;
    KW_NAMED(): antlr4.TerminalNode;
    flag: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CodeContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CODE(): antlr4.TerminalNode;
    STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConceptContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.TerminalNode;
    CODE: (i: any) => any;
    STRING: (i: any) => any;
    MULTILINE_STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class QuantityContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    UNIT(): antlr4.TerminalNode;
    CODE(): antlr4.TerminalNode;
    NUMBER(): antlr4.TerminalNode;
    STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RatioContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ratioPart: (i: any) => any;
    COLON(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ReferenceContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    REFERENCE(): antlr4.TerminalNode;
    STRING(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ReferenceTypeContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    REFERENCE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CodeableReferenceTypeContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CODEABLE_REFERENCE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CanonicalContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CANONICAL(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RatioPartContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    NUMBER(): antlr4.TerminalNode;
    quantity(): QuantityContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BoolContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_TRUE(): antlr4.TerminalNode;
    KW_FALSE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TargetTypeContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    name(): NameContext;
    referenceType(): ReferenceTypeContext;
    canonical(): CanonicalContext;
    codeableReferenceType(): CodeableReferenceTypeContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MostAlphaKeywordsContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_MS(): antlr4.TerminalNode;
    KW_SU(): antlr4.TerminalNode;
    KW_TU(): antlr4.TerminalNode;
    KW_NORMATIVE(): antlr4.TerminalNode;
    KW_DRAFT(): antlr4.TerminalNode;
    KW_FROM(): antlr4.TerminalNode;
    KW_CONTAINS(): antlr4.TerminalNode;
    KW_NAMED(): antlr4.TerminalNode;
    KW_AND(): antlr4.TerminalNode;
    KW_ONLY(): antlr4.TerminalNode;
    KW_OR(): antlr4.TerminalNode;
    KW_OBEYS(): antlr4.TerminalNode;
    KW_TRUE(): antlr4.TerminalNode;
    KW_FALSE(): antlr4.TerminalNode;
    KW_INCLUDE(): antlr4.TerminalNode;
    KW_EXCLUDE(): antlr4.TerminalNode;
    KW_CODES(): antlr4.TerminalNode;
    KW_WHERE(): antlr4.TerminalNode;
    KW_VSREFERENCE(): antlr4.TerminalNode;
    KW_SYSTEM(): antlr4.TerminalNode;
    KW_CONTENTREFERENCE(): antlr4.TerminalNode;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
