"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadConfigurationFromIgResource = loadConfigurationFromIgResource;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const ini_1 = __importDefault(require("ini"));
const fhir_1 = require("fhir/fhir");
const utils_1 = require("../utils");
/**
 * Attempts to find an ig resource file and extract the required configuration properties from it
 * @param igRoot - path to the root of the IG project
 * @returns {Configuration} the extracted configuration
 */
function loadConfigurationFromIgResource(igRoot) {
    var _a, _b, _c, _d, _e, _f, _g;
    // First, look in the ig.ini file for a path to the IG resource
    let igPath;
    const igIniPath = path_1.default.join(igRoot, 'ig.ini');
    if (fs_extra_1.default.existsSync(igIniPath)) {
        try {
            const igIni = ini_1.default.parse(fs_extra_1.default.readFileSync(igIniPath, 'utf-8'));
            if ((_a = igIni.IG) === null || _a === void 0 ? void 0 : _a.ig) {
                igPath = path_1.default.join(igRoot, igIni.IG.ig);
            }
        }
        catch (_h) { }
    }
    // Make a list of possible path, if ig.ini exists and points to a ig file, add just that
    // otherwise consider all files in the input folder of the ig
    const igInputPath = path_1.default.join(igRoot, 'input');
    const possibleIgPaths = [];
    if (fs_extra_1.default.existsSync(igPath)) {
        possibleIgPaths.push(igPath);
    }
    else if (fs_extra_1.default.existsSync(igInputPath)) {
        possibleIgPaths.push(...fs_extra_1.default.readdirSync(igInputPath).map(file => path_1.default.join(igInputPath, file)));
    }
    // Go through each possible path, and check each xml/json file to see if they are an IG resource
    const fhirConverter = new fhir_1.Fhir();
    let igResource;
    let multipleIgs = false;
    possibleIgPaths.forEach(filePath => {
        let fileContent;
        if (path_1.default.extname(filePath) === '.json') {
            fileContent = fs_extra_1.default.readJSONSync(filePath);
        }
        else if (path_1.default.extname(filePath) === '.xml') {
            fileContent = fhirConverter.xmlToObj(fs_extra_1.default.readFileSync(filePath).toString());
        }
        if ((fileContent === null || fileContent === void 0 ? void 0 : fileContent.resourceType) === 'ImplementationGuide') {
            // If 2 possible IG resources are found, we cannot tell which to use, so return
            if (igResource != null) {
                multipleIgs = true;
                utils_1.logger.error('Multiple possible ImplementationGuide resources in "input" folder, so no configuration can be extracted.' +
                    ' Ensure only one ImplementationGuide resource is in the "input" folder, or give the path to the desired resource in ig.ini.');
            }
            igResource = fileContent;
            igPath = filePath;
        }
    });
    // Extract the configuration from the resource
    if (igResource && igResource.url && !multipleIgs) {
        utils_1.logger.info(`Extracting FSHOnly configuration from ${igPath}...`);
        const config = {
            id: igResource.id,
            canonical: igResource.url.replace(/\/ImplementationGuide.*/, ''),
            url: igResource.url,
            name: igResource.name,
            packageId: igResource.packageId,
            version: igResource.version,
            status: (_b = igResource.status) !== null && _b !== void 0 ? _b : 'draft', // Default status to 'draft' on FSHOnly IGs so exported resources inherit the property
            fhirVersion: (_c = igResource.fhirVersion) !== null && _c !== void 0 ? _c : [],
            dependencies: (_d = igResource.dependsOn) === null || _d === void 0 ? void 0 : _d.filter(dep => dep.packageId && dep.version),
            parameters: (_f = (_e = igResource.definition) === null || _e === void 0 ? void 0 : _e.parameter) !== null && _f !== void 0 ? _f : [],
            FSHOnly: true
        };
        if (!igResource.id) {
            delete config.id;
        }
        (_g = config.dependencies) === null || _g === void 0 ? void 0 : _g.forEach((dep) => {
            if (/[A-Z]/.test(dep.packageId)) {
                const lowercasePackageId = dep.packageId.toLowerCase();
                utils_1.logger.warn(`Dependency ${dep.packageId} contains uppercase characters, which is discouraged. SUSHI will use ${lowercasePackageId} as the package name.`);
                dep.packageId = lowercasePackageId;
            }
        });
        utils_1.logger.info('Extracted configuration:');
        Object.entries(config).forEach(e => {
            if (Array.isArray(e[1])) {
                e[1].forEach((sub, i) => {
                    utils_1.logger.info(`  ${e[0]}[${i}]: ${JSON.stringify(sub)}`);
                });
            }
            else {
                utils_1.logger.info(`  ${e[0]}: ${JSON.stringify(e[1])}`);
            }
        });
        return config;
    }
    return null;
}
//# sourceMappingURL=loadConfigurationFromIgResource.js.map