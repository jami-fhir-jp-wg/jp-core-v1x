"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyRuleSetSubstitutions = applyRuleSetSubstitutions;
const MiniFSHVisitor_1 = __importDefault(require("./generated/MiniFSHVisitor"));
const antlr4_1 = require("antlr4");
const MiniFSHLexer_1 = __importDefault(require("./generated/MiniFSHLexer"));
const MiniFSHParser_1 = __importDefault(require("./generated/MiniFSHParser"));
const os_1 = require("os");
const lodash_1 = require("lodash");
function applyRuleSetSubstitutions(ruleSet, values) {
    const importer = new MiniFSHImporter(ruleSet, values);
    return importer.transformRuleSet();
}
class MiniFSHImporter extends MiniFSHVisitor_1.default {
    constructor(ruleSet, values) {
        super();
        this.ruleSet = ruleSet;
        this.values = values;
        const escapedParameters = this.ruleSet.parameters.map(lodash_1.escapeRegExp).join('|');
        this.bracketParamUsage = new RegExp(`\\[\\[{\\s*(${escapedParameters})\\s*}\\]\\]|{\\s*(${escapedParameters})\\s*}`, 'g');
        this.plainParamUsage = new RegExp(`{\\s*(${escapedParameters})\\s*}`, 'g');
    }
    transformRuleSet() {
        const chars = new antlr4_1.InputStream(this.ruleSet.contents);
        const lexer = new MiniFSHLexer_1.default(chars);
        const tokens = new antlr4_1.CommonTokenStream(lexer);
        const parser = new MiniFSHParser_1.default(tokens);
        parser.buildParseTrees = true;
        // @ts-ignore
        const ctx = parser.ruleSet();
        const transformedRules = this.visitRuleSet(ctx);
        return `RuleSet: ${this.ruleSet.name}${os_1.EOL}${transformedRules.join(os_1.EOL)}`;
    }
    visitRuleSet(ctx) {
        return ctx.someRule().map(ruleCtx => this.visitSomeRule(ruleCtx));
    }
    visitSomeRule(ctx) {
        var _a;
        const ruleParts = ctx.rulePart();
        const regularInsert = ruleParts[0].getText() === 'insert' && ruleParts.length > 1;
        const pathInsert = ((_a = ruleParts[1]) === null || _a === void 0 ? void 0 : _a.getText()) === 'insert';
        const indent = (0, lodash_1.repeat)(' ', this.getStarContextStartColumn(ctx) - 1);
        if (regularInsert || pathInsert) {
            return `${indent}${this.doBracketAwareSubstitution(ctx)}`;
        }
        else {
            return `${indent}${this.doRegularSubstitution(ctx)}`;
        }
    }
    doBracketAwareSubstitution(ctx) {
        const ruleText = ctx
            .rulePart()
            .map(rpCtx => rpCtx.getText())
            .join(' ');
        const bracketDetector = /(?:,|\()\s*\[\[.+?\]\]\s*(?=,|\))/g;
        const bracketZones = [...ruleText.matchAll(bracketDetector)].map(matchInfo => {
            return [matchInfo.index, matchInfo.index + matchInfo[0].length];
        });
        return ('* ' +
            ruleText.replace(this.bracketParamUsage, (fullMatch, bracketParamName, paramName, offset) => {
                if (fullMatch.startsWith('[')) {
                    const matchIndex = this.ruleSet.parameters.indexOf(bracketParamName);
                    if (matchIndex > -1) {
                        return `[[${this.values[matchIndex]
                            .replace(/\]\],/g, ']]\\,')
                            .replace(/\]\]\)/g, ']]\\)')}]]`;
                    }
                    else {
                        return '';
                    }
                }
                else {
                    const matchIndex = this.ruleSet.parameters.indexOf(paramName);
                    if (matchIndex > -1) {
                        // a match without brackets might still be within brackets, but with extra contents.
                        // check the bracket ranges to see which substitution to perform.
                        if (bracketZones.some(([start, end]) => {
                            return start < offset && offset < end;
                        })) {
                            return this.values[matchIndex].replace(/\]\],/g, ']]\\,').replace(/\]\]\)/g, ']]\\)');
                        }
                        else {
                            return this.values[matchIndex];
                        }
                    }
                    else {
                        return '';
                    }
                }
            }));
    }
    doRegularSubstitution(ctx) {
        const ruleText = ctx
            .rulePart()
            .map(rpCtx => rpCtx.getText())
            .join(' ');
        return ('* ' +
            ruleText.replace(this.plainParamUsage, (fullMatch, paramName) => {
                const matchIndex = this.ruleSet.parameters.indexOf(paramName);
                if (matchIndex > -1) {
                    return this.values[matchIndex];
                }
                else {
                    return '';
                }
            }));
    }
    getStarContextStartColumn(ctx) {
        return ctx.STAR().getText().length - ctx.STAR().getText().lastIndexOf('\n') - 2;
    }
}
//# sourceMappingURL=MiniFSHImporter.js.map