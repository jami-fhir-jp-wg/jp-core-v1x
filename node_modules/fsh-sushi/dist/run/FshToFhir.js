"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fshToFhir = fshToFhir;
const import_1 = require("../import");
const export_1 = require("../export");
const fhirdefs_1 = require("../fhirdefs");
const utils_1 = require("../utils");
/**
 * This function can be used to process input string(s) containing FSH definitions into JSON.
 * NOTE: This function is not safe for true asynchronous usage. If two calls of this function are running at once, the error and warnings reported
 * will be inconsistent. Always ensure a given call to this function completes before making a new call.
 * @param {string|string[]} input - A string or array of strings containing FSH
 * @param {fshToFhirOptions} options - An object containing options for processing. Options include canonical, version, fhirVersion, dependencies, and logLevel
 * @returns {Promise<{fhir: any[]; errors: ErrorsAndWarnings['errors']; warnings: ErrorsAndWarnings['warnings'];}>} - Object containing generated fhir, and errors/warnings from processing
 */
async function fshToFhir(input, options = {}) {
    var _a, _b, _c;
    // track errors and warnings, and determine log level from options
    utils_1.errorsAndWarnings.reset();
    utils_1.errorsAndWarnings.shouldTrack = true;
    if (options.logLevel == 'silent') {
        utils_1.logger.transports[0].silent = true;
    }
    else if (options.logLevel != null) {
        if (!isLevel(options.logLevel)) {
            return {
                fhir: null,
                errors: [
                    {
                        message: `Invalid logLevel: ${options.logLevel}. Valid levels include: ${levels.join(', ')}.`
                    }
                ],
                warnings: []
            };
        }
        utils_1.logger.level = options.logLevel;
    }
    const snapshot = (_a = options.snapshot) !== null && _a !== void 0 ? _a : false;
    // set up a config so that sushi can run
    const config = {
        canonical: (_b = options.canonical) !== null && _b !== void 0 ? _b : 'http://example.org',
        FSHOnly: true,
        fhirVersion: [(_c = options.fhirVersion) !== null && _c !== void 0 ? _c : '4.0.1'],
        dependencies: options.dependencies,
        version: options.version
    };
    // load dependencies
    const defs = new fhirdefs_1.FHIRDefinitions();
    await (0, utils_1.loadExternalDependencies)(defs, config);
    // load FSH text into memory
    const rawFSHes = [];
    if (Array.isArray(input)) {
        input.forEach((input, i) => {
            rawFSHes.push(new import_1.RawFSH(input, `Input_${i}`));
        });
    }
    else {
        rawFSHes.push(new import_1.RawFSH(input));
    }
    const tank = (0, utils_1.fillTank)(rawFSHes, config);
    // process FSH text into FHIR
    const outPackage = (0, export_1.exportFHIR)(tank, defs);
    const fhir = [];
    [
        'profiles',
        'extensions',
        'instances',
        'valueSets',
        'codeSystems',
        'logicals',
        'resources'
    ].forEach(artifactType => {
        outPackage[artifactType].forEach((artifact) => {
            fhir.push(artifact.toJSON(snapshot));
        });
    });
    return {
        fhir,
        errors: utils_1.errorsAndWarnings.errors,
        warnings: utils_1.errorsAndWarnings.warnings
    };
}
// Winston levels: https://github.com/winstonjs/winston#logging-levels plus a silent option
const levels = ['silly', 'debug', 'verbose', 'http', 'info', 'warn', 'error', 'silent'];
function isLevel(level) {
    return levels.includes(level);
}
//# sourceMappingURL=FshToFhir.js.map