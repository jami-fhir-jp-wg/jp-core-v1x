"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IGExporter = void 0;
const path_1 = __importDefault(require("path"));
const ini_1 = __importDefault(require("ini"));
const sanitize_filename_1 = __importDefault(require("sanitize-filename"));
const os_1 = require("os");
const lodash_1 = require("lodash");
const title_case_1 = require("title-case");
const fs_extra_1 = require("fs-extra");
const junk_1 = __importDefault(require("junk"));
const fhirtypes_1 = require("../fhirtypes");
const common_1 = require("../fhirtypes/common");
const utils_1 = require("../utils");
const import_1 = require("../import");
// Deprecated but still supported in IG Publisher, so we'll support it too.
const DEPRECATED_RESOURCE_FORMAT_EXTENSION = 'http://hl7.org/fhir/StructureDefinition/implementationguide-resource-format';
const CURRENT_RESOURCE_FORMAT_EXTENSION = 'http://hl7.org/fhir/tools/StructureDefinition/implementationguide-resource-format';
const IG_RESOURCE_FORMAT_EXTENSIONS = [
    DEPRECATED_RESOURCE_FORMAT_EXTENSION,
    CURRENT_RESOURCE_FORMAT_EXTENSION
];
function isR4(fhirVersion) {
    return fhirVersion.some(v => /^R4B?$/.test((0, utils_1.getFHIRVersionInfo)(v).name));
}
/**
 * The IG Exporter exports the FSH artifacts into a file structure supported by the IG Publisher.
 * This allows a FSH Tank to be built as a FHIR IG.  Currently, template-based IG publishing is
 * still new, so this functionality is subject to change.
 *
 * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/index.html}
 */
class IGExporter {
    constructor(pkg, fhirDefs, inputPath) {
        this.pkg = pkg;
        this.fhirDefs = fhirDefs;
        this.inputPath = inputPath;
        this.config = pkg.config;
        this.configPath = path_1.default.resolve(this.inputPath, '..', path_1.default.basename(this.config.filePath));
        this.configName = path_1.default.basename(this.configPath);
    }
    /**
     * Export the IG structure to the location specified by the outPath argument
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#directory-structure}
     * @param outPath {string} - the path to export the IG file structure to
     */
    export(outPath) {
        var _a;
        (0, fs_extra_1.ensureDirSync)(outPath);
        this.normalizeResourceReferences();
        this.initIG();
        this.addResources();
        this.addPredefinedResources();
        this.addConfiguredResources();
        this.sortResources();
        this.addConfiguredGroups();
        this.addIndex(outPath);
        this.addLinkReferences(outPath);
        if (!((_a = this.config.pages) === null || _a === void 0 ? void 0 : _a.length)) {
            this.addOtherPageContent();
        }
        else {
            this.addConfiguredPageContent();
        }
        this.addMenuXML(outPath);
        this.checkIgIni();
        this.checkPackageList();
        if (!isR4(this.config.fhirVersion)) {
            this.updateForR5();
        }
        else {
            this.translateR5PropertiesToR4();
        }
        this.addImplementationGuide(outPath);
    }
    /**
     * Normalizes FSHy ids and names to the required relative URLs or canonicals
     */
    normalizeResourceReferences() {
        var _a, _b, _c, _d;
        (_a = this.config.global) === null || _a === void 0 ? void 0 : _a.forEach(g => {
            if (g.profile) {
                g.profile = this.normalizeResourceReference(g.profile, false);
            }
        });
        (_b = this.config.groups) === null || _b === void 0 ? void 0 : _b.forEach(g => {
            if (g.resources) {
                g.resources = g.resources.map(r => this.normalizeResourceReference(r, true));
            }
        });
        (_c = this.config.resources) === null || _c === void 0 ? void 0 : _c.forEach(r => {
            var _a;
            if ((_a = r.reference) === null || _a === void 0 ? void 0 : _a.reference) {
                r.reference.reference = this.normalizeResourceReference(r.reference.reference, true);
            }
            if (r.exampleCanonical) {
                r.exampleCanonical = this.normalizeResourceReference(r.exampleCanonical, false);
            }
        });
        (_d = this.config.parameters) === null || _d === void 0 ? void 0 : _d.forEach(p => {
            const parsedCode = (0, import_1.parseCodeLexeme)(p.code); // parameter.code will always be a string coming from the config
            if (parsedCode.system) {
                // If a system and code is provided, normalize the system
                p.code = `${this.normalizeResourceReference(parsedCode.system, false)}#${parsedCode.code}`;
            }
        });
    }
    /**
     * Initializes the ImplementationGuide JSON w/ data from the configuration YAML
     *
     * @see {@link https://confluence.hl7.org/pages/viewpage.action?pageId=35718629#NPMPackageSpecification-PackageManifestpropertiesforIGs}
     */
    initIG() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        // first, properties that can be directly used without much trouble
        this.ig = {
            resourceType: 'ImplementationGuide',
            id: this.config.id,
            meta: this.config.meta,
            implicitRules: this.config.implicitRules,
            language: this.config.language,
            text: this.config.text,
            contained: this.config.contained,
            extension: this.config.extension,
            modifierExtension: this.config.modifierExtension,
            url: (_a = this.config.url) !== null && _a !== void 0 ? _a : `${this.config.canonical}/ImplementationGuide/${this.config.id}`,
            version: this.config.version,
            // name must be alphanumeric (allowing underscore as well)
            name: this.config.name.replace(/[^A-Za-z0-9_]/g, ''),
            title: this.config.title,
            status: this.config.status,
            experimental: this.config.experimental,
            date: this.config.date,
            publisher: this.config.publisher,
            contact: this.config.contact,
            description: this.config.description,
            useContext: this.config.useContext,
            jurisdiction: this.config.jurisdiction,
            copyright: this.config.copyright,
            packageId: (_b = this.config.packageId) !== null && _b !== void 0 ? _b : this.config.id,
            license: this.config.license,
            fhirVersion: this.config.fhirVersion,
            // put an empty dependsOn here to preserve the location of this property (delete later if not needed)
            dependsOn: [],
            global: this.config.global,
            definition: {
                extension: (_c = this.config.definition) === null || _c === void 0 ? void 0 : _c.extension,
                // put an empty grouping here to preserve the location of this property (delete later if not needed)
                grouping: [],
                resource: [],
                page: {
                    nameUrl: 'toc.html',
                    title: 'Table of Contents',
                    generation: 'html',
                    page: [] // index.[md|html] is required and added later
                },
                // required parameters are enforced in the configuration
                // default to empty array in case we want to add other parameters later
                parameter: (_d = this.config.parameters) !== null && _d !== void 0 ? _d : [],
                template: this.config.templates
            }
        };
        // Add the path-history, if applicable (only applies to HL7 IGs)
        if (/^https?:\/\/hl7.org\//.test(this.config.canonical) &&
            !this.ig.definition.parameter.some(param => {
                return param.code === 'path-history';
            })) {
            this.ig.definition.parameter.push({
                code: 'path-history',
                value: `${this.config.canonical}/history.html`
            });
        }
        // Default 'autoload-resources' to false if it is not already defined
        // and only if custom resources are defined. This is done to counter
        // the IG Publisher behaving as if 'autoload-resources' is set to true
        // and allowing the IG Publisher to attempt processing of custom resources.
        if (((_e = this.pkg.resources) === null || _e === void 0 ? void 0 : _e.length) > 0 &&
            !this.ig.definition.parameter.some(param => {
                return param.code === 'autoload-resources';
            })) {
            this.ig.definition.parameter.push({
                code: 'autoload-resources',
                value: 'false'
            });
            utils_1.logger.info('The autoload-resources parameter has been set to false because this implementation guide contains custom resources.');
        }
        // add dependencies, filtering out "virtual" extension packages
        const dependencies = (_f = this.config.dependencies) === null || _f === void 0 ? void 0 : _f.filter(d => !/^hl7\.fhir\.extensions\.r[2345]$/.test(d.packageId));
        if (dependencies === null || dependencies === void 0 ? void 0 : dependencies.length) {
            const igs = this.fhirDefs.allImplementationGuides();
            for (const dependency of dependencies) {
                const dependsEntry = this.fixDependsOn(dependency, igs);
                if (dependsEntry) {
                    this.ig.dependsOn.push(dependsEntry);
                }
            }
        }
        else {
            delete this.ig.dependsOn;
        }
        // delete grouping value if there are no groups in the config
        if (!((_g = this.config.groups) === null || _g === void 0 ? void 0 : _g.length) && !((_h = this.config.resources) === null || _h === void 0 ? void 0 : _h.some(r => r.groupingId != null))) {
            delete this.ig.definition.grouping;
        }
        // delete global if it is empty
        if (!((_j = this.config.global) === null || _j === void 0 ? void 0 : _j.length)) {
            delete this.ig.global;
        }
        // delete templates if it is empty
        if (!((_k = this.config.templates) === null || _k === void 0 ? void 0 : _k.length)) {
            delete this.ig.definition.template;
        }
    }
    /**
     * Fixes a dependsOn entry by specifying its uri (if not yet specified) and generating an id (if
     * not yet specified). Will also ensure that required properties (uri/version) are available.
     * If it cannot ensure a valid dependsOn entry, it will return undefined.
     * @param dependency - the dependency to fix
     * @param igs - the IGs to search when finding the dependency URI
     * @returns the fixed dependency or null if it can't be fixed
     */
    fixDependsOn(dependency, igs) {
        // Clone it so we don't mutate the original
        const dependsOn = (0, lodash_1.cloneDeep)(dependency);
        // By default, dependsOn.reason should not be supported because it is an R5 element
        delete dependsOn.reason;
        if (dependsOn.version == null) {
            // No need for the detailed log message since we already logged one in the package loader.
            utils_1.logger.error(`Failed to add ${dependency.packageId} to ImplementationGuide instance because no ` +
                `version was specified in your ${this.configName}.`);
            return;
        }
        if (dependsOn.version === 'latest') {
            const dependencyIG = igs.find(ig => ig.packageId === dependsOn.packageId);
            if ((dependencyIG === null || dependencyIG === void 0 ? void 0 : dependencyIG.version) != null) {
                dependsOn.version = dependencyIG.version;
            }
            else {
                const packageJSON = this.fhirDefs
                    .allPackageJsons()
                    .find(p => p.name === dependsOn.packageId);
                if ((packageJSON === null || packageJSON === void 0 ? void 0 : packageJSON.version) != null) {
                    dependsOn.version = packageJSON.version;
                }
            }
        }
        if (dependsOn.uri == null) {
            // Need to find the URI from the IG in the FHIR cache
            const dependencyIG = igs.find(ig => ig.packageId === dependsOn.packageId &&
                (ig.version === dependsOn.version ||
                    'current' === dependsOn.version ||
                    'dev' === dependsOn.version));
            dependsOn.uri = dependencyIG === null || dependencyIG === void 0 ? void 0 : dependencyIG.url;
            if (dependsOn.uri == null) {
                // there may be a package.json that can help us here
                const dependencyPackageJson = this.fhirDefs.getPackageJson(`${dependsOn.packageId}#${dependsOn.version}`);
                dependsOn.uri = dependencyPackageJson === null || dependencyPackageJson === void 0 ? void 0 : dependencyPackageJson.canonical;
            }
            if (dependsOn.uri == null) {
                // setting uri to required format as indicated in zulip discussion:
                // https://chat.fhir.org/#narrow/stream/179252-IG-creation/topic/fhir.2Edicom.20has.20no.20ImplementationGuide.20resource/near/265772431
                dependsOn.uri = `http://fhir.org/packages/${dependsOn.packageId}/ImplementationGuide/${dependsOn.packageId}`;
            }
        }
        if (dependsOn.id == null) {
            // packageId should be "a..z, A..Z, 0..9, and _ and it must start with a..z | A..Z" per
            // https://chat.fhir.org/#narrow/stream/215610-shorthand/topic/SUSHI.200.2E12.2E7/near/199193333
            // depId should be [A-Za-z0-9\-\.]{1,64}, so we replace . and - with _ and prepend "id_" if it does not start w/ a-z|A-Z
            dependsOn.id = /[A-Za-z]/.test(dependsOn.packageId[0])
                ? dependsOn.packageId.replace(/\.|-/g, '_')
                : 'id_' + dependsOn.packageId.replace(/\.|-/g, '_');
        }
        // Keep dependsOn.extension as configured, so no special handling is needed
        return dependsOn;
    }
    /**
     * Add the index.md file. Creates an index.md based on the "indexPageContent" in sushi-config.yaml.
     * If the user provided an index file, and no "indexPageContent" in sushi-config.yaml is specified,
     * the provided file is used instead. The provided file may be in one of two locations:
     * ./input/pagecontent or ./input/pages
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input}
     * @param igPath - the path where the IG is exported to
     */
    addIndex(igPath) {
        var _a;
        const pageContentExportPath = path_1.default.join(igPath, 'input', 'pagecontent');
        // If the user provided an index.md file, use that
        // There are four possible locations for it (two filenames in two directories)
        // If more possibilities arise, rewrite this to avoid having to list all of them
        const inputIndexMarkdownPageContentPath = path_1.default.join(this.inputPath, 'input', 'pagecontent', 'index.md');
        const inputIndexXMLPageContentPath = path_1.default.join(this.inputPath, 'input', 'pagecontent', 'index.xml');
        const inputIndexMarkdownPagesPath = path_1.default.join(this.inputPath, 'input', 'pages', 'index.md');
        const inputIndexXMLPagesPath = path_1.default.join(this.inputPath, 'input', 'pages', 'index.xml');
        let generation = 'markdown';
        let filePath;
        if ((0, fs_extra_1.existsSync)(inputIndexMarkdownPageContentPath))
            filePath = inputIndexMarkdownPageContentPath;
        if ((0, fs_extra_1.existsSync)(inputIndexXMLPageContentPath))
            filePath = inputIndexXMLPageContentPath;
        if ((0, fs_extra_1.existsSync)(inputIndexMarkdownPagesPath))
            filePath = inputIndexMarkdownPagesPath;
        if ((0, fs_extra_1.existsSync)(inputIndexXMLPagesPath))
            filePath = inputIndexXMLPagesPath;
        if (this.config.indexPageContent) {
            (0, fs_extra_1.ensureDirSync)(pageContentExportPath);
            if (filePath) {
                const filePathString = path_1.default.join(path_1.default.basename(this.inputPath), path_1.default.relative(this.inputPath, filePath));
                const preferredFileMessage = `Since a ${filePathString} file was found, the "indexPageContent" property in the ${this.configName} ` +
                    'will be ignored and an index.md file will not be generated. Remove the "indexPageContent" ' +
                    `property in ${this.configName} to resolve this warning.`;
                utils_1.logger.warn(`Found both an "indexPageContent" property in ${this.configName} and an index file at ` +
                    `${filePathString}. ${preferredFileMessage}`, {
                    file: filePath
                });
                if (!(0, fs_extra_1.existsSync)(inputIndexMarkdownPagesPath) &&
                    !(0, fs_extra_1.existsSync)(inputIndexMarkdownPageContentPath) &&
                    ((0, fs_extra_1.existsSync)(inputIndexXMLPagesPath) || (0, fs_extra_1.existsSync)(inputIndexXMLPageContentPath))) {
                    generation = 'html';
                }
                // Add user-provided index file to IG definition
                this.ig.definition.page.page.push({
                    nameUrl: 'index.html',
                    title: 'Home',
                    generation
                });
                return;
            }
            // Generate index file if indexPageContent is provided in config
            const filePathString = 'input';
            const warning = warningBlock('<!-- index.md {% comment %}', '{% endcomment %} -->', [
                `To change the contents of this file, edit the "indexPageContent" attribute in the tank ${this.configName} file`,
                `or provide your own index file in the ${filePathString}${path_1.default.sep}pagecontent or ${filePathString}${path_1.default.sep}pages folder.`,
                'See: https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input'
            ]);
            const outputPath = path_1.default.join(pageContentExportPath, 'index.md');
            (0, fs_extra_1.outputFileSync)(outputPath, `${warning}${this.config.indexPageContent}`);
            utils_1.logger.info(`Generated index.md based on "indexPageContent" in ${this.configName}.`);
        }
        else if (!(0, fs_extra_1.existsSync)(inputIndexMarkdownPagesPath) &&
            !(0, fs_extra_1.existsSync)(inputIndexMarkdownPageContentPath) &&
            ((0, fs_extra_1.existsSync)(inputIndexXMLPagesPath) || (0, fs_extra_1.existsSync)(inputIndexXMLPageContentPath))) {
            generation = 'html';
        }
        else {
            // do nothing -- no indexPageContent in config, do nothing with index file if provided
        }
        // Add user-provided or generated index file to IG definition
        // If pages are defined in the configuration, this is the author's responsibility
        if (!((_a = this.config.pages) === null || _a === void 0 ? void 0 : _a.length) && (filePath || this.config.indexPageContent)) {
            this.ig.definition.page.page.push({
                nameUrl: 'index.html',
                title: 'Home',
                generation
            });
        }
    }
    addLinkReferences(igPath) {
        var _a;
        // no need to make this file if there are no resources
        if (!((_a = this.ig.definition) === null || _a === void 0 ? void 0 : _a.resource.length)) {
            return;
        }
        const linkReferencesDir = path_1.default.join(igPath, 'fsh-generated', 'includes');
        const linkReferencesExportPath = path_1.default.join(linkReferencesDir, 'fsh-link-references.md');
        (0, fs_extra_1.ensureDirSync)(linkReferencesDir);
        const content = this.ig.definition.resource.map(igResource => {
            var _a, _b, _c, _d, _e, _f;
            // FSH resources and predefined resources will have a _linkRef
            // a configured resource may lack a name
            // in that case, try to build a useful name from the reference
            const linkName = (_b = (_a = igResource._linkRef) !== null && _a !== void 0 ? _a : igResource.name) !== null && _b !== void 0 ? _b : (_d = (_c = igResource.reference) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.replace(/^[^\/]*\//, '');
            // delete the _linkRef now that we've used it
            delete igResource._linkRef;
            return `[${linkName}]: ${(_f = (_e = igResource.reference) === null || _e === void 0 ? void 0 : _e.reference) === null || _f === void 0 ? void 0 : _f.replace('/', '-')}.html`;
        });
        (0, fs_extra_1.outputFileSync)(linkReferencesExportPath, content.join('\n'));
    }
    /**
     * Adds additional pages beyond index.md that are defined by the user.
     * Only add formats that are supported by the IG template
     * Intro and notes file contents are injected into relevant pages and should not be treated as their own page
     * Three directories are checked for additional page content:
     * pagecontent, pages, and resource-docs
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input}
     */
    addOtherPageContent() {
        const pageContentFolderNames = ['pagecontent', 'pages', 'resource-docs'];
        for (const contentFolder of pageContentFolderNames) {
            const inputPageContentPath = path_1.default.join(this.inputPath, 'input', contentFolder);
            if ((0, fs_extra_1.existsSync)(inputPageContentPath)) {
                const organizedPages = this.organizePageContent((0, fs_extra_1.readdirSync)(inputPageContentPath));
                let invalidFileTypeIncluded = false;
                organizedPages.forEach(page => {
                    // All user defined pages are included in input/${contentFolder}
                    const pagePath = path_1.default.join(this.inputPath, 'input', contentFolder, page.originalName);
                    const isSupportedFileType = page.fileType === 'md' || page.fileType === 'xml';
                    const isIntroOrNotesFile = page.name.endsWith('-intro') || page.name.endsWith('-notes');
                    if (isSupportedFileType) {
                        // Intro and notes files will be in supported formats but are not separate pages, so they should not be added to IG definition
                        if (!isIntroOrNotesFile) {
                            // Valid page files will be added to the IG definition
                            this.ig.definition.page.page.push({
                                nameUrl: `${page.name}.html`,
                                title: page.title,
                                generation: page.fileType === 'md' ? 'markdown' : 'html'
                            });
                        }
                    }
                    else if (!junk_1.default.is(path_1.default.basename(pagePath))) {
                        invalidFileTypeIncluded = true;
                    }
                });
                if (invalidFileTypeIncluded) {
                    const errorString = 'Files not in the supported file types (.md and .xml) were detected.';
                    utils_1.logger.warn(errorString, {
                        file: inputPageContentPath
                    });
                }
            }
        }
    }
    /**
     * Adds additional pages to the IG based on user configuration.
     * Only pages present in the configuration are added, regardless of available files.
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#directory-structure}
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input}
     */
    addConfiguredPageContent() {
        // only configured pages are added to the implementation guide,
        for (const page of this.config.pages) {
            this.addConfiguredPage(page, this.ig.definition.page.page);
        }
        // all files in page content folders are left alone but checked for supported file types
        const pageContentFolderNames = ['pagecontent', 'pages', 'resource-docs'];
        for (const contentFolder of pageContentFolderNames) {
            let invalidFileTypeIncluded = false;
            const inputPageContentPath = path_1.default.join(this.inputPath, 'input', contentFolder);
            if ((0, fs_extra_1.existsSync)(inputPageContentPath)) {
                for (const contentFile of (0, fs_extra_1.readdirSync)(inputPageContentPath)) {
                    const fileType = contentFile.slice(contentFile.lastIndexOf('.') + 1);
                    if (!(fileType === 'md' || fileType === 'xml') && !junk_1.default.is(path_1.default.basename(contentFile))) {
                        invalidFileTypeIncluded = true;
                    }
                }
            }
            if (invalidFileTypeIncluded) {
                const errorString = 'Files not in the supported file types (.md and .xml) were detected. These files will be included without any processing.';
                utils_1.logger.warn(errorString, {
                    file: inputPageContentPath
                });
            }
        }
    }
    /**
     * Adds pages to the implementation guide's list of pages.
     * The page configuration is traversed recursively to maintain the configured structure.
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input}
     * @param {ImplementationGuideDefinitionPage} page - the current page being added to a list of output pages
     * @param {ImplementationGuideDefinitionPage[]} target - the list of output pages that will receive the current page
     */
    addConfiguredPage(page, target) {
        var _a, _b, _c;
        if (page.nameUrl) {
            const lastPeriod = page.nameUrl.lastIndexOf('.');
            let name, fileType = '';
            if (lastPeriod === -1) {
                name = page.nameUrl;
            }
            else {
                name = page.nameUrl.slice(0, lastPeriod);
                fileType = page.nameUrl.slice(lastPeriod + 1);
            }
            // Any page listed in configuration will be added, even if it does not exist.
            const igPage = {
                nameUrl: `${name}.html`,
                title: (_a = page.title) !== null && _a !== void 0 ? _a : (0, title_case_1.titleCase)((0, lodash_1.words)(name).join(' ')),
                generation: (_b = page.generation) !== null && _b !== void 0 ? _b : (fileType === 'md' ? 'markdown' : 'html'),
                ...(page.extension && { extension: page.extension }),
                ...(page.modifierExtension && { modifierExtension: page.modifierExtension })
            };
            if ((_c = page.page) === null || _c === void 0 ? void 0 : _c.length) {
                const igSubpages = [];
                for (const subpage of page.page) {
                    this.addConfiguredPage(subpage, igSubpages);
                }
                if (igSubpages.length > 0) {
                    igPage.page = igSubpages;
                }
            }
            target.push(igPage);
        }
    }
    /**
     * Sorts and renames pages based on numeric prefixes.
     * Numeric prefixes are used for applying a sort order, and remain part of the file name.
     *
     * @param {string[]} pages - list of file names with extensions
     * @returns {PageMetadata []} - sorted list of file information objects
     */
    organizePageContent(pages) {
        // Remove any preexisting duplicate file names, and log an error
        pages = pages.filter(page => {
            if (pages.find(p => p.slice(0, p.lastIndexOf('.')) === page.slice(0, page.lastIndexOf('.'))) !==
                page) {
                utils_1.logger.error(`Duplicate file ${page} will be ignored. Please rename to avoid collisions.`, {
                    file: page
                });
                return false;
            }
            return true;
        });
        const pageData = pages.map(page => {
            const nameParts = page.match(/^(\d+)_(.*)/);
            let prefix = null;
            let nameWithoutPrefix;
            const nameWithPrefix = page.slice(0, page.lastIndexOf('.'));
            if (nameParts == null) {
                nameWithoutPrefix = page.slice(0, page.lastIndexOf('.'));
            }
            else {
                prefix = parseInt(nameParts[1]);
                nameWithoutPrefix = nameParts[2].slice(0, nameParts[2].lastIndexOf('.'));
            }
            return {
                originalName: page,
                prefix: prefix,
                name: nameWithPrefix,
                title: (0, title_case_1.titleCase)((0, lodash_1.words)(nameWithoutPrefix).join(' ')),
                fileType: page.slice(page.lastIndexOf('.') + 1)
            };
        });
        let mightHaveDuplicates = true;
        while (mightHaveDuplicates) {
            mightHaveDuplicates = false;
            pageData.forEach(page => {
                const sameName = pageData.filter(otherPage => otherPage.name == page.name);
                if (sameName.length > 1) {
                    mightHaveDuplicates = true;
                    sameName.forEach(matchingPage => {
                        matchingPage.name = matchingPage.originalName.slice(0, matchingPage.originalName.lastIndexOf('.'));
                    });
                }
            });
        }
        return pageData.filter(page => page.name !== 'index').sort(this.compareIgFilenames);
    }
    /**
     * Compares two file names, each of which may be prefixed with a number.
     * If neither file has a prefix, compares the file names alphabetically.
     * If one file has a prefix, that file is before the other.
     * If both have a prefix, compares the prefixes numerically.
     * If the prefixes are equal, resolves the tie by comparing the file names alphabetically.
     *
     * @param {PageMetadata} pageA - metadata for first file
     * @param {PageMetadata} pageB - metadata for second file
     * @returns {number} - positive when file b comes first, negative when file a comes first, zero when the file names are equal.
     */
    compareIgFilenames(pageA, pageB) {
        if (pageA.prefix == null && pageB.prefix == null) {
            return pageA.name.localeCompare(pageB.name);
        }
        else if (pageA.prefix == null) {
            return 1;
        }
        else if (pageB.prefix == null) {
            return -1;
        }
        else {
            const prefixComparison = pageA.prefix - pageB.prefix;
            if (prefixComparison == 0) {
                return pageA.name.localeCompare(pageB.name);
            }
            else {
                return prefixComparison;
            }
        }
    }
    /**
     * Adds menu.xml
     * A user can define a menu in sushi-config.yaml or provide one in ./input/includes.
     * If neither is provided, a warning is issued to the user.
     *
     * @param {string} igPath - the path where the IG is exported to
     */
    addMenuXML(igPath) {
        const menuXMLDefaultPath = path_1.default.join(this.inputPath, 'input', 'includes', 'menu.xml');
        const menuXMLOutputPath = path_1.default.join(igPath, 'fsh-generated', 'includes', 'menu.xml');
        const menuXMLExists = (0, fs_extra_1.existsSync)(menuXMLDefaultPath);
        // If user provided file and config, log a warning but prefer the file.
        if (menuXMLExists && this.config.menu) {
            const filePathString = path_1.default.join(path_1.default.basename(this.inputPath), 'input', 'includes', 'menu.xml');
            const preferredFileMessage = `Since a ${filePathString} file was found, the "menu" property in the ${this.configName} ` +
                `will be ignored and a menu.xml file will not be generated. Remove the ${filePathString} ` +
                `file to use the "menu" property in ${this.configName} to generate a menu.xml file instead.`;
            utils_1.logger.warn(`Found both a "menu" property in ${this.configName} and a menu.xml file at ${filePathString}. ` +
                `${preferredFileMessage}`, {
                file: menuXMLDefaultPath
            });
            return;
        }
        // Use config menu if defined and no file is provided.
        if (this.config.menu) {
            let menu = `<ul xmlns="http://www.w3.org/1999/xhtml" class="nav navbar-nav">${os_1.EOL}`;
            this.config.menu.forEach(item => {
                menu += this.buildMenuItem(item, 2);
            });
            menu += '</ul>';
            const filePathString = path_1.default.join('input', 'includes');
            const warning = warningBlock(`<!-- ${path_1.default.parse(menuXMLOutputPath).base} {% comment %}`, '{% endcomment %} -->', [
                `To change the contents of this file, edit the "menu" attribute in the tank ${this.configName} file`,
                `or provide your own menu.xml in the ${filePathString} folder`
            ]);
            (0, fs_extra_1.outputFileSync)(menuXMLOutputPath, `${warning}${menu}`, 'utf8');
        }
        // If user did not provide file or config, log a warning.
        if (!menuXMLExists && !this.config.menu) {
            const filePathString = path_1.default.join('input', 'includes');
            utils_1.logger.warn(`No "menu" property or file was found. Generate a menu.xml in the ${filePathString} folder or specify a "menu" property in ${this.configName}.`);
        }
    }
    /**
     * Build individual menu item for menu.xml file. An item could contain a submenu
     *
     * @param {ConfigurationMenuItem} item - the menu item to be rendered
     * @param {number} spaces - the base number of spaces to indent
     * @returns {string} - the piece of XML relating to the given menu item
     */
    buildMenuItem(item, spaces) {
        const prefixSpaces = ' '.repeat(spaces);
        let menuItem = '';
        if (item.subMenu) {
            menuItem += `${prefixSpaces}<li class="dropdown">${os_1.EOL}`;
            menuItem += this.buildSubMenu(item, spaces + 2);
            menuItem += `${prefixSpaces}</li>${os_1.EOL}`;
        }
        else {
            menuItem += `${prefixSpaces}<li>${os_1.EOL}${prefixSpaces}${'  '}`;
            if (item.url) {
                menuItem += '<a ';
                if (item.openInNewTab)
                    menuItem += 'target="_blank" ';
                menuItem += `href="${item.url}">`;
            }
            menuItem += this.encodeMenuName(item.name);
            if (item.url) {
                menuItem += '</a>';
            }
            menuItem += `${os_1.EOL}${prefixSpaces}</li>${os_1.EOL}`;
        }
        return menuItem;
    }
    /**
     * Build a submenu for an item for menu.xml.
     *
     * @param item - the menu item with submenu to be rendered
     * @param spaces - the base number of spaces to indent
     * @returns {string} - the piece of XML relating to the submenu
     */
    buildSubMenu(item, spaces) {
        var _a;
        const prefixSpaces = ' '.repeat(spaces);
        let subMenu = `${prefixSpaces}<a data-toggle="dropdown" href="#" class="dropdown-toggle">${this.encodeMenuName(item.name)}${os_1.EOL}`;
        subMenu += `${prefixSpaces}${'  '}<b class="caret"></b>${os_1.EOL}`;
        subMenu += `${prefixSpaces}</a>${os_1.EOL}`;
        subMenu += `${prefixSpaces}<ul class="dropdown-menu">${os_1.EOL}`;
        (_a = item.subMenu) === null || _a === void 0 ? void 0 : _a.forEach((subItem) => {
            if (subItem.subMenu) {
                utils_1.logger.warn(`The ${subItem.name} menu item specifies a sub-menu. The IG template currently only supports two levels of menus. ` +
                    `The sub-menu for ${subItem.name} is included in the menu.xml file but it will not be rendered in the IG.`);
            }
            subMenu += this.buildMenuItem(subItem, spaces + 2);
        });
        subMenu += `${prefixSpaces}</ul>${os_1.EOL}`;
        return subMenu;
    }
    encodeMenuName(name) {
        let escapedName = name;
        if (/&quot;|&apos;|&lt;|&gt;|&amp;/g.test(name)) {
            utils_1.logger.warn('SUSHI now supports automatically escaping characters in XML. You can safely replace the ' +
                `escaped character with the unescaped character in the following menu configuration item: ${name}. ` +
                'SUSHI will escape it when generating the menu.xml file.');
        }
        escapedName = escapedName.replace(/"/g, '&quot;');
        escapedName = escapedName.replace(/'/g, '&apos;');
        escapedName = escapedName.replace(/</g, '&lt;');
        escapedName = escapedName.replace(/>/g, '&gt;');
        // Replace & with &amp; but we don't want to replace any previously escaped characters, which will start with &.
        escapedName = escapedName.replace(/&(?!quot;|apos;|lt;|gt;|amp;)/g, '&amp;');
        return escapedName;
    }
    /**
     * Add each of the resources from the package to the ImplementationGuide JSON file.
     * Configuration may specify resources to omit.
     *
     * This function has similar operation to addPredefinedResources, and both should be
     * analyzed when making changes to either.
     */
    addResources() {
        // NOTE: Custom resources are not included in the implementation guide
        //       because the IG Publisher will not except newly defined resources.
        //       This only prevents adding custom resources into the IG. It does
        //       NOT prevent custom resource StructureDefinitions from being
        //       written to disk.
        const resources = [
            ...this.pkg.profiles,
            ...this.pkg.extensions,
            ...this.pkg.logicals,
            ...this.pkg.valueSets,
            ...this.pkg.codeSystems
        ];
        resources.forEach(r => {
            var _a;
            const referenceKey = `${r.resourceType}/${r.id}`;
            const configResource = ((_a = this.config.resources) !== null && _a !== void 0 ? _a : []).find(resource => { var _a; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) == referenceKey; });
            if ((configResource === null || configResource === void 0 ? void 0 : configResource.omit) !== true) {
                this.addPackageResource(referenceKey, r, configResource);
            }
        });
        this.pkg.instances
            .filter(instance => instance._instanceMeta.usage !== 'Inline')
            .filter(instance => 
        // Filter out instances that have a type that has the same type as a custom resource defined in the package
        !this.pkg.resources.some(r => r.type === instance.resourceType))
            .forEach(instance => {
            var _a, _b;
            // Logical instances should use Binary type. See: https://fshschool.org/docs/sushi/tips/#instances-of-logical-models
            const referenceKey = `${instance._instanceMeta.sdKind === 'logical' ? 'Binary' : instance.resourceType}/${(_a = instance.id) !== null && _a !== void 0 ? _a : instance._instanceMeta.name}`;
            const configResource = ((_b = this.config.resources) !== null && _b !== void 0 ? _b : []).find(resource => { var _a; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) == referenceKey; });
            if ((configResource === null || configResource === void 0 ? void 0 : configResource.omit) !== true) {
                this.addPackageResource(referenceKey, instance, configResource);
            }
        });
    }
    addPackageResource(referenceKey, pkgResource, configResource) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        const newResource = {
            reference: { reference: referenceKey }
        };
        if (pkgResource instanceof fhirtypes_1.InstanceDefinition) {
            newResource.name =
                (_c = (_b = (_a = configResource === null || configResource === void 0 ? void 0 : configResource.name) !== null && _a !== void 0 ? _a : pkgResource._instanceMeta.title) !== null && _b !== void 0 ? _b : (0, utils_1.stringOrElse)(pkgResource.title)) !== null && _c !== void 0 ? _c : pkgResource._instanceMeta.name;
            newResource.description =
                (_e = (_d = configResource === null || configResource === void 0 ? void 0 : configResource.description) !== null && _d !== void 0 ? _d : pkgResource._instanceMeta.description) !== null && _e !== void 0 ? _e : (0, utils_1.stringOrElse)(pkgResource.description);
            newResource._linkRef = pkgResource.id;
        }
        else {
            newResource.name =
                (_h = (_g = (_f = configResource === null || configResource === void 0 ? void 0 : configResource.name) !== null && _f !== void 0 ? _f : pkgResource.title) !== null && _g !== void 0 ? _g : pkgResource.name) !== null && _h !== void 0 ? _h : pkgResource.id;
            newResource.description = (_j = configResource === null || configResource === void 0 ? void 0 : configResource.description) !== null && _j !== void 0 ? _j : pkgResource.description;
            newResource._linkRef = pkgResource.name;
        }
        if ((_k = configResource === null || configResource === void 0 ? void 0 : configResource.fhirVersion) === null || _k === void 0 ? void 0 : _k.length) {
            newResource.fhirVersion = configResource.fhirVersion;
        }
        if (configResource === null || configResource === void 0 ? void 0 : configResource.groupingId) {
            newResource.groupingId = configResource.groupingId;
            this.addGroup(newResource.groupingId);
        }
        if (configResource === null || configResource === void 0 ? void 0 : configResource.exampleCanonical) {
            newResource.exampleCanonical = configResource.exampleCanonical;
        }
        else if (typeof (configResource === null || configResource === void 0 ? void 0 : configResource.exampleBoolean) === 'boolean') {
            newResource.exampleBoolean = configResource.exampleBoolean;
        }
        else if (pkgResource instanceof fhirtypes_1.InstanceDefinition &&
            pkgResource._instanceMeta.usage === 'Example') {
            // so here's where we set exampleCanonical
            // but we need to be able to set it without there being anything in meta.profile
            const metaProfileUrls = (_m = (_l = pkgResource.meta) === null || _l === void 0 ? void 0 : _l.profile) !== null && _m !== void 0 ? _m : [];
            const exampleUrl = [...metaProfileUrls, (_o = pkgResource._instanceMeta.instanceOfUrl) !== null && _o !== void 0 ? _o : ''].find(url => {
                var _a;
                const [baseUrl, version] = url.split('|', 2);
                const availableProfileOrLogical = this.pkg.fish(baseUrl, utils_1.Type.Profile, utils_1.Type.Logical);
                return (availableProfileOrLogical != null &&
                    (version == null ||
                        version === ((_a = availableProfileOrLogical.version) !== null && _a !== void 0 ? _a : this.config.version)));
            });
            if (exampleUrl) {
                newResource.exampleCanonical = exampleUrl.split('|', 1)[0];
            }
            else {
                newResource.exampleBoolean = true;
            }
        }
        else {
            newResource.exampleBoolean = false;
        }
        if ((_p = configResource === null || configResource === void 0 ? void 0 : configResource.extension) === null || _p === void 0 ? void 0 : _p.length) {
            newResource.extension = configResource.extension;
        }
        if (pkgResource instanceof fhirtypes_1.InstanceDefinition &&
            pkgResource._instanceMeta.sdKind === 'logical') {
            if (!((_q = configResource === null || configResource === void 0 ? void 0 : configResource.extension) === null || _q === void 0 ? void 0 : _q.some(ext => IG_RESOURCE_FORMAT_EXTENSIONS.includes(ext.url)))) {
                // Logical instances should add a special extension. See: https://fshschool.org/docs/sushi/tips/#instances-of-logical-models
                newResource.extension = (_r = newResource.extension) !== null && _r !== void 0 ? _r : [];
                newResource.extension.push({
                    url: CURRENT_RESOURCE_FORMAT_EXTENSION,
                    valueCode: 'application/fhir+json'
                });
            }
            else if ((_s = configResource === null || configResource === void 0 ? void 0 : configResource.extension) === null || _s === void 0 ? void 0 : _s.some(ext => ext.url === DEPRECATED_RESOURCE_FORMAT_EXTENSION)) {
                utils_1.logger.warn(`The extension ${DEPRECATED_RESOURCE_FORMAT_EXTENSION} has been deprecated. Update the configuration for ${(_u = (_t = configResource.reference) === null || _t === void 0 ? void 0 : _t.reference) !== null && _u !== void 0 ? _u : newResource.name} to use the current extension, ${CURRENT_RESOURCE_FORMAT_EXTENSION}.`);
            }
        }
        this.ig.definition.resource.push(newResource);
    }
    /**
     * Adds any user provided resource files to the ImplementationGuide JSON file.
     * This includes definitions in:
     * capabilities, extensions, models, operations, profiles, resources, vocabulary, examples
     * Based on: https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input
     *
     * NOTE: This only includes files nested in subfolders when specified in the path-resource
     * parameter, which is based on how the IG Publisher works.
     *
     * This function has similar operation to addResources, and both should be
     * analyzed when making changes to either.
     */
    addPredefinedResources() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
        // Similar code for loading custom resources exists in load.ts loadCustomResources()
        const pathEnds = [
            'capabilities',
            'extensions',
            'models',
            'operations',
            'profiles',
            'resources',
            'vocabulary',
            'examples'
        ];
        const predefinedResourcePaths = pathEnds.map(pathEnd => path_1.default.join(this.inputPath, 'input', pathEnd));
        const pathResourceDirectories = [];
        const pathResources = (_a = this.config.parameters) === null || _a === void 0 ? void 0 : _a.filter(parameter => parameter.value && parameter.code === 'path-resource').map(parameter => parameter.value);
        if (pathResources) {
            pathResources.forEach(directoryPath => {
                const fullPath = path_1.default.join(this.inputPath, ...directoryPath.split('/'));
                if ((0, fs_extra_1.existsSync)(fullPath)) {
                    pathResourceDirectories.push(fullPath);
                }
                else if (directoryPath.endsWith('/*') && (0, fs_extra_1.existsSync)(fullPath.slice(0, -2))) {
                    pathResourceDirectories.push(...(0, fs_extra_1.readdirSync)(fullPath.slice(0, -2), { withFileTypes: true, recursive: true })
                        .filter(file => file.isDirectory())
                        .map(dir => path_1.default.join(dir.path, dir.name)));
                }
            });
            if (pathResourceDirectories)
                predefinedResourcePaths.push(...pathResourceDirectories);
        }
        const deeplyNestedFiles = [];
        const configuredBinaryResources = ((_b = this.config.resources) !== null && _b !== void 0 ? _b : []).filter(resource => {
            var _a, _b, _c;
            return ((_b = (_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) === null || _b === void 0 ? void 0 : _b.startsWith('Binary/')) &&
                ((_c = resource.extension) === null || _c === void 0 ? void 0 : _c.some(e => IG_RESOURCE_FORMAT_EXTENSIONS.includes(e.url)));
        });
        for (const dirPath of predefinedResourcePaths) {
            if ((0, fs_extra_1.existsSync)(dirPath)) {
                const files = (0, utils_1.getFilesRecursive)(dirPath);
                for (const file of files) {
                    if (path_1.default.dirname(file) !== dirPath &&
                        !(pathResourceDirectories === null || pathResourceDirectories === void 0 ? void 0 : pathResourceDirectories.includes(path_1.default.dirname(file)))) {
                        if (!deeplyNestedFiles.includes(file)) {
                            deeplyNestedFiles.push(file);
                        }
                        continue;
                    }
                    const resourceJSON = this.fhirDefs.getPredefinedResource(file);
                    if (resourceJSON) {
                        // For predefined examples of Logical Models, the user must provide an entry in config
                        // that specifies the reference as Binary/[id], the extension that specifies the resource format,
                        // and the exampleCanonical that references the LogicalModel the resource is an example of.
                        // Note: the exampleCanonical should reference the resourceType because the resourceType should
                        // be the absolute URL, but we previously supported using the logical model's id as the example's
                        // resourceType, so support having an exampleCanonical in either form for now.
                        // In that case, we do not want to add our own entry for the predefined resource - we just
                        // want to use the resource entry from the sushi-config.yaml
                        // For predefined examples of Logical Models that do not have a resourceType or id,
                        // a Binary resource reference based on the file name can be used, based on Zulip:
                        // https://chat.fhir.org/#narrow/stream/215610-shorthand/topic/How.20do.20I.20get.20SUSHI.20to.20ignore.20a.20binary.20JSON.20logical.20instance.3F/near/407861211
                        const configuredBinaryReference = configuredBinaryResources.find(resource => {
                            var _a, _b;
                            return (((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) === `Binary/${resourceJSON.id}` &&
                                (resource.exampleCanonical ===
                                    `${this.config.canonical}/StructureDefinition/${resourceJSON.resourceType}` ||
                                    resource.exampleCanonical === resourceJSON.resourceType)) ||
                                ((_b = resource.reference) === null || _b === void 0 ? void 0 : _b.reference) === `Binary/${path_1.default.parse(file).name}`;
                        });
                        if (configuredBinaryReference) {
                            if ((_c = configuredBinaryReference.extension) === null || _c === void 0 ? void 0 : _c.some(ext => ext.url === DEPRECATED_RESOURCE_FORMAT_EXTENSION)) {
                                utils_1.logger.warn(`The extension ${DEPRECATED_RESOURCE_FORMAT_EXTENSION} has been deprecated. Update the configuration for ${(_e = (_d = configuredBinaryReference.reference) === null || _d === void 0 ? void 0 : _d.reference) !== null && _e !== void 0 ? _e : configuredBinaryReference.name} to use the current extension, ${CURRENT_RESOURCE_FORMAT_EXTENSION}.`);
                            }
                            continue;
                        }
                        if (resourceJSON.resourceType == null || resourceJSON.id == null) {
                            utils_1.logger.warn(`Resource at ${file} is missing ${resourceJSON.resourceType == null ? 'resourceType' : ''}${resourceJSON.resourceType == null && resourceJSON.id == null ? ' and ' : ''}${resourceJSON.id == null ? 'id' : ''}.`);
                            continue;
                        }
                        const referenceKey = `${resourceJSON.resourceType}/${resourceJSON.id}`;
                        const newResource = {
                            reference: {
                                reference: referenceKey
                            }
                        };
                        const configResource = ((_f = this.config.resources) !== null && _f !== void 0 ? _f : []).find(resource => { var _a; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) == referenceKey; });
                        if ((configResource === null || configResource === void 0 ? void 0 : configResource.omit) !== true) {
                            const existingIndex = this.ig.definition.resource.findIndex(r => r.reference.reference === referenceKey);
                            // If the user has provided a resource, it should override the generated resource.
                            // This can be helpful for working around cases where the generated resource has some incorrect values.
                            const existingResource = existingIndex >= 0 ? this.ig.definition.resource[existingIndex] : null;
                            const existingIsExample = (existingResource === null || existingResource === void 0 ? void 0 : existingResource.exampleBoolean) || (existingResource === null || existingResource === void 0 ? void 0 : existingResource.exampleCanonical);
                            const existingName = existingIsExample ? existingResource.name : null;
                            const existingDescription = existingIsExample ? existingResource.description : null;
                            const metaExtensionDescription = this.getMetaExtensionDescription(resourceJSON);
                            const metaExtensionName = this.getMetaExtensionName(resourceJSON);
                            // On some resources (Patient for example) title, name, and description can be objects, avoid using them when this is true
                            newResource.description =
                                (_j = (_h = (_g = configResource === null || configResource === void 0 ? void 0 : configResource.description) !== null && _g !== void 0 ? _g : metaExtensionDescription) !== null && _h !== void 0 ? _h : existingDescription) !== null && _j !== void 0 ? _j : (0, utils_1.stringOrElse)(resourceJSON.description);
                            if (configResource === null || configResource === void 0 ? void 0 : configResource.fhirVersion) {
                                newResource.fhirVersion = configResource.fhirVersion;
                            }
                            if (configResource === null || configResource === void 0 ? void 0 : configResource.groupingId) {
                                newResource.groupingId = configResource.groupingId;
                                this.addGroup(newResource.groupingId);
                            }
                            if (path_1.default.basename(dirPath) === 'examples') {
                                newResource.name =
                                    (_p = (_o = (_m = (_l = (_k = configResource === null || configResource === void 0 ? void 0 : configResource.name) !== null && _k !== void 0 ? _k : metaExtensionName) !== null && _l !== void 0 ? _l : existingName) !== null && _m !== void 0 ? _m : (0, utils_1.stringOrElse)(resourceJSON.title)) !== null && _o !== void 0 ? _o : (0, utils_1.stringOrElse)(resourceJSON.name)) !== null && _p !== void 0 ? _p : resourceJSON.id;
                                newResource._linkRef = resourceJSON.id;
                                // set exampleCanonical or exampleBoolean, preferring configured values
                                if (configResource === null || configResource === void 0 ? void 0 : configResource.exampleCanonical) {
                                    newResource.exampleCanonical = configResource.exampleCanonical;
                                }
                                else if (typeof (configResource === null || configResource === void 0 ? void 0 : configResource.exampleBoolean) === 'boolean') {
                                    newResource.exampleBoolean = configResource.exampleBoolean;
                                }
                                else {
                                    const exampleUrl = (_r = (_q = resourceJSON.meta) === null || _q === void 0 ? void 0 : _q.profile) === null || _r === void 0 ? void 0 : _r.find(url => {
                                        var _a, _b;
                                        const [baseUrl, version] = url.split('|', 2);
                                        const availableProfile = (_a = this.pkg.fish(baseUrl, utils_1.Type.Profile)) !== null && _a !== void 0 ? _a : this.fhirDefs.fishForFHIR(baseUrl, utils_1.Type.Profile);
                                        return (availableProfile != null &&
                                            (version == null ||
                                                version === ((_b = availableProfile.version) !== null && _b !== void 0 ? _b : this.config.version)));
                                    });
                                    if (exampleUrl) {
                                        newResource.exampleCanonical = exampleUrl.split('|', 1)[0];
                                    }
                                    else {
                                        newResource.exampleBoolean = true;
                                    }
                                }
                            }
                            else {
                                if (configResource === null || configResource === void 0 ? void 0 : configResource.exampleCanonical) {
                                    newResource.exampleCanonical = configResource.exampleCanonical;
                                }
                                else if (typeof (configResource === null || configResource === void 0 ? void 0 : configResource.exampleBoolean) === 'boolean') {
                                    newResource.exampleBoolean = configResource.exampleBoolean;
                                }
                                else {
                                    newResource.exampleBoolean = false;
                                }
                                newResource.name =
                                    (_w = (_v = (_u = (_t = (_s = configResource === null || configResource === void 0 ? void 0 : configResource.name) !== null && _s !== void 0 ? _s : metaExtensionName) !== null && _t !== void 0 ? _t : existingResource === null || existingResource === void 0 ? void 0 : existingResource.name) !== null && _u !== void 0 ? _u : (0, utils_1.stringOrElse)(resourceJSON.title)) !== null && _v !== void 0 ? _v : (0, utils_1.stringOrElse)(resourceJSON.name)) !== null && _w !== void 0 ? _w : resourceJSON.id;
                                newResource._linkRef = (_x = (0, utils_1.stringOrElse)(resourceJSON.name)) !== null && _x !== void 0 ? _x : resourceJSON.id;
                            }
                            if ((_y = configResource === null || configResource === void 0 ? void 0 : configResource.extension) === null || _y === void 0 ? void 0 : _y.length) {
                                newResource.extension = configResource.extension;
                            }
                            if (existingIndex >= 0) {
                                this.ig.definition.resource[existingIndex] = newResource;
                            }
                            else {
                                this.ig.definition.resource.push(newResource);
                            }
                        }
                    }
                }
            }
        }
        if (deeplyNestedFiles.length) {
            utils_1.logger.warn('The following files were not added to the ImplementationGuide JSON because they are not in one of the supported ' +
                'input folders or are nested too deep in one of those folders. While SUSHI automatically supports resources in ' +
                'sub-folders, the IG Publisher does not, unless the folder is explicitly added via the template or an IG parameter. ' +
                'To fix any issues you may encounter due to this, adjust your IG parameters or template accordingly or move these ' +
                `files so they are directly under a supported input folder (e.g., input/resources, input/profiles, etc.):\n  - ${deeplyNestedFiles.join('\n  - ')}`);
        }
    }
    /**
     * Adds resources that are present only in the configuration.
     * If a configured resource is already in the implementation guide,
     * there is no need to add it again.
     */
    addConfiguredResources() {
        var _a;
        for (const resource of (_a = this.config.resources) !== null && _a !== void 0 ? _a : []) {
            if (!resource.omit &&
                this.ig.definition.resource.findIndex(r => { var _a, _b; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) === ((_b = r.reference) === null || _b === void 0 ? void 0 : _b.reference); }) === -1) {
                this.ig.definition.resource.push(resource);
            }
        }
    }
    /**
     * Sort the IG resources based on the configuration.
     * If all resources are listed in the configuration "resources" section, use that order.
     * Otherwise, if all resources are listed in the configuration "groups" section, use that order.
     * Otherwise, use the name attribute that was created when the resource was added to the IG.
     * A configured resource may lack a name, so use reference.reference as backup.
     */
    sortResources() {
        if (!(this.trySortResourcesByConfig() || this.trySortResourcesByGroup())) {
            this.ig.definition.resource = (0, lodash_1.sortBy)(this.ig.definition.resource, resource => {
                var _a, _b, _c;
                return (_c = ((_a = resource.name) !== null && _a !== void 0 ? _a : (_b = resource.reference) === null || _b === void 0 ? void 0 : _b.reference)) === null || _c === void 0 ? void 0 : _c.toLocaleUpperCase();
            });
        }
    }
    /**
     * Try to sort resources based on the order in the resource configuration.
     * If this sort is possible, perform it, and return true.
     * Otherwise, return false.
     */
    trySortResourcesByConfig() {
        if (this.config.resources == null) {
            return false;
        }
        const resourceIndices = new Map();
        const allInConfig = this.ig.definition.resource.every(igResource => {
            var _a;
            if (((_a = igResource.reference) === null || _a === void 0 ? void 0 : _a.reference) == null) {
                return false;
            }
            const configIndex = this.config.resources.findIndex(configResource => { var _a; return ((_a = configResource.reference) === null || _a === void 0 ? void 0 : _a.reference) === igResource.reference.reference; });
            if (configIndex >= 0) {
                resourceIndices.set(igResource.reference.reference, configIndex);
                return true;
            }
            else {
                return false;
            }
        });
        if (allInConfig) {
            this.ig.definition.resource = (0, lodash_1.sortBy)(this.ig.definition.resource, igResource => resourceIndices.get(igResource.reference.reference));
        }
        return allInConfig;
    }
    /**
     * Try to sort resources based on the order in the group configuration.
     * If this sort is possible, perform it, and return true.
     * Otherwise, return false.
     */
    trySortResourcesByGroup() {
        if (this.config.groups == null) {
            return false;
        }
        const resourceIndices = new Map();
        const allInGroups = this.ig.definition.resource.every(igResource => {
            var _a;
            if (((_a = igResource.reference) === null || _a === void 0 ? void 0 : _a.reference) == null) {
                return false;
            }
            let resourceIndex = -1;
            const groupIndex = this.config.groups.findIndex(group => {
                var _a, _b;
                resourceIndex = (_b = (_a = group.resources) === null || _a === void 0 ? void 0 : _a.indexOf(igResource.reference.reference)) !== null && _b !== void 0 ? _b : -1;
                if (resourceIndex >= 0) {
                    return true;
                }
                else {
                    return false;
                }
            });
            if (groupIndex >= 0) {
                resourceIndices.set(igResource.reference.reference, { groupIndex, resourceIndex });
                return true;
            }
            else {
                return false;
            }
        });
        if (allInGroups) {
            this.ig.definition.resource = (0, lodash_1.sortBy)(this.ig.definition.resource, igResource => resourceIndices.get(igResource.reference.reference).groupIndex, igResource => resourceIndices.get(igResource.reference.reference).resourceIndex);
        }
        return allInGroups;
    }
    /**
     * Adds or updates a group in the implementation guide.
     *
     * @param {string} id - unique identifier for group
     * @param {string} name - name of the group
     * @param {string} description - optional description of the group
     */
    addGroup(id, name, description) {
        if (!this.ig.definition.grouping) {
            this.ig.definition.grouping = [];
        }
        // Initially `name` and `id` were derived from the same parameter. This allows
        // the function to still work with just a single parameter.
        if (name === undefined) {
            name = id;
        }
        const existingGroup = this.ig.definition.grouping.find(group => group.id === id);
        if (existingGroup) {
            existingGroup.name = name;
            if (description) {
                existingGroup.description = description;
            }
        }
        else {
            this.ig.definition.grouping.push({
                id: id,
                name: name,
                ...(description && { description })
            });
        }
    }
    /**
     * Adds groups listed in the configuration to the implementation guide.
     * Updates the groupingId on resources listed as members of a group.
     * Shows errors if a listed resource does not exist, or if there are conflicting
     * configured values for groupingId.
     * Shows a warning if a groupingId is given in resource configuration and
     * that resource is listed in the group with that groupingId.
     */
    addConfiguredGroups() {
        var _a;
        for (const group of (_a = this.config.groups) !== null && _a !== void 0 ? _a : []) {
            this.addGroup(group.id, group.name, group.description);
            if (group.resources) {
                for (const resourceKey of group.resources) {
                    const existingResource = this.ig.definition.resource.find(resource => { var _a; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) === resourceKey; });
                    if (!existingResource) {
                        utils_1.logger.error(`Group ${group.id} configured with nonexistent resource ${resourceKey}`);
                    }
                    else {
                        if (existingResource.groupingId) {
                            if (existingResource.groupingId === group.id) {
                                utils_1.logger.warn(`Resource ${resourceKey} is listed as a member of group ${group.id}, and does not need a groupingId.`);
                            }
                            else {
                                utils_1.logger.error(`Resource ${resourceKey} configured with groupingId ${existingResource.groupingId}, but listed as member of group ${group.id}.`);
                            }
                        }
                        existingResource.groupingId = group.id;
                    }
                }
            }
        }
    }
    getMetaExtensionDescription(resource) {
        var _a, _b, _c;
        const description = (_c = (_b = (_a = resource.meta) === null || _a === void 0 ? void 0 : _a.extension) === null || _b === void 0 ? void 0 : _b.find(e => e.url === 'http://hl7.org/fhir/StructureDefinition/instance-description')) === null || _c === void 0 ? void 0 : _c.valueMarkdown;
        if (!common_1.CONFORMANCE_AND_TERMINOLOGY_RESOURCES.has(resource.resourceType)) {
            return description;
        }
    }
    getMetaExtensionName(resource) {
        var _a, _b, _c;
        const name = (_c = (_b = (_a = resource.meta) === null || _a === void 0 ? void 0 : _a.extension) === null || _b === void 0 ? void 0 : _b.find(e => e.url === 'http://hl7.org/fhir/StructureDefinition/instance-name')) === null || _c === void 0 ? void 0 : _c.valueString;
        if (!common_1.CONFORMANCE_AND_TERMINOLOGY_RESOURCES.has(resource.resourceType)) {
            return name;
        }
    }
    normalizeResourceReference(resource, useRelative) {
        let ref;
        // If it doesn't contain / or :, then it's not a relative URL or canonical yet
        if (!/[/:]/.test(resource)) {
            let def = this.pkg.fishForFHIR(resource);
            if (def == null) {
                def = this.fhirDefs.fishForFHIR(resource);
            }
            if (useRelative && (def === null || def === void 0 ? void 0 : def.resourceType) && (def === null || def === void 0 ? void 0 : def.id)) {
                ref = `${def.resourceType}/${def.id}`;
            }
            else if (def === null || def === void 0 ? void 0 : def.url) {
                ref = def.url;
            }
            if (ref == null) {
                utils_1.logger.warn(`Cannot determine ${useRelative ? 'relative URL' : 'canonical'} for "${resource}" referenced in sushi-config.yaml.`);
            }
        }
        // Fallback to resource if we didn't assign a fullRef
        return ref !== null && ref !== void 0 ? ref : resource;
    }
    /**
     * Writes the in-memory ImplementationGuide JSON to the IG output folder.
     *
     * @param igPath {string} - the path where the IG is exported to
     */
    addImplementationGuide(igPath) {
        const igJSONFolder = path_1.default.join('fsh-generated', 'resources');
        const igJsonPath = path_1.default.join(igPath, igJSONFolder, (0, sanitize_filename_1.default)(`ImplementationGuide-${this.ig.id}.json`, { replacement: '-' }));
        (0, fs_extra_1.outputJSONSync)(igJsonPath, this.ig, { spaces: 2 });
        utils_1.logger.info(`Generated ImplementationGuide-${this.ig.id}.json`);
    }
    /**
     * Logs an error if the no longer supported "template" property is used in sushi-config.yaml.
     */
    checkIgIni() {
        const inputIniPath = path_1.default.join(this.inputPath, 'ig.ini');
        if (this.config.template != null) {
            if ((0, fs_extra_1.existsSync)(inputIniPath)) {
                const filePathString = path_1.default.join(path_1.default.basename(this.inputPath), 'ig.ini');
                const message = `Found both a "template" property in ${this.configName} and an ig.ini file at ${filePathString}. ` +
                    `The "template" property in ${this.configName} is no longer supported and will be ignored. The existing ` +
                    `${filePathString} file will be used instead. To resolve this error, remove the "template" property in ` +
                    `${this.configName} and manage the ig.ini file directly.`;
                utils_1.logger.error(message, { file: inputIniPath });
            }
            else {
                const message = `The "template" property in ${this.configName} is no longer supported. Please remove the "template" ` +
                    `property in ${this.configName} and manage the ig.ini file directly.` +
                    ` To resolve this error, create an ig.ini file in your project folder with the following contents:\n\n${this.generateIgIniString()}`;
                utils_1.logger.error(message);
            }
        }
        else if ((0, fs_extra_1.existsSync)(inputIniPath)) {
            this.processIgIni(inputIniPath);
        }
        else {
            // do nothing -- no template in config, no ig.ini provided
        }
    }
    /**
     * Generates the contents of an ig.ini file using the information in the configuration.
     *
     * @returns {string} contents of ig.ini file
     */
    generateIgIniString() {
        // Create an ig.ini object from the configuration
        const iniObj = {};
        const igFolder = 'fsh-generated/resources';
        iniObj.ig = `${igFolder}/ImplementationGuide-${this.config.id}.json`;
        iniObj.template = this.config.template;
        let outputIniContents = ini_1.default.encode(iniObj, { section: 'IG', whitespace: true });
        // The encoder escapes '#' but FHIR doesn't like that, so if `#` is escaped in the template, then unescape it.
        outputIniContents = outputIniContents.replace(/^template\s*=\s*.*?(\\#.+)?$/m, ($0, $1) => $1 ? $0.replace($1, $1.slice(1)) : $0);
        return outputIniContents;
    }
    /**
     * Process an existing ig.ini.
     * When one of the required properties is missing, an error is logged but the file is not changed.
     *
     * @param inputIniPath {string} - the path to the input ig.ini file
     */
    processIgIni(inputIniPath) {
        let inputIniContents = (0, fs_extra_1.readFileSync)(inputIniPath, 'utf8');
        // FHIR allows templates to have versions identified using #.  E.g.,
        //   template = hl7.fhir.template#0.1.0
        // The ini library, however, treats # as a comment unless it is escaped.  So if it exists, we need to escape it.
        inputIniContents = inputIniContents.replace(/^\s*template\s*=\s*[^#]*(#.+)?$/m, ($0, $1) => $1 ? $0.replace($1, `\\${$1}`) : $0);
        const inputIni = ini_1.default.parse(inputIniContents);
        if (Object.keys(inputIni).length > 1 || inputIni.IG == null) {
            utils_1.logger.error('ig.ini file must contain an [IG] section with no other sections', {
                file: inputIniPath
            });
        }
        const filePathString = path_1.default.join(path_1.default.basename(this.inputPath), 'ig.ini');
        if (inputIni.IG) {
            const igValue = `fsh-generated/resources/ImplementationGuide-${this.config.id}.json`;
            if (inputIni.IG.ig == null) {
                inputIni.IG.ig = igValue;
                utils_1.logger.error('The ig.ini file must have an "ig" property pointing to the IG file. Please add the following line ' +
                    `to ${filePathString}:\n'` +
                    `ig = ${igValue}`, {
                    file: inputIniPath
                });
            }
            else if (!new RegExp(`(.*[/\\\\])?fsh-generated[/\\\\]resources[/\\\\]ImplementationGuide-${(0, lodash_1.escapeRegExp)(this.config.id)}\.json$`).test(inputIni.IG.ig)) {
                utils_1.logger.warn('\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' +
                    'Your ig.ini file does NOT point to the Implementation Guide resource that SUSHI generates. As a\n' +
                    'result, the IG Publisher will IGNORE the SUSHI-generated ImplementationGuide resource. To fix this,\n' +
                    'please do one of the following:\n' +
                    `- Update your ig.ini file with \'ig = ${igValue}\' (recommended), or\n` +
                    "- Update your sushi-config.yaml file with 'FSHOnly: true' to tell SUSHI NOT to generate the IG resource\n\n");
            }
            if (inputIni.IG.template == null) {
                const templateValue = 'fhir.base.template';
                inputIni.IG.template = templateValue;
                utils_1.logger.error(`The ig.ini file must have a "template" property. Please update ${filePathString} to include ` +
                    'your desired template value. Consider adding the following line:\n' +
                    `template = ${templateValue}`, {
                    file: inputIniPath
                });
            }
            const deprecatedProps = [
                'copyrightyear',
                'license',
                'version',
                'ballotstatus',
                'fhirspec',
                'excludexml',
                'excludejson',
                'excludettl',
                'excludeMaps'
            ].filter(p => inputIni.IG[p] != null);
            if (deprecatedProps.length > 0) {
                const propList = deprecatedProps.join(', ');
                utils_1.logger.warn(`Your ${filePathString} file contains the following unsupported properties: ${propList}. ` +
                    'These are no longer supported in ig.ini and should be removed.  See the following link for details: ' +
                    'https://github.com/HL7/ig-template-base/releases/tag/0.0.2', {
                    file: inputIniPath
                });
            }
        }
    }
    /**
     * Logs an error if the no longer supported "history" property is used in sushi-config.yaml
     */
    checkPackageList() {
        if (this.config.history) {
            utils_1.logger.error('Detected "history" property in configuration. The use of "history" is no longer supported. Please remove the property and provide a package-list.json directly. ' +
                'The package-list.json corresponding to the "history" property in the configuration is:\n\n' +
                JSON.stringify(this.config.history, null, 2) +
                '\n');
        }
    }
    // Supports necessary updates for R5 IGs.
    // SUSHI only supports R4 or later, and as of now, we will just target R5.
    updateForR5() {
        var _a;
        // Update IG.definition.resource
        this.ig.definition.resource.forEach(resource => {
            var _a;
            // Use IG.definition.resource.isExample
            if (resource.exampleBoolean || resource.exampleCanonical) {
                resource.isExample = true;
                if (resource.exampleCanonical) {
                    resource.profile = [resource.exampleCanonical];
                }
                delete resource.exampleBoolean;
                delete resource.exampleCanonical;
            }
            else if (resource.exampleBoolean === false) {
                resource.isExample = false;
                delete resource.exampleBoolean;
            }
            // Assign IG.definition.resource.profile if provided
            const configEntry = (_a = this.config.resources) === null || _a === void 0 ? void 0 : _a.find(r => { var _a, _b; return ((_a = r.reference) === null || _a === void 0 ? void 0 : _a.reference) === ((_b = resource.reference) === null || _b === void 0 ? void 0 : _b.reference); });
            if ((configEntry === null || configEntry === void 0 ? void 0 : configEntry.profile) != null) {
                resource.profile = configEntry.profile;
            }
            // Assign IG.definition.resource.isExample if provided
            if ((configEntry === null || configEntry === void 0 ? void 0 : configEntry.isExample) != null) {
                resource.isExample = configEntry.isExample;
            }
        });
        // Update IG.definition.page.name
        this.ig.definition.page.name = this.ig.definition.page.nameUrl;
        delete this.ig.definition.page.nameUrl;
        this.ig.definition.page.page.forEach(page => {
            this.updatePageNameForR5(page, this.config.pages);
        });
        // Add new IG.definition.page.source[x] property
        // this.ig.definition.page is the toc.html page we create
        // All configured pages are at the next level, so start at that level
        this.ig.definition.page.page.forEach(page => {
            this.addPageSourceForR5(page, this.config.pages);
        });
        // Default IG.definition.page.source[x] on every page if not set
        this.defaultPageSourceUrlForR5(this.ig.definition.page);
        // Update IG.definition.parameter
        this.ig.definition.parameter.forEach(parameter => {
            var _a, _b;
            const guideParameterCodes = (_b = (_a = this.fhirDefs
                .fishForFHIR('http://hl7.org/fhir/guide-parameter-code', utils_1.Type.CodeSystem)) === null || _a === void 0 ? void 0 : _a.concept.map((concept) => concept.code)) !== null && _b !== void 0 ? _b : [];
            const code = parameter.code;
            parameter.code = { code };
            const parsedCode = (0, import_1.parseCodeLexeme)(code);
            if (parsedCode.code && parsedCode.system) {
                // If we can parse the code and we have a system and a code provided, we should use that.
                parameter.code.code = parsedCode.code;
                parameter.code.system = parsedCode.system;
            }
            else if (guideParameterCodes.some(c => c === code)) {
                // Otherwise, only a code was provided, so we check if it is in the bound VS
                parameter.code.system = 'http://hl7.org/fhir/guide-parameter-code';
            }
            else {
                // If the code is not in the VS in the R5 IG resource, we default the system
                // based on https://chat.fhir.org/#narrow/stream/179252-IG-creation/topic/Unknown.20FHIRVersion.20code.20'5.2E0.2E0-ballot'/near/298697304
                parameter.code.system = 'http://hl7.org/fhir/tools/CodeSystem/ig-parameters';
            }
        });
        // Add new copyrightLabel property
        if (this.config.copyrightLabel) {
            this.ig.copyrightLabel = this.config.copyrightLabel;
        }
        // Add new versionAlgorithm property
        if (this.config.versionAlgorithmString) {
            this.ig.versionAlgorithmString = this.config.versionAlgorithmString;
        }
        else if (this.config.versionAlgorithmCoding) {
            this.ig.versionAlgorithmCoding = this.config.versionAlgorithmCoding;
        }
        // Add new dependsOn.reason property
        (_a = this.ig.dependsOn) === null || _a === void 0 ? void 0 : _a.forEach(dependency => {
            var _a;
            const configDependency = (_a = this.config.dependencies) === null || _a === void 0 ? void 0 : _a.find(d => d.packageId === dependency.packageId);
            if (configDependency.reason) {
                dependency.reason = configDependency.reason;
            }
        });
    }
    // If an R4 IG uses any new properties from R5, they should be included as extensions.
    // Converting between FHIR versions is documented here: http://hl7.org/fhir/2022Sep/versions.html#extensions
    // If an R4 IG uses any R5 properties that have an equivalent R4 property, use the R4 property.
    translateR5PropertiesToR4() {
        var _a, _b, _c, _d;
        this.ig.definition.resource.forEach(resource => {
            var _a, _b, _c, _d;
            // Assign IG.definition.resource.profile to exampleCanonical if it is not set, otherwise add an extension
            const configEntry = (_a = this.config.resources) === null || _a === void 0 ? void 0 : _a.find(r => { var _a, _b; return ((_a = r.reference) === null || _a === void 0 ? void 0 : _a.reference) === ((_b = resource.reference) === null || _b === void 0 ? void 0 : _b.reference); });
            if (resource.exampleCanonical == null && ((_b = configEntry === null || configEntry === void 0 ? void 0 : configEntry.profile) === null || _b === void 0 ? void 0 : _b.length)) {
                resource.exampleCanonical = configEntry.profile[0];
                delete resource.exampleBoolean;
            }
            if (resource.exampleCanonical != null &&
                ((_c = configEntry === null || configEntry === void 0 ? void 0 : configEntry.profile) === null || _c === void 0 ? void 0 : _c.some(p => p !== resource.exampleCanonical))) {
                resource.extension = ((_d = resource.extension) !== null && _d !== void 0 ? _d : []).concat({
                    url: 'http://hl7.org/fhir/5.0/StructureDefinition/extension-ImplementationGuide.definition.resource.profile',
                    valueCanonical: configEntry.profile
                });
            }
            // Assign isExample to exampleBoolean if it is set and neither exampleCanonical or exampleBoolean are already set.
            if ((configEntry === null || configEntry === void 0 ? void 0 : configEntry.isExample) != null && resource.exampleCanonical == null) {
                resource.exampleBoolean = configEntry.isExample;
            }
        });
        // Add new IG.definition.page.source[x] property to an extension if it is provided. No need to set a default like R5 needs to.
        // this.ig.definition.page is the toc.html page we create
        // All configured pages are at the next level, so start at that level
        this.ig.definition.page.page.forEach(page => {
            this.addNameUrlAndPageSourceExtensionForR4(page, this.config.pages);
        });
        // Update IG.definition.parameter.code
        this.ig.definition.parameter.forEach(parameter => {
            var _a;
            const code = parameter.code;
            const parsedCode = (0, import_1.parseCodeLexeme)(code);
            // If the code is parsed, use just the code portion
            if (parsedCode.code) {
                parameter.code = parsedCode.code;
            }
            else {
                parameter.code = code;
            }
            // If the system is parsed, add an extension for the full Coding
            if (parsedCode.system) {
                parameter.extension = ((_a = parameter.extension) !== null && _a !== void 0 ? _a : []).concat({
                    url: 'http://hl7.org/fhir/5.0/StructureDefinition/extension-ImplementationGuide.definition.resource.parameter.code',
                    valueCoding: {
                        code: parsedCode.code,
                        system: parsedCode.system
                    }
                });
            }
        });
        // Add new copyrightLabel property to an extension if provided
        if (this.config.copyrightLabel) {
            this.ig.extension = ((_a = this.ig.extension) !== null && _a !== void 0 ? _a : []).concat({
                url: 'http://hl7.org/fhir/5.0/StructureDefinition/extension-ImplementationGuide.copyrightLabel',
                valueString: this.config.copyrightLabel
            });
        }
        // Add new versionAlgorithm property to an extension if provided
        if (this.config.versionAlgorithmString) {
            this.ig.extension = ((_b = this.ig.extension) !== null && _b !== void 0 ? _b : []).concat({
                url: 'http://hl7.org/fhir/5.0/StructureDefinition/extension-ImplementationGuide.versionAlgorithm',
                valueString: this.config.versionAlgorithmString
            });
        }
        else if (this.config.versionAlgorithmCoding) {
            this.ig.extension = ((_c = this.ig.extension) !== null && _c !== void 0 ? _c : []).concat({
                url: 'http://hl7.org/fhir/5.0/StructureDefinition/extension-ImplementationGuide.versionAlgorithm',
                valueCoding: this.config.versionAlgorithmCoding
            });
        }
        // Add new dependsOn.reason property
        (_d = this.ig.dependsOn) === null || _d === void 0 ? void 0 : _d.forEach(dependency => {
            var _a, _b;
            const configDependency = (_a = this.config.dependencies) === null || _a === void 0 ? void 0 : _a.find(d => d.packageId === dependency.packageId);
            if (configDependency.reason) {
                dependency.extension = ((_b = dependency.extension) !== null && _b !== void 0 ? _b : []).concat({
                    url: 'http://hl7.org/fhir/5.0/StructureDefinition/extension-ImplementationGuide.dependsOn.reason',
                    valueMarkdown: configDependency.reason
                });
            }
        });
    }
    updatePageNameForR5(page, configPages) {
        var _a, _b, _c;
        const configPage = configPages === null || configPages === void 0 ? void 0 : configPages.find(p => (p.nameUrl || p.name).replace(/\.[^.]+$/, '') === page.nameUrl.replace(/\.[^.]+$/, ''));
        if (configPage && configPage.name) {
            page.name = configPage.name;
            // Regenerate the title based on the updated name
            page.title =
                (_a = configPage.title) !== null && _a !== void 0 ? _a : (0, title_case_1.titleCase)((0, lodash_1.words)(page.name.replace(/\.[^.]+$/, '')).join(' '));
            // The default of sourceUrl will be the old nameUrl (for now).
            // If sourceUrl is included in the configuration, this value will be
            // overwritten in addPageSourceForR5, which is called after this function in updateForR5.
            page.sourceUrl = page.nameUrl;
            delete page.nameUrl;
        }
        else if (page.nameUrl) {
            page.name = page.nameUrl;
            delete page.nameUrl;
        }
        if ((_b = page.page) === null || _b === void 0 ? void 0 : _b.length) {
            for (const subPage of page === null || page === void 0 ? void 0 : page.page) {
                this.updatePageNameForR5(subPage, (_c = configPage === null || configPage === void 0 ? void 0 : configPage.page) !== null && _c !== void 0 ? _c : []);
            }
        }
    }
    addPageSourceForR5(page, configPages) {
        var _a;
        const configPage = configPages === null || configPages === void 0 ? void 0 : configPages.find(p => (p.nameUrl || p.name).replace(/\.[^.]+$/, '') === page.name.replace(/\.[^.]+$/, ''));
        if (configPage) {
            if (configPage.sourceUrl) {
                page.sourceUrl = configPage.sourceUrl;
            }
            else if (configPage.sourceString) {
                page.sourceString = configPage.sourceString;
            }
            else if (configPage.sourceMarkdown) {
                page.sourceMarkdown = configPage.sourceMarkdown;
            }
            if ((_a = page.page) === null || _a === void 0 ? void 0 : _a.length) {
                for (const subPage of page === null || page === void 0 ? void 0 : page.page) {
                    this.addPageSourceForR5(subPage, configPage.page);
                }
            }
        }
    }
    defaultPageSourceUrlForR5(page) {
        var _a;
        if (page.sourceUrl == null && page.sourceString == null && page.sourceMarkdown == null) {
            page.sourceUrl = page.name;
        }
        if ((_a = page.page) === null || _a === void 0 ? void 0 : _a.length) {
            for (const subPage of page === null || page === void 0 ? void 0 : page.page) {
                this.defaultPageSourceUrlForR5(subPage);
            }
        }
    }
    // Add an extension for the R5 property IG.definition.page.source[x] if provided in configuration
    addNameUrlAndPageSourceExtensionForR4(page, configPages) {
        var _a, _b, _c, _d, _e;
        const sourceExtensionUrl = 'http://hl7.org/fhir/5.0/StructureDefinition/extension-ImplementationGuide.definition.page.source';
        const nameExtensionUrl = 'http://hl7.org/fhir/5.0/StructureDefinition/extension-ImplementationGuide.definition.page.name';
        // Find the corresponding configuration page
        // Configuration might use name or nameUrl and will have a filetype at the end that we want to ignore
        const configPage = configPages === null || configPages === void 0 ? void 0 : configPages.find(p => (p.nameUrl || p.name).replace(/\.[^.]+$/, '') === page.nameUrl.replace(/\.[^.]+$/, ''));
        if (configPage) {
            // If nameUrl and name do not match, add the name value to an extension
            if (configPage.name && configPage.nameUrl !== configPage.name) {
                page.extension = ((_a = page.extension) !== null && _a !== void 0 ? _a : []).concat({
                    url: nameExtensionUrl,
                    valueUrl: configPage.name
                });
            }
            if (configPage.sourceUrl) {
                // If nameUrl and sourceUrl do not match, add the sourceUrl value to an extension
                if (configPage.nameUrl !== configPage.sourceUrl) {
                    page.extension = ((_b = page.extension) !== null && _b !== void 0 ? _b : []).concat({
                        url: sourceExtensionUrl,
                        valueUrl: configPage.sourceUrl
                    });
                }
            }
            else if (configPage.sourceString) {
                page.extension = ((_c = page.extension) !== null && _c !== void 0 ? _c : []).concat({
                    url: sourceExtensionUrl,
                    valueString: configPage.sourceString
                });
            }
            else if (configPage.sourceMarkdown) {
                page.extension = ((_d = page.extension) !== null && _d !== void 0 ? _d : []).concat({
                    url: sourceExtensionUrl,
                    valueMarkdown: configPage.sourceMarkdown
                });
            }
            if ((_e = page.page) === null || _e === void 0 ? void 0 : _e.length) {
                for (const subPage of page === null || page === void 0 ? void 0 : page.page) {
                    this.addNameUrlAndPageSourceExtensionForR4(subPage, configPage.page);
                }
            }
        }
    }
}
exports.IGExporter = IGExporter;
/**
 * Creates a block of comments indicating that a file is generated and should not be directly edited,
 * allowing for the block comment delimiters to be passed in as well as any extra text to include.
 *
 * @param blockPrefix {string} - the comment prefix to use at the start of the block (e.g., <!-- {% comment %})
 * @param blockPostfix {string} - the comment postfix to use at the end of the block (e.g., {% endcomment %} -->)
 * @param extra {List<string>} - an array of strings, each of which is a line to include in the comment after the
 *   standard warning text
 * @param blankLineAfter {boolean} - whether or not to put a blank line after the block of comments
 * @returns {string} representing the formatted comments
 */
function warningBlock(blockPrefix = '', blockPostfix = '', extra = [], blankLineAfter = true) {
    const a = [blockPrefix, ...warningTextArray('', extra), blockPostfix, ''];
    if (blankLineAfter) {
        a.push('');
    }
    return a.join(os_1.EOL);
}
/**
 * Creates a set of comments as an array of strings, each representing a line in the comments.
 * These comments indicate that a file is generated and should not be directly edited, and this function
 * allows for the comment delimiters to be passed in as well as any extra text to include.
 *
 * @param prefix {string} - the comment prefix to use at the start of each line (e.g., <!--)
 * @param extra {List<string>} - an array of strings, each of which is a line to include in the comment after the
 *   standard warning text
 */
function warningTextArray(prefix, extra = []) {
    const msgLen = Math.max(85, ...extra.map(e => e.length));
    const a = [];
    const msg = (text = '', center = false) => {
        const fn = center ? lodash_1.pad : lodash_1.padEnd;
        a.push(`${prefix}* ${fn(text, msgLen)} *`);
    };
    a.push(`${prefix}${(0, lodash_1.repeat)('*', msgLen + 4)}`);
    msg('WARNING: DO NOT EDIT THIS FILE', true);
    msg();
    msg('This file is generated by SUSHI. Any edits you make to this file will be overwritten.');
    if (extra && extra.length > 0) {
        msg();
        extra.forEach(m => msg(m));
    }
    a.push(`${prefix}${(0, lodash_1.repeat)('*', msgLen + 4)}`);
    return a;
}
//# sourceMappingURL=IGExporter.js.map