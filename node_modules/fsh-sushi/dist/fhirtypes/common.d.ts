import { StructureDefinition, PathPart, ElementDefinition, InstanceDefinition, ValueSet, CodeSystem, CodeSystemConcept } from '.';
import { AssignmentRule, CaretValueRule } from '../fshtypes/rules';
import { Instance, Logical, Profile, Extension, RuleSet, FshValueSet, FshCodeSystem, Mapping, Resource, FshEntity, Invariant } from '../fshtypes';
import { FSHTank } from '../import';
import { Fishable } from '../utils/Fishable';
import { InstanceExporter } from '../export';
import { MismatchedTypeError } from '../errors';
export declare const CONFORMANCE_AND_TERMINOLOGY_RESOURCES: Set<string>;
export declare const TYPE_CHARACTERISTICS_EXTENSION = "http://hl7.org/fhir/StructureDefinition/structuredefinition-type-characteristics";
export declare const TYPE_CHARACTERISTICS_CODE = "http://hl7.org/fhir/type-characteristics-code";
export declare const LOGICAL_TARGET_EXTENSION = "http://hl7.org/fhir/tools/StructureDefinition/logical-target";
export declare const IMPOSE_PROFILE_EXTENSION = "http://hl7.org/fhir/StructureDefinition/structuredefinition-imposeProfile";
export declare function splitOnPathPeriods(path: string): string[];
/**
 * This function sets an instance property of a resource if possible
 * @param {StructureDefinition | ElementDefinition | CodeSystem | ValueSet} instance - The instance to assign a value on
 * @param {string} path - The path to assign a value at
 * @param {any} value - The value to assign
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 */
export declare function setPropertyOnDefinitionInstance(instance: StructureDefinition | ElementDefinition | CodeSystem | ValueSet, path: string, value: any, fisher: Fishable): void;
/**
 * Adds placeholder elements with slice names to array elements on instance definition.
 * The placeholder elements to add are based on the paths in the rule map.
 * @param {StructureDefinition | ElementDefinition | InstanceDefinition} instanceDef - Instance to create slices on
 * @param {StructureDefinition} instanceOfStructureDefinition - Structure definition for instanceDef
 * @param {Map<string, { pathParts: PathPart[] }>} ruleMap - Contains the paths used in assignment rules on the instance
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 * Returns the path of the slice including the slice name and the quantity (the minimum or the greatest index of the
 * slice that is used in a rule) of the slice.
 */
export declare function createUsefulSlices(instanceDef: StructureDefinition | ElementDefinition | InstanceDefinition, instanceOfStructureDefinition: StructureDefinition, ruleMap: Map<string, {
    pathParts: PathPart[];
}>, fisher: Fishable): Map<string, number>;
/**
 * Looks through the rules on an instance to determine what slices will be created
 * when the instance is exported.
 * Returns the path of the slice including the slice name and the quantity (the minimum or the greatest index of the
 * slice that is used in a rule) of the slice.
 */
export declare function determineKnownSlices(instanceOfStructureDefinition: StructureDefinition, ruleMap: Map<string, {
    pathParts: PathPart[];
}>, fisher: Fishable): Map<string, number>;
/**
 * NOTE: There is a thorough explanation of this function in ./common-README.md
 * that will hopefully explain some of the intricacies of function.
 * Good luck out there.
 */
export declare function setImpliedPropertiesOnInstance(instanceDef: StructureDefinition | ElementDefinition | InstanceDefinition | CodeSystem | ValueSet, instanceOfStructureDefinition: StructureDefinition, paths: string[], assignedResourcePaths: string[], fisher: Fishable, knownSlices?: Map<string, number>, manualSliceOrdering?: boolean): void;
export declare function setPropertyOnInstance(instance: StructureDefinition | ElementDefinition | InstanceDefinition | ValueSet | CodeSystem, pathParts: PathPart[], assignedValue: any, fisher: Fishable): void;
/**
 * Tests to see if the last bracket in a PathPart is a non-negative int, and if so returns it
 * @param {PathPart} pathPart - The part of the path to test
 * @returns {number} The index if it exists and is non-negative, otherwise undefined
 *
 */
export declare function getArrayIndex(pathPart: PathPart): number;
/**
 * Replaces a reference to an item by name or id with the correct relative path to that item.
 * Replaces a reference to a local code system by the url for that code system.
 * @param {AssignmentRule} rule - The rule to replace references on
 * @param {FSHTank} tank - The tank holding the instances and code systems
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 * @returns {AssignmentRule} a clone of the rule if replacing is done, otherwise the original rule
 */
export declare function replaceReferences<T extends AssignmentRule | CaretValueRule>(rule: T, tank: FSHTank, fisher: Fishable): T;
export declare function listUndefinedLocalCodes(codeSystem: FshCodeSystem | Instance, codes: string[], tank: FSHTank, sourceEntity: FshEntity): void;
/**
 * Returns the sliceName for a set of pathParts
 * @param {PathPart} pathPart - The part of the path to get a sliceName for
 * @returns {string} The sliceName for the path part
 */
export declare function getSliceName(pathPart: PathPart): string;
/**
 * Replaces fields in an object that match a certain condition
 * @param { {[key: string]: any} } object - The object to replace fields on
 * @param {(object: { [key: string]: any }, prop: string) => boolean} matchFn - The function to match with
 * @param {(object: { [key: string]: any }, prop: string) => void} replaceFn - The function to replace with
 * @param {(object: { [key: string]: any }, prop: string) => boolean} skipFn - A function that returns true if a property should not be traversed
 */
export declare function replaceField(object: {
    [key: string]: any;
}, matchFn: (object: {
    [key: string]: any;
}, prop: string) => boolean, replaceFn: (object: {
    [key: string]: any;
}, prop: string) => void, skipFn: (prop: string) => boolean): void;
/**
 * Cleans up temporary properties that were added to the resource definition during processing
 * @param {StructureDefinition | InstanceDefinition | CodeSystem | ValueSet} resourceDef - The resource definition to clean
 * @param {string => boolean} skipFn - A function that returns true if a property should not be traversed
 */
export declare function cleanResource(resourceDef: StructureDefinition | InstanceDefinition | CodeSystem | ValueSet, skipFn?: (prop: string) => boolean): void;
/**
 * Adds insert rules onto a Profile, Extension, or Instance
 * @param fshDefinition - The definition to apply rules on
 * @param tank - The FSHTank containing the fshDefinition
 */
export declare function applyInsertRules(fshDefinition: Profile | Extension | Logical | Resource | Instance | FshValueSet | FshCodeSystem | Invariant | Mapping | RuleSet, tank: FSHTank, seenRuleSets?: string[]): void;
/**
 * Tests if resourceType is a valid FHIR resource that is a subtype of type. This is the case
 * if type is Resource, or if type is DomainResource and resourceType is one of the resources
 * that inherits from DomainResource, or if type is equal to resourceType.
 * @param {string} resourceType - The resourceType to test inheritance of
 * @param {string} type - The original type being inherited from
 * @param {Fishable} fisher - A fisher for finding FHIR definitions
 * @param {boolean} allowProfile - True if profiles of inherited resource should be allowed
 * @returns {boolean} true if resourceType is a valid sub-type of type, false otherwise
 */
export declare function isInheritedResource(resourceType: string, type: string, fisher: Fishable, allowProfile?: boolean): boolean;
/**
 * Determines the formal FHIR URL to use to refer to this entity (for example when fishing).
 * If a caret value rule has been applied to the entity's url, use the value specified in that
 * rule. Otherwise, use the default url based on the configured canonical url.
 * Since a string should always be assigned here, only return the rule value if it is a string
 * and not an Instance.
 *
 * @param fshDefinition - The FSH definition that the returned URL refers to
 * @param canonical - The canonical URL for the FSH project
 * @returns The URL to use to refer to the FHIR entity
 */
export declare function getUrlFromFshDefinition(fshDefinition: Profile | Extension | Logical | Resource | FshValueSet | FshCodeSystem | Instance, canonical: string): string;
/**
 * Determines the version of this entity.
 * If a caret value rule has been applied to the entity's version, use the value specified in that
 * rule. Otherwise, use the default version based on the configured version from the tank.
 * Since a string should always be assigned here, only return the rule value if it is a string
 * and not an Instance.
 *
 * @param fshDefinition - The FSH definition whose version is being determined
 * @param canonical - The version for the FSH project
 * @returns The version of the FHIR entity
 */
export declare function getVersionFromFshDefinition(fshDefinition: Profile | Extension | Logical | Resource | FshValueSet | FshCodeSystem | Instance, version: string): string;
/**
 * Determines the formal FHIR type to use to define to this entity for logical models and
 * resources. The type for profiles and extension should not be changed. If a caret value
 * rule has been applied to the entity's type, use the value specified in that rule.
 * Otherwise, use the appropriate default based on the fshDefinition.
 *
 * @param fshDefinition - The FSH definition (Logical or Resource) that the returned type refers to
 * @param parentSD - The parent StructureDefinition for the fshDefinition
 * @returns The type to specify in the StructureDefinition for this fshDefinition
 */
export declare function getTypeFromFshDefinitionOrParent(fshDefinition: Profile | Extension | Logical | Resource, parentSD: StructureDefinition): string;
export declare function isExtension(path: string): boolean;
export declare function isModifierExtension(extension: any): boolean;
/**
 * Checks if a provided type can be treated as a Reference
 * @param type - The type being checked
 * @returns - True if the type can be treated as a reference, false otherwise
 */
export declare function isReferenceType(type: string): boolean;
/**
 * Use the raw value from a CaretValueRule to try to find an Instance to assign.
 * This is useful in cases where the Instance id is numeric or boolean.
 */
export declare function validateInstanceFromRawValue(target: CodeSystem | ValueSet, rule: CaretValueRule, instanceExporter: InstanceExporter, fisher: Fishable, originalErr: MismatchedTypeError): {
    instance: InstanceDefinition;
    pathParts: PathPart[];
};
/**
 * Make a deep clone recursively, adding properties in the order expected for exported JSON.
 * If a list of keys is provided, use those properties from the input.
 * Otherwise, use all properties from the input.
 *
 * @param input - the value to clone
 * @param keys - optionally, the properties of the value to include in the clone, defaults to input keys if not specified
 * @returns {any} - a clone of the input, with reordered properties
 */
export declare function orderedCloneDeep(input: any, keys?: string[]): any;
export declare function getAllConcepts(cs: {
    concept?: CodeSystemConcept[];
}): string[];
/**
 * Find the profiles declared as impose profiles via the imposeProfile extension.
 * @param sd - the StructureDefinition to extract imposeProfiles from
 * @returns - a list of impose profile URLs or undefined if there are none
 */
export declare function findImposeProfiles(sd: any): string[] | undefined;
export declare function getMatchingContainedReferenceId(value: string, containedResources: {
    pathParts: PathPart[];
    assignedValue: any;
}[]): any;
