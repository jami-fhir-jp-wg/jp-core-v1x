"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePeriod = validatePeriod;
exports.validateRange = validateRange;
const errors_1 = require("../errors");
const primitiveTypes_1 = require("./primitiveTypes");
/**
 * Throws an error if either start or end are not valid dateTime strings,
 * or if the start comes before the end.
 * @param period - the Period to validate.
 * @returns {void}
 * @throws {InvalidPeriodError} when the start comes before the end.
 */
function validatePeriod(period) {
    let start, end;
    if (period.start) {
        (0, primitiveTypes_1.validateFHIRDateTime)(period.start);
        start = new Date(period.start);
    }
    if (period.end) {
        (0, primitiveTypes_1.validateFHIRDateTime)(period.end);
        end = new Date(period.end);
    }
    if (start && end && start > end) {
        throw new errors_1.InvalidPeriodError(period);
    }
}
/**
 * Enforces constraints on values, units, codes, and systems in a range.
 * @param {range} Range - the Range to validate.
 * @returns {void}
 * @throws {InvalidRangeValueError} when the low value is greater than or equal to the high value.
 * @throws {UnitMismatchError} when low and high do not have matching unit attributes.
 * @throws {CodeAndSystemMismatchError} when low and high do not have matching code and system attributes.
 */
function validateRange(range) {
    if (range.low && range.high) {
        if (range.low.value > range.high.value) {
            throw new errors_1.InvalidRangeValueError(range.low.value, range.high.value);
        }
        if (range.low.unit !== range.high.unit) {
            throw new errors_1.UnitMismatchError(range.low, range.high);
        }
        if (range.low.code !== range.high.code || range.low.system !== range.high.system) {
            throw new errors_1.CodeAndSystemMismatchError(range.low, range.high);
        }
    }
}
//# sourceMappingURL=dataTypes.js.map