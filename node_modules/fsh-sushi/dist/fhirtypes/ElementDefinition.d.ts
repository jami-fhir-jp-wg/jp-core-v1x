import { PathPart, StructureDefinition } from './StructureDefinition';
import { CodeableConcept, CodeableReference, Coding, Element, Quantity, Ratio, Reference } from './dataTypes';
import { FshCode, Invariant, SourceInfo } from '../fshtypes';
import { AddElementRule, AssignmentValueType, OnlyRule } from '../fshtypes/rules';
import { ValidationError } from '../errors';
import { Fishable } from '../utils';
import { InstanceDefinition } from './InstanceDefinition';
export declare class ElementDefinitionType {
    private _actualCode;
    _code?: Element;
    profile?: string[];
    _profile?: Element[];
    targetProfile?: string[];
    _targetProfile?: Element[];
    aggregation?: string[];
    _aggregation?: Element[];
    versioning?: string;
    _versioning?: Element;
    extension?: ElementDefinitionExtension[];
    constructor(code: string);
    /**
     * Element.id, Extension.url, and primitive types are specified in the valueUrl of an extension.
     * This function returns the fhir-type extension's valueUrl if available, else returns the code.
     * @see {@link http://hl7.org/fhir/extension-structuredefinition-fhir-type.html}
     */
    get code(): string;
    set code(c: string);
    getActualCode(): string;
    withProfiles(...profiles: string[]): this;
    withTargetProfiles(...targetProfiles: string[]): this;
    toJSON(): ElementDefinitionTypeJSON;
    static fromJSON(json: any): ElementDefinitionType;
}
/**
 * A class representing a FHIR R4 ElementDefinition.  For the most part, each allowable property in an ElementDefinition
 * is represented via a get/set in this class, and the value is expected to be the FHIR-compliant JSON that would go
 * in the StructureDefinition JSON file (w/ translation for R3).
 * @see {@link http://hl7.org/fhir/R4/elementdefinition.html}
 */
export declare class ElementDefinition {
    private _privateId;
    path: string;
    extension: any[];
    modifierExtension: any[];
    representation: string[];
    sliceName: string;
    sliceIsConstraining: boolean;
    label: string;
    code: Coding[];
    slicing: ElementDefinitionSlicing;
    short: string;
    definition: string;
    comment: string;
    requirements: string;
    alias: string[];
    min: number;
    max: string;
    base: ElementDefinitionBase;
    contentReference: string;
    type: ElementDefinitionType[];
    meaningWhenMissing: string;
    orderMeaning: string;
    fixedCode: string;
    patternCode: string;
    fixedString: string;
    patternString: string;
    fixedUri: string;
    patternUri: string;
    fixedUrl: string;
    patternUrl: string;
    fixedCanonical: string;
    patternCanonical: string;
    fixedInstant: string;
    patternInstant: string;
    fixedBase64Binary: string;
    patternBase64Binary: string;
    fixedDate: string;
    patternDate: string;
    fixedDateTime: string;
    patternDateTime: string;
    fixedTime: string;
    patternTime: string;
    fixedOid: string;
    patternOid: string;
    fixedId: string;
    patternId: string;
    fixedMarkdown: string;
    patternMarkdown: string;
    fixedUuid: string;
    patternUuid: string;
    fixedXhtml: string;
    patternXhtml: string;
    fixedBoolean: boolean;
    patternBoolean: boolean;
    fixedDecimal: number;
    patternDecimal: number;
    fixedInteger: number;
    patternInteger: number;
    fixedInteger64: string;
    patternInteger64: string;
    fixedUnsignedInt: number;
    patternUnsignedInt: number;
    fixedPositiveInt: number;
    patternPositiveInt: number;
    fixedCodeableConcept: CodeableConcept;
    patternCodeableConcept: CodeableConcept;
    fixedCoding: Coding;
    patternCoding: Coding;
    fixedQuantity: Quantity;
    patternQuantity: Quantity;
    fixedAge: Quantity;
    patternAge: Quantity;
    fixedAddress: InstanceDefinition;
    patternAddress: InstanceDefinition;
    fixedPeriod: InstanceDefinition;
    patternPeriod: InstanceDefinition;
    fixedRatio: Ratio;
    patternRatio: Ratio;
    fixedReference: Reference;
    patternReference: Reference;
    fixedCodeableReference: CodeableReference;
    patternCodeableReference: CodeableReference;
    example: ElementDefinitionExample[];
    maxLength: number;
    condition: string[];
    constraint: ElementDefinitionConstraint[];
    mustSupport: boolean;
    isModifier: boolean;
    isModifierReason: string;
    isSummary: boolean;
    binding: ElementDefinitionBinding;
    mapping: ElementDefinitionMapping[];
    structDef: StructureDefinition;
    treeParent: ElementDefinition;
    treeChildren: ElementDefinition[];
    private _original;
    private _edStructureDefinition;
    private _replacementProps;
    /**
     * Constructs a new ElementDefinition with the given ID.
     * @param {string} id - the ID of the ElementDefinition
     */
    constructor(id?: string);
    get id(): string;
    /**
     * Sets the id of the ElementDefinition and updates the path accordingly.
     * NOTE: This does not automatically update child ids/paths.  That is currently up to the library user.
     * @param {string} id - the ElementDefinition id
     */
    set id(id: string);
    validate(): ValidationError[];
    private validateRequired;
    private validateIncludes;
    isArrayOrChoice(): boolean;
    isPrimitive(fisher: Fishable): boolean;
    private validateSlicing;
    getPathWithoutBase(): string;
    /**
     * Get the StructureDefinition for ElementDefinition
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @returns {StructureDefinition} the StructureDefinition of ElementDefinition
     */
    getOwnStructureDefinition(fisher: Fishable): StructureDefinition;
    /**
     * Returns the Types that have the given code(s).
     * @param {string[]} codes - the codes to match Types against
     * @returns {ElementDefinitionType[]} the matched Types
     */
    findTypesByCode(...codes: string[]): ElementDefinitionType[];
    /**
     * Creates a new element with an id/path indicating it is a child of the current element.
     * Defaults to '$UNKNOWN' if no name is passed in, as it needs a value, but usually a name should be passed in.
     * NOTE: This function does not automatically add the child element to the StructureDefinition.
     * @param {string} name - the name of the child element, to be appended to the parent ID/path
     * @returns {ElementDefinition} the new child element
     */
    newChildElement(name?: string): ElementDefinition;
    /**
     * ElementDefinition is capable of producing its own differential, based on differences from a stored "original".
     * This function captures the current state as the "original", so any further changes made would be captured in
     * the generated differential. The structDef reference isn't used in the differential, so it can be removed.
     */
    captureOriginal(): void;
    /**
     * Clears the stored "original" state, resulting in every property being considered new, and reflected in the
     * generated differential.
     */
    clearOriginal(): void;
    clearOriginalProperty(pathParts: PathPart[]): void;
    private calculateClearPath;
    /**
     * Determines if the state of the current element differs from the stored "original".
     * @returns {boolean} true if the state of the current element differs from the stored "original", false otherwise
     */
    hasDiff(): boolean;
    /**
     * Calculates the differential based on changes in data from the stored "original" state and returns the differential
     * as a new ElementDefinition containing only the id, path, and changed data.
     * @returns {ElementDefinition} an ElementDefinition representing the changed data since the stored "original" state
     */
    calculateDiff(): ElementDefinition;
    /**
     * Apply the AddElementRule to this new element using the appropriate methods
     * for specific rules for the AddElementRule's implied rules (i.e., cardinality,
     * type constraints, and flags).
     * @param {AddElementRule} rule - specific instance of the rule
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     */
    applyAddElementRule(rule: AddElementRule, fisher: Fishable): void;
    /**
     * Define and return the initial base ElementDefinition.type from the AddElementRule.
     * @ref https://github.com/FHIR/sushi/pull/802#discussion_r631300737
     * @param {AddElementRule} rule - specific instance of the rule
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @returns {ElementDefinitionType[]} The element types as defined by the AddElementRule
     * @private
     */
    private initializeElementType;
    /**
     * Apply invariant to the Element.constraint
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.constraint}
     * @param invariant The invariant to be applied to the constraint
     * @param source Source URL for the constraint
     * @returns {number} the index of the constraint that was applied
     */
    applyConstraint(invariant: Invariant, source?: string): number;
    /**
     * This function sets an instance property of an ED if possible
     * @param {string} path - The path to the ElementDefinition to assign
     * @param {any} value - The value to assign
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     */
    setInstancePropertyByPath(path: string, value: any, fisher: Fishable): void;
    getSlices(): ElementDefinition[];
    /**
     * Returns an array of slices that will be pre-loaded.
     * A slice is pre-loaded if if has a min of 1 and contains a fixed or pattern value on itself or it's descendents
     * @returns {ElementDefinition[]} - Array of slices to be pre-loaded
     */
    getPreloadedSlices(): ElementDefinition[];
    /**
     * Determines if an array index references a slice that will be preloaded.
     * A slice is pre-loaded if if has a min of 1 and contains a fixed or pattern value on itself or it's descendents
     * @param {number} sliceIndex - The index
     * @returns {boolean}
     */
    isPreloadedSlice(sliceIndex: number): boolean;
    /**
     * Constrains the cardinality of this element.  Cardinality constraints can only narrow
     * cardinality.  Attempts to constrain to a wider cardinality will throw.
     * @see {@link http://hl7.org/fhir/R4/profiling.html#cardinality}
     * @see {@link http://hl7.org/fhir/R4/conformance-rules.html#cardinality}
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.min}
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.max}
     * @param {number} min - the minimum cardinality
     * @param {number|string} max - the maximum cardinality
     * @throws {InvalidCardinalityError} when min > max
     * @throws {ConstrainingCardinalityError} when new cardinality is wider than existing cardinality
     * @throws {InvalidSumOfSliceMinsError} when the mins of slice elements > max of sliced element
     * @throws {NarrowingRootCardinalityError} when the new cardinality on an element is narrower than
     *   the cardinality on a connected element
     */
    constrainCardinality(min: number, max: string): void;
    /**
     * Tries to find all connected elements based on slicing.
     * When an element that has children is sliced, there can be constraints on that element's children,
     * as well as the children of any defined slices. Depending on the order that slices and rules are
     * defined, a rule may be applied to an element after slices of that element have already been
     * created. Therefore, to determine the full effect of that rule, the elements that are inside
     * slices must be found. The rule's path may contain many sliced elements, so it is necessary
     * to recursively search the StructureDefinition for ancestors of the element on the rule's path
     * that contain slice definitions. These sliced ancestors may in turn contain child elements that
     * match the rule's path.
     * In summary: find elements that have the same path, but are slicier.
     * @param {string} postPath The path to append to the parent in order to try to find a connected element
     * @returns {ElementDefinition[]} The elements at or inside of slices whose path matches the original element
     */
    findConnectedElements(postPath?: string): ElementDefinition[];
    findConnectedSliceElement(postPath?: string): ElementDefinition;
    findParentSlice(): ElementDefinition;
    /**
     * Checks if the sum of slice mins exceeds the max of sliced element, and returns
     * the sum if so.
     * @param {string} slicedElementMax - The max of the sliced element
     * @param {number} newSliceMin - An optional new minimum if the minimum of this is being constrained
     * @returns {number} the sum of the mins of the slices, or 0 if the sum is less than the sliced max
     * @throws {InvalidSumOfSliceMinsError} when the sum of mins of the slices exceeds max of sliced element
     */
    private checkSumOfSliceMins;
    /**
     * Constrains the type of this element to the requested type(s).  When this element's type is a
     * choice, this function will reduce the choice to only those types provided -- unless a
     * targetType is provided, in which case, only that type will be affected and other options in
     * the choice will be left unchanged.  This function should allow the following scenarios:
     * - constrain a choice of types to a smaller subset of types (including a single type)
     * - constrain a type to one or more profiles on that type
     * - constrain a supertype (e.g., Resource) to one or more subtypes (e.g., Condition)
     * - constrain a reference of multiple types to a reference of a smaller subset of types
     * - constrain a reference of a type or profile to one or more profiles of that type/profile
     * - constrain a reference of a supertype to one or more references of subtypes
     * - any combinaton of the above
     * This function will throw when:
     * - attempting to add a base type (e.g., `type.code`) that wasn't already a choice in the type
     * - attempting to add a profile that doesn't extend or impose (via extension) any of the
     *   existing types
     * - attempting to add a base reference that wasn't already a reference
     * - attempting to add a reference to a profile that doesn't extend or impose (via extensions)
     *   any of the existing references
     * - specifying a target that does not match any of the existing type choices
     * - specifying types or a target whose definition cannot be found
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.type}
     * @param {OnlyRule} rule - The rule specifying the types to apply
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @param {string} [target] - a specific target type to constrain.  If supplied, will attempt to
     *   constrain only that type without affecting other types (in a choice or reference to a choice).
     * @throws {TypeNotFoundError} when a passed in type's definition cannot be found
     * @throws {InvalidTypeError} when a passed in type or the targetType doesn't match any existing
     *   types
     * @throws {SliceTypeRemovalError} when a rule would eliminate all types on a slice
     */
    constrainType(rule: OnlyRule | AddElementRule, fisher: Fishable, target?: string): void;
    /**
     * Given a string representing a type or profile, will return this element's matching type, if
     * found -- with all other profiles or targetProfiles (e.g. references) removed from the type.
     * @param {string} target - the target to find a matching type for
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @returns {ElementDefinitionType} the element's type that matches the target
     * @throws {TypeNotFoundError} when the target's definition cannot be found
     * @throws {InvalidTypeError} when the target doesn't match any existing types
     */
    private getTargetType;
    /**
     * Given an input type (the constraint) and a set of target types (the things to potentially
     * constrain), find the match and return information about it.
     * @param {OnlyRuleType} type - the constrained types, identified by id/type/url string and
     *   an optional reference/canonical flags (defaults false)
     * @param {ElementDefinitionType[]} targetTypes - the element types that the constrained type
     *   can be potentially applied to
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @param {boolean} allowLooseMatch - whether to allow profiles to match on any other profile
     *   of the same resource / data type, even if it doesn't formally descend from the profile
     * @returns {ElementTypeMatchInfo} the information about the match
     * @throws {TypeNotFoundError} when the type's definition cannot be found
     * @throws {InvalidTypeError} when the type doesn't match any of the targetTypes
     */
    private findTypeMatch;
    /**
     * Gets the full lineage of the type, w/ the item at index 0 being the type's own Metadata,
     * the item at index 1 being its parent's, 2 being its grandparent's, etc.  If a definition can't be
     * found, it stops and returns as much lineage as is found thus far.
     * @param {string} type - the type to get the lineage for
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @param {boolean} includeImposeProfiles - whether or not profiles declared via an imposeProfile
     *   extension should be included in the lineage
     * @param {string[]} seenUrls - the list of URLs that have already been processed (for recursive calls)
     * @returns {Metadata[]} representing the lineage of the type
     */
    private getTypeLineage;
    /**
     * Given a new ElementTypeDefinition (based on the existing one), will apply the matching
     * profiles and targetProfiles as appropriate.  If a targetType was specified, will filter out
     * the other profiles or targetProfiles.
     * @param {ElementDefinitionType} newType - the new type to apply the profiles/targetProfiles to
     * @param {ElementDefinitionType} [targetType] - the (potentially null) target type for the
     *   type constraint
     * @param {ElementTypeMatchInfo[]} matches - the information about how type constraints map
     *   to element types
     */
    private applyProfiles;
    private findTypeIntersection;
    private applyTypeIntersection;
    /**
     * Sets flags on this element as specified in a profile or extension.
     * Don't change a flag when the incoming argument is undefined or false.
     * @see {@link http://hl7.org/fhir/R4/profiling.html#mustsupport}
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.mustSupport}
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.isSummary}
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.isModifier}
     * @see {@link http://hl7.org/fhir/R4/versions.html#std-process}
     * @see {@link http://hl7.org/fhir/extension-structuredefinition-standards-status.html}
     * @see {@link http://hl7.org/fhir/valueset-standards-status.html}
     * @param mustSupport - whether to make this element a Must Support element
     * @param summary - whether to include this element when querying for a summary
     * @param modifier - whether this element acts as a modifier on the resource
     * @param trialUse - indicates a standards status of "Trial Use" for this element
     * @param normative - indicates a standards status of "Normative" for this element
     * @param draft - indicates a standards status of "Draft" for this element
     */
    applyFlags(mustSupport: boolean, summary: boolean, modifier: boolean, trialUse: boolean, normative: boolean, draft: boolean): void;
    /**
     * Binds a value set with a specific strength to this element.  The type must be coded (code, Coding,
     * CodeableConcept, Quantity), or the data types (string, uri).  The strength must be the same or
     * stricter than the current strength (if a binding already exists).
     * TODO: Determine if it is valid to bind value set on a choice element (e.g., value[x]).
     * TODO: Determine rules for replacing existing bindings when we can't guarantee rules are followed.
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.binding}
     * @see {@link http://hl7.org/fhir/R4/terminologies.html#strength}
     * @param {string} vsURI - the value set URI to bind
     * @param {string} strength - the strength of the binding (e.g., 'required')
     * @param {SourceInfo} - optionally include rule.sourceInfo if the binding is coming from a rule
     * @throws {BindingStrengthError} when the binding can't be applied because it is looser than the existing binding
     * @throws {CodedTypeNotFoundError} - when the binding can't be applied because the element is the wrong type
     * @throws {InvalidUriError} when the value set uri is not valid
     */
    bindToVS(vsURI: string, strength: ElementDefinitionBindingStrength, ruleSourceInfo?: SourceInfo, fisher?: Fishable): void;
    /**
     * Assigns a value to an ElementDefinition
     * @param {AssignmentValueType} value - The value to assign
     * @param {exactly} boolean - True if if fixed[x] should be used, otherwise pattern[x] is used
     * @throws {NoSingleTypeError} when the ElementDefinition does not have a single type
     * @throws {ValueAlreadyAssignedError} when the value is already assigned to a different value
     * @throws {MismatchedTypeError} when the value does not match the type of the ElementDefinition
     */
    assignValue(value: AssignmentValueType, exactly?: boolean, fisher?: Fishable): void;
    /**
     * Checks if a FHIR value can be assigned and then assigns it if so. A FHIR value can be assigned on an element if:
     * - the element isn't already assigned to something else (by fixed[x], pattern[x], or from a parent)
     * - or the element is already assigned to something that is the same or a subset of the new value
     *   - e.g., you can assign { code: 'Foo', system: 'http://bar.com' } to an element already assigned to
     *     { system: 'http://bar.com } because the new value contains the old value (with no conflicts).
     *     This does not work the other way around, however.
     * @param {string} fshValue - The FSH-syntax-formatted value (usually the FSH class .toString())
     * @param {object} fhirValue - The FHIR representation of the FSH value
     * @param {boolean} exactly - Set to true if fixed[x] should be used, otherwise pattern[x] is used
     * @param {string} type - The FHIR type that is being assigned; will be used to construct fixed[x] and pattern[x] names
     * @throws {ValueAlreadyAssignedError} when the currentElementValue exists and is different than the new value
     * @throws {MismatchedTypeError} when the value does not match the type of the ElementDefinition
     */
    private assignFHIRValue;
    private checkAssignedValueAgainstChildren;
    private checkAssignedValueAgainstChild;
    /**
     * @param sdType - The type to check
     * @param sourceInfo - Source information for logging purposes
     * @param fisher - A fishable implementation for finding definitions and metadata
     * @returns - False if the type does not satisfy the targetProfile, true otherwise (or if it can't be determined)
     */
    private typeSatisfiesTargetProfile;
    /**
     * Checks if an element is assigned by a fixed[x] or pattern[x] on its direct parent
     * @returns {any} the value the element is assigned to by its parent, undefined if value is not assigned
     */
    assignedByDirectParent(): any;
    /**
     * Checks if an element is assigned by a pattern[x] on any of its parents
     * @returns {any} the value the element is assigned to by its parent, undefined if value is not assigned
     */
    assignedByAnyParent(): any;
    /**
     * Assigns a number to this element.
     * @see {@link assignValue}
     * @see {@link https://www.hl7.org/fhir/datatypes.html#primitive}
     * @param {number} value - the number value to assign
     * @param {exactly} boolean - True if if fixed[x] should be used, otherwise pattern[x] is used
     * @throws {NoSingleTypeError} when the ElementDefinition does not have a single type
     * @throws {ValueAlreadyAssignedError} when the value is already assigned to a different value
     * @throws {MismatchedTypeError} when the value does not match the type of the ElementDefinition
     */
    private assignNumber;
    private isValidBase64;
    /**
     * Assigns a string to this element.
     * @see {@link assignValue}
     * @see {@link https://www.hl7.org/fhir/datatypes.html#primitive}
     * @param {string} value - the string value to assign
     * @param {exactly} boolean - True if if fixed[x] should be used, otherwise pattern[x] is used
     * @throws {NoSingleTypeError} when the ElementDefinition does not have a single type
     * @throws {ValueAlreadyAssignedError} when the value is already assigned to a different value
     * @throws {TypeNotFoundError} when the value does not match the type of the ElementDefinition
     */
    private assignString;
    private checkXhtml;
    /**
     * Checks if a resource can be assigned to this element
     * @param {InstanceDefinition} value - The resource to assign
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @throws {MismatchedTypeError} when the ElementDefinition is not of type Resource
     * @returns {InstanceDefinition} the input value when it can be assigned
     */
    checkAssignInlineInstance(value: InstanceDefinition, fisher: Fishable): InstanceDefinition;
    /**
     * Assigns a code to this element, formatting it in the way the element expects for the type.
     * If the element is not a code-ish type or a different code is already assigned, it will throw.
     * TODO: Determine if it is valid to assign the code on a choice element (e.g., value[x]).
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.fixed_x_}
     * @see {@link http://hl7.org/fhir/R4/elementdefinition-definitions.html#ElementDefinition.pattern_x_}
     * @param {FshCode} code - the code to assign
     * @param {boolean} exactly - True if if fixed[x] should be used, otherwise pattern[x] is used
     * @param {Fishable} fisher - A fishable object used for finding structure definitions
     * @throws {MismatchedTypeError} when the type of the value cannot be assigned to the element
     * @throws {ValueAlreadyAssignedError} when the code is already assigned to a different code
     * @throws {InvalidUriError} when the system being assigned is not a valid uri
     */
    private assignFshCode;
    /**
     * Checks if a provided type is a specialization of Quantity
     * @param {string} type - The type being checked
     * @param {Fishable} fisher - A fishable object used for finding the Base Definition of the provided type
     */
    private isQuantityType;
    /**
     * Checks if a the ElementDefinition has exactly one type
     * @returns {boolean} - true if there is exactly one type
     */
    private hasSingleType;
    /**
     * Sets mapping on an element
     * @see {@link https://www.hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.mapping}
     * @param {string} identity - value for mapping.identity
     * @param {string} map - value for mapping.map
     * @param {string} comment - value for mapping.comment
     * @param {FshCode} language - language.code is value for mapping.language
     * @throws {InvalidMappingError} when attempting to set mapping with identity or map undefined
     * @throws {InvalidFHIRIdError} when setting mapping.identity to an invalid FHIR ID
     */
    applyMapping(identity: string, map: string, comment: string, language: FshCode): void;
    /**
     * Finds and returns the parent element.  For example, the parent element of `Foo.bar.one` is the element `Foo.bar`.
     * @returns {ElementDefinition|undefined} the parent element or undefined if this is the root element
     */
    parent(): ElementDefinition | undefined;
    /**
     * Finds and returns all parent elements.  For example, the parent elements of `Foo.bar.one` are [`Foo.bar`, `Foo`].
     * @returns {ElementDefinition[]} the array of parents, empty if no parents
     */
    getAllParents(): ElementDefinition[];
    /**
     * Finds and returns all child elements of this element.  For example, the children of `Foo.bar` might be the
     * elements `Foo.bar.one`, `Foo.bar.two`, and `Foo.bar.two.a`.  This will not "expand" or "unroll" elements; it
     * only returns those child elements that already exist in the structure definition.
     * @param {boolean} directOnly - If true, only direct children of the element are returned
     * @returns {ElementDefinition[]} the child elements of this element
     */
    children(directOnly?: boolean): ElementDefinition[];
    /**
     * Finds and returns all assignable descendents of the element. A assignable descendent is a direct child of the
     * element that has minimum cardinality greater than 0, and all assignable descendents of such children
     * @returns {ElementDefinition[]} the assignable descendents of this element
     */
    getAssignableDescendents(): ElementDefinition[];
    /**
     * Finds and returns the element being sliced
     * @returns {ElementDefinition | undefined} the sliced element or undefined if the element is not a slice
     */
    slicedElement(): ElementDefinition | undefined;
    /**
     * If the element has a single type, graft the type's elements into this StructureDefinition as child elements.
     * If the element is sliced, unfold from the sliced element on the StructureDefinition
     * If the element is a content reference, unfold from the referenced element on the StructureDefintion
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @returns {ElementDefinition[]} the unfolded elements or an empty array if the type is multi-value or type can't
     *   be resolved.
     */
    unfold(fisher: Fishable): ElementDefinition[];
    /**
     * Returns an array of an ElementDefinition's unfolded children.
     * @param {ElementDefinition} targetElement - The ElementDefinition being unfolded
     * @param {boolean} recaptureSliceExtensions - Indicates whether or not slice extensions should be recaptured
     * @returns {ElementDefinition[]} An array of the targetElement's children, with the IDs altered and
     * the original property re-captured.
     */
    private cloneChildren;
    /**
     * Checks a StructureDefinition's differential to determine if the profile element extension has been used on
     * an element.
     * @param {Object} profileJson - The json representation of this ElementDefinition's structDef
     * @returns {boolean} True if the profile element extension is found on this elements profile property, false
     * if the extension is not found
     */
    private hasProfileElementExtension;
    private getContentReferenceId;
    /**
     * Unfolds a choice element's typed choices. The elements added to this element's
     * structure definition are those that are on the common ancestor of the available types.
     * All types have a common ancestor of Element, so if all else fails, Element's
     * elements are used.
     *
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     */
    unfoldChoiceElementTypes(fisher: Fishable): ElementDefinition[];
    /**
     * Sets up slicings on an element by adding or modifying the element's `slicing`.  If a matching slicing discriminator
     * already exists, it will be used
     * @see {@link http://hl7.org/fhir/R4/profiling.html#slicing}
     * @param {string} discriminatorType - the discriminator type ('value' | 'exists' | 'pattern' | 'type' | 'profile')
     * @param {string} discriminatorPath - the dot-separated discriminator path
     * @param {boolean} [ordered] - indicates if the slices are ordered. If no value is provided, it will default to false
     * for new slicings or accept the existing value for existing slicings.
     * @param {string} [rules] - indicates if addition slices are allowed or not ('closed' | 'open' | 'openAtEnd'). If no
     * value is provided, it will default to 'open' for new slicings or accept the existing value for existing slicings.
     * @returns {ElementDefinitionSlicing} the slicing
     * @throws { SlicingDefinitionError } if ordered is changed from true to false or rules are changed from closed to
     * open/openAtEnd or openAtEnd is changed to open
     */
    sliceIt(discriminatorType: string, discriminatorPath: string, ordered?: boolean, rules?: string): ElementDefinitionSlicing;
    /**
     * Creates a new slice on the element.
     * @see {@link http://hl7.org/fhir/R4/profiling.html#slicing}
     * @param {string} name - the name of the new slice
     * @param { ElementDefinitionType } [type] - the type of the new slice; if undefined it copies over this element's types
     * @returns {ElementDefinition} the new element representing the slice
     */
    addSlice(name: string, type?: ElementDefinitionType): ElementDefinition;
    isPartOfComplexExtension(): boolean;
    /**
     * Clones the current ElementDefinition, optionally clearing the stored "original" (clears it by default)
     * @param {boolean} [clearOriginal=true] - indicates if the stored "original" should be cleared
     * @returns {ElementDefinition} the cloned ElementDefinition
     */
    clone(clearOriginal?: boolean): ElementDefinition;
    /**
     * Provides the FHIR-conformant JSON representation of this ElementDefinition
     * @returns {Object} the FHIR-conformant JSON representation of this ElementDefinition
     */
    toJSON(): LooseElementDefJSON;
    /**
     * Instantiates a new ElementDefinition from a FHIR-conformant JSON representation
     * @param {Object} json - the FHIR-conformant JSON representation of the ElementDefinition to instantiate
     * @param {captureOriginal} - indicate if original element should be captured for purposes of detecting
     *   differential.  Defaults to true.
     * @returns {ElementDefinition} the ElementDefinition representing the data passed in
     */
    static fromJSON(json: LooseElementDefJSON, captureOriginal?: boolean): ElementDefinition;
}
export type ElementDefinitionSlicing = {
    discriminator?: ElementDefinitionSlicingDiscriminator[];
    description?: string;
    ordered?: boolean;
    rules: string;
};
export type ElementDefinitionSlicingDiscriminator = {
    type: string;
    path: string;
};
export type ElementDefinitionBase = {
    path: string;
    min: number;
    max: string;
};
export type ElementDefinitionTypeJSON = {
    code: string;
    profile?: string[];
    targetProfile?: string[];
    aggregation?: string[];
    versioning?: string;
    extension?: ElementDefinitionExtension[];
};
export type ElementDefinitionExtension = {
    url: string;
    valueUrl?: string;
    valueUri?: string;
};
export type ElementDefinitionExample = {
    label: string;
};
export type ElementDefinitionConstraint = {
    key: string;
    requirements?: string;
    severity: string;
    human: string;
    expression?: string;
    xpath?: string;
    source?: string;
};
export type ElementDefinitionBinding = {
    strength: ElementDefinitionBindingStrength;
    description?: string;
    valueSet?: string;
};
export type ElementDefinitionBindingStrength = 'example' | 'preferred' | 'extensible' | 'required';
export type ElementDefinitionMapping = {
    identity: string;
    language?: string;
    map: string;
    comment?: string;
};
/**
 * A barebones and lenient definition of ElementDefinition JSON
 */
export interface LooseElementDefJSON {
    id?: string;
    path?: string;
    slicing?: ElementDefinitionSlicing;
    type?: ElementDefinitionTypeJSON[];
    binding?: ElementDefinitionBinding;
}
