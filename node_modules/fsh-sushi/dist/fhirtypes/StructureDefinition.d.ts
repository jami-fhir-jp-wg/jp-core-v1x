import { ElementDefinition, ElementDefinitionType, LooseElementDefJSON } from './ElementDefinition';
import { Meta } from './specialTypes';
import { Identifier, CodeableConcept, Coding, Narrative, Resource, Extension } from './dataTypes';
import { ContactDetail, UsageContext } from './metaDataTypes';
import { ValidationError } from '../errors';
import { HasName, HasId } from './mixins';
import { Fishable } from '../utils/Fishable';
import { SourceInfo } from '../fshtypes';
/**
 * A class representing a FHIR R4 StructureDefinition.  For the most part, each allowable property in a StructureDefinition
 * is represented via a get/set in this class, and the value is expected to be the FHIR-compliant JSON that would go
 * in the StructureDefinition JSON file (w/ translation for R3).
 *
 * The snapshot and differential, however, do not have their own properties, but rather are represented as an
 * `elements` get/set property, whose value is a list of `ElementDefinition` instances.
 *
 * @see {@link http://hl7.org/fhir/R4/structuredefinition.html|FHIR StructureDefinition}
 */
export declare class StructureDefinition {
    readonly resourceType = "StructureDefinition";
    meta: Meta;
    implicitRules: string;
    language: string;
    text: Narrative;
    contained: Resource[];
    extension: Extension[];
    modifierExtension: Extension[];
    url: string;
    identifier: Identifier[];
    version: string;
    title: string;
    status: string;
    experimental: boolean;
    date: string;
    publisher: string;
    contact: ContactDetail[];
    description: string;
    useContext: UsageContext[];
    jurisdiction: CodeableConcept[];
    purpose: string;
    copyright: string;
    keyword: Coding[];
    fhirVersion: string;
    mapping: StructureDefinitionMapping[];
    kind: string;
    abstract: boolean;
    context: StructureDefinitionContext[];
    contextInvariant: string[];
    type: string;
    baseDefinition: string;
    derivation: 'specialization' | 'constraint';
    /**
     * The StructureDefinition's elements.  The returned array should not be pushed to directly.  Instead, use
     * the {@link addElement} or {@link addElements} function
     */
    elements: ElementDefinition[];
    /**
     * A StructureDefinition instance of StructureDefinition itself.  Needed for supporting escape syntax.
     */
    private _sdStructureDefinition;
    private originalMapping;
    validate(): ValidationError[];
    /**
     * A flag indicating if the StructureDefinition is currently being processed.
     * This allows us to log messages when processing might be affected by circular dependencies.
     */
    inProgress?: boolean;
    /**
     * Constructs a StructureDefinition with a root element.
     */
    constructor();
    /**
     * Get the file name for serializing to disk.
     * @returns {string} the filename
     */
    getFileName(): string;
    get pathType(): string;
    /**
     * Get the Structure Definition for Structure Definition
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @returns {StructureDefinition} the StructureDefinition of StructureDefinition
     */
    getOwnStructureDefinition(fisher: Fishable): StructureDefinition;
    /**
     * Adds an ElementDefinition to the StructureDefinition's elements, inserting it into the proper location based
     * on its ID and sliceName.  This should be used rather than pushing directly to the elements array.
     * @param {ElementDefinition} element - the ElementDefinition to add
     */
    addElement(element: ElementDefinition): void;
    addElementToTree(element: ElementDefinition): void;
    private escapePath;
    /**
     * Adds an array of ElementDefinitions to the StructureDefinition, inserting each one into the proper location based
     * on its ID.  This should be used rather than pushing directly to the elements array.
     * @param {ElementDefinition[]} elements - the array of ElementDefinitions to add
     */
    addElements(elements?: ElementDefinition[]): void;
    /**
     * Finds an element by its id.
     * @param {string} id
     * @returns {ElementDefinition} the found element (or undefined if it is not found)
     */
    findElement(id: string): ElementDefinition;
    /**
     * Finds an element by a FSH-compatible path
     * @param {string} path - The FSH path
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @returns {ElementDefinition} - The found element (or undefined if it is not found)
     */
    findElementByPath(path: string, fisher: Fishable): ElementDefinition;
    /**
     * Change a path's choice elements that are given as [x], but only have one type.
     * If the choice element has more than one type, do not change it.
     * For example, value[x] constrained to only "string" would become valueString.
     * These paths are useful when assigning values on an instance.
     * @param {string} path - The FSH path to operate on
     * @returns {string} - a FSH path with type-specific choices
     */
    updatePathWithChoices(path: string): string;
    /**
     * This function sets an instance property of an SD if possible
     * @param {string} path - The path to the ElementDefinition to assign
     * @param {any} value - The value to assign
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     */
    setInstancePropertyByPath(path: string, value: any, fisher: Fishable): void;
    /**
     * Creates a new element and adds it to the StructureDefinition elements.
     * @param {string} name - the name of the element to create (which will be appended to the element ID)
     * @returns {ElementDefinition} the new ElementDefinition
     */
    newElement(name?: string): ElementDefinition;
    /**
     * Each ElementDefinition is capable of producing its own differential, based on differences
     * from a stored "original".  This function captures the current state of each element as the
     * "original", so any further changes made would be captured in the generated differentials.
     */
    captureOriginalElements(): void;
    /**
     * Clears the stored "original" state for each ElementDefnition, resulting in every property
     * being considered new, and reflected in the generated differentials.
     */
    clearOriginalElements(): void;
    /**
     * Capture the current state of the mapping array. This is used to determine
     * which mappings have been added and which are inherited.
     */
    captureOriginalMapping(): void;
    buildMappingJSON(j: LooseStructDefJSON, snapshot: boolean): void;
    /**
     * Exports the StructureDefinition to a properly formatted FHIR JSON representation.
     * @returns {any} the FHIR JSON representation of the StructureDefinition
     */
    toJSON(snapshot?: boolean): any;
    /**
     * Constructs a new StructureDefinition representing the passed in JSON.  The JSON that is passed in must be a
     * properly formatted FHIR 4.0.1 StructureDefinition JSON.
     * @param {any} json - the FHIR 4.0.1 JSON representation of a StructureDefinition to construct
     * @param {captureOriginalElements} - indicate if original elements should be captured for purposes of
     *   detecting differentials.  Defaults to true.
     * @returns {StructureDefinition} a new StructureDefinition instance representing the passed in JSON
     */
    static fromJSON(json: LooseStructDefJSON, captureOriginalElements?: boolean): StructureDefinition;
    /**
     * This function tests if it is possible to assign value to a path, but does not actually assign it
     * @param {string} path - The path to the ElementDefinition to assign
     * @param {any} value - The value to assign; use null to validate just the path when you know the value is valid
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @param {string[]} inlineResourceTypes - Types that will be used to replace Resource elements
     * @param {boolean} manualSliceOrdering - Flag to determine how list elements and slices should be accessed
     * @param {SourceInfo} sourceInfo - Source info of the rule being validated
     * @throws {CannotResolvePathError} when the path cannot be resolved to an element
     * @throws {InvalidResourceTypeError} when setting resourceType to an invalid value
     * @returns {any} - The object or value to assign
     */
    validateValueAtPath(path: string, value: any, fisher: Fishable, inlineResourceTypes?: string[], sourceInfo?: SourceInfo, manualSliceOrdering?: boolean): {
        assignedValue: any;
        pathParts: PathPart[];
        childPath?: string;
    };
    /**
     * Looks for a matching choice element. If the choice has no existing slice, we slice it and
     * add to the existing StructureDefinition. If the choice has an existing slice, we return that.
     * @param {string} fhirPath - The path in FHIR to match with
     * @param {ElementDefinition[]} elements - The set of elements to search through
     * @returns {ElementDefinition} - The new slice element if found, else undefined
     */
    private sliceMatchingValueX;
    /**
     * Looks for a slice within the set of elements that matches the fhirPath
     * @param {string} fhirPathString - the current FHIR path to match against
     * @param {PathPart} pathPart - The path part to match sliceName against
     * @param {ElementDefinition[]} elements - The set of elements to search through
     * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
     * @returns {ElementDefinition} - The sliceElement if found, else undefined
     */
    private findMatchingSlice;
    findObsoleteChoices(baseElement: ElementDefinition, oldTypes: ElementDefinitionType[]): string[];
    /**
     * Looks for a Reference or canonical type element within the set of elements that matches the fhirPath
     * @param {PathPart} pathPart - The path to match the Reference/canonical type elements against
     * @param {ElementDefinition[]} elements - The set of elements to search through
     * @returns {ElementDefinition} - The Reference/canonical type element if found, else undefined
     */
    private findMatchingRefOrCanonical;
    /**
     * Gets the specific reference or canonical being referred to by a path with brackets
     * @param {string} path - The path
     * @param {ElementDefinition} element - The element that may contain the reference/canonical
     * @returns {string} - The name of the reference/canonical if it exists, else undefined
     */
    getReferenceOrCanonicalName(path: string, element: ElementDefinition): string;
}
export interface StructureDefinition extends HasName, HasId {
}
export type StructureDefinitionMapping = {
    identity: string;
    uri?: string;
    name?: string;
    comment?: string;
};
export type StructureDefinitionContext = {
    type: string;
    expression: string;
};
export type PathPart = {
    base: string;
    brackets?: string[];
    primitive?: boolean;
    slices?: string[];
    prefix?: string;
};
/**
 * A barebones and lenient definition of StructureDefinition JSON
 */
interface LooseStructDefJSON {
    resourceType: string;
    derivation?: string;
    mapping?: StructureDefinitionMapping[];
    snapshot?: {
        element: LooseElementDefJSON[];
    };
    differential?: {
        element: LooseElementDefJSON[];
    };
    inProgress?: boolean;
}
export {};
