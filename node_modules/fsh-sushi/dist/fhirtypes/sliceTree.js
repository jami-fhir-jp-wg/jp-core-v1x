"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSliceTree = buildSliceTree;
exports.calculateSliceTreeCounts = calculateSliceTreeCounts;
const lodash_1 = require("lodash");
function buildSliceTree(parent) {
    const root = {
        element: parent,
        children: []
    };
    const slicesToUse = parent.getSlices();
    slicesToUse.forEach(slice => {
        insertIntoSliceTree(root, slice);
    });
    return root;
}
function insertIntoSliceTree(parent, elementToAdd) {
    const nextParent = parent.children.find(child => elementToAdd.sliceName.startsWith(`${child.element.sliceName}/`));
    if (nextParent != null) {
        insertIntoSliceTree(nextParent, elementToAdd);
    }
    else {
        parent.children.push({ element: elementToAdd, children: [] });
    }
}
function calculateSliceTreeCounts(node, knownSlices, keyStart) {
    node.children.forEach(child => calculateSliceTreeCounts(child, knownSlices, keyStart));
    const elementMin = node.element.min - (0, lodash_1.sumBy)(node.children, getSliceTreeSum);
    const slicePath = keyStart +
        node.element.id
            .split('.')
            .slice(-1)[0]
            .replace(/:(.*)$/, '[$1]')
            .replace(/\//g, '][');
    const sliceMin = knownSlices.has(slicePath) ? knownSlices.get(slicePath) : 0;
    node.count = Math.max(elementMin, sliceMin);
}
function getSliceTreeSum(node) {
    return node.count + (0, lodash_1.sumBy)(node.children, getSliceTreeSum);
}
//# sourceMappingURL=sliceTree.js.map