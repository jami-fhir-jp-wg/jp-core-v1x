"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IMPOSE_PROFILE_EXTENSION = exports.LOGICAL_TARGET_EXTENSION = exports.TYPE_CHARACTERISTICS_CODE = exports.TYPE_CHARACTERISTICS_EXTENSION = exports.CONFORMANCE_AND_TERMINOLOGY_RESOURCES = void 0;
exports.splitOnPathPeriods = splitOnPathPeriods;
exports.setPropertyOnDefinitionInstance = setPropertyOnDefinitionInstance;
exports.createUsefulSlices = createUsefulSlices;
exports.determineKnownSlices = determineKnownSlices;
exports.setImpliedPropertiesOnInstance = setImpliedPropertiesOnInstance;
exports.setPropertyOnInstance = setPropertyOnInstance;
exports.getArrayIndex = getArrayIndex;
exports.replaceReferences = replaceReferences;
exports.listUndefinedLocalCodes = listUndefinedLocalCodes;
exports.getSliceName = getSliceName;
exports.replaceField = replaceField;
exports.cleanResource = cleanResource;
exports.applyInsertRules = applyInsertRules;
exports.isInheritedResource = isInheritedResource;
exports.getUrlFromFshDefinition = getUrlFromFshDefinition;
exports.getVersionFromFshDefinition = getVersionFromFshDefinition;
exports.getTypeFromFshDefinitionOrParent = getTypeFromFshDefinitionOrParent;
exports.isExtension = isExtension;
exports.isModifierExtension = isModifierExtension;
exports.isReferenceType = isReferenceType;
exports.validateInstanceFromRawValue = validateInstanceFromRawValue;
exports.orderedCloneDeep = orderedCloneDeep;
exports.getAllConcepts = getAllConcepts;
exports.findImposeProfiles = findImposeProfiles;
exports.getMatchingContainedReferenceId = getMatchingContainedReferenceId;
const lodash_1 = require("lodash");
const _1 = require(".");
const rules_1 = require("../fshtypes/rules");
const fshtypes_1 = require("../fshtypes");
const Fishable_1 = require("../utils/Fishable");
const utils_1 = require("../utils");
const sliceTree_1 = require("./sliceTree");
const errors_1 = require("../errors");
const common_1 = require("../fshtypes/common");
const valid_url_1 = require("valid-url");
// List of Conformance and Terminology resources from http://hl7.org/fhir/R4/resourcelist.html
// and https://hl7.org/fhir/R5/resourcelist.html
exports.CONFORMANCE_AND_TERMINOLOGY_RESOURCES = new Set([
    'CapabilityStatement',
    'CapabilityStatement2', // pre-release R5
    'StructureDefinition',
    'ImplementationGuide',
    'SearchParameter',
    'MessageDefinition',
    'OperationDefinition',
    'CompartmentDefinition',
    'StructureMap',
    'GraphDefinition',
    'ExampleScenario',
    'CodeSystem',
    'ValueSet',
    'ConceptMap',
    'ConceptMap2', // pre-release R5
    'NamingSystem',
    'TerminologyCapabilities'
]);
// characteristics are set using the structuredefinition-type-characteristics extension
exports.TYPE_CHARACTERISTICS_EXTENSION = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-type-characteristics';
// the allowed codes to use with that extension are in the type-characteristics-code code system.
exports.TYPE_CHARACTERISTICS_CODE = 'http://hl7.org/fhir/type-characteristics-code';
exports.LOGICAL_TARGET_EXTENSION = 'http://hl7.org/fhir/tools/StructureDefinition/logical-target';
exports.IMPOSE_PROFILE_EXTENSION = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-imposeProfile';
function splitOnPathPeriods(path) {
    return path.split(/\.(?![^\[]*\])/g); // match a period that isn't within square brackets
}
/**
 * This function sets an instance property of a resource if possible
 * @param {StructureDefinition | ElementDefinition | CodeSystem | ValueSet} instance - The instance to assign a value on
 * @param {string} path - The path to assign a value at
 * @param {any} value - The value to assign
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 */
function setPropertyOnDefinitionInstance(instance, path, value, fisher) {
    const instanceSD = instance.getOwnStructureDefinition(fisher);
    const { assignedValue, pathParts } = instanceSD.validateValueAtPath(path, value, fisher);
    if (instance instanceof _1.ElementDefinition) {
        instance.clearOriginalProperty(pathParts);
    }
    if (!(instance instanceof _1.CodeSystem || instance instanceof _1.ValueSet)) {
        const knownSlices = determineKnownSlices(instanceSD, new Map([[path, { pathParts }]]), fisher);
        setImpliedPropertiesOnInstance(instance, instanceSD, [path], [], fisher, knownSlices);
    }
    setPropertyOnInstance(instance, pathParts, assignedValue, fisher);
}
/**
 * Adds placeholder elements with slice names to array elements on instance definition.
 * The placeholder elements to add are based on the paths in the rule map.
 * @param {StructureDefinition | ElementDefinition | InstanceDefinition} instanceDef - Instance to create slices on
 * @param {StructureDefinition} instanceOfStructureDefinition - Structure definition for instanceDef
 * @param {Map<string, { pathParts: PathPart[] }>} ruleMap - Contains the paths used in assignment rules on the instance
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 * Returns the path of the slice including the slice name and the quantity (the minimum or the greatest index of the
 * slice that is used in a rule) of the slice.
 */
function createUsefulSlices(instanceDef, instanceOfStructureDefinition, ruleMap, fisher) {
    const knownSlices = new Map();
    ruleMap.forEach(({ pathParts }, path) => {
        var _a, _b, _c, _d, _e, _f, _g;
        var _h, _j;
        const nonNumericPath = path.replace(/\[[-+]?\d+\]/g, '');
        const element = instanceOfStructureDefinition.findElementByPath(nonNumericPath, fisher);
        if (element) {
            // go through the parts, and make sure that we have a useful index, and maybe a named slice
            let current = instanceDef;
            let currentPath = '';
            for (const [i, pathPart] of pathParts.entries()) {
                currentPath += `${currentPath ? '.' : ''}${pathPart.base}`;
                // If this is a primitive and the path continues to a nested element of the primitive,
                // then we need to look at the special property that starts with _ instead.
                let key;
                if (pathPart.primitive && i < pathParts.length - 1) {
                    key = `_${pathPart.base}`;
                }
                else {
                    key = pathPart.base;
                }
                const ruleIndex = getArrayIndex(pathPart);
                let effectiveIndex = ruleIndex;
                let sliceName;
                if (ruleIndex != null) {
                    // If the array doesn't exist, create it
                    if (pathPart.primitive) {
                        (_a = current[_h = pathPart.base]) !== null && _a !== void 0 ? _a : (current[_h] = []);
                        (_b = current[_j = `_${pathPart.base}`]) !== null && _b !== void 0 ? _b : (current[_j] = []);
                    }
                    else {
                        (_c = current[key]) !== null && _c !== void 0 ? _c : (current[key] = []);
                    }
                    sliceName = pathPart.brackets ? getSliceName(pathPart) : null;
                    if (sliceName) {
                        // Determine the path to the slice
                        const slicePath = `${currentPath}[${sliceName.replace(/\//g, '][')}]`; // Include sliceName in the currentPath (which is a FSH path)
                        knownSlices.set(slicePath, Math.max(ruleIndex + 1, (_d = knownSlices.get(slicePath)) !== null && _d !== void 0 ? _d : 0));
                        const sliceIndices = [];
                        // Find the indices where slices are placed
                        const sliceExtensionUrl = (_e = fisher.fishForMetadata(sliceName)) === null || _e === void 0 ? void 0 : _e.url;
                        (_f = current[pathPart.base]) === null || _f === void 0 ? void 0 : _f.forEach((el, i) => {
                            if ((el === null || el === void 0 ? void 0 : el._sliceName) === sliceName ||
                                (isExtension(pathPart.base) && (el === null || el === void 0 ? void 0 : el.url) && (el === null || el === void 0 ? void 0 : el.url) === sliceExtensionUrl)) {
                                sliceIndices.push(i);
                            }
                        });
                        /**
                         * Convert the index in terms of the slice to the corresponding index in the overall array
                         *
                         * Consider an example:
                         * * component[foo][0]
                         * * component[foo][1]
                         * * component[bar][0]
                         * * component[foo][2]
                         *
                         * So if rule = component[foo][2]:
                         * ruleIndex = 2
                         * sliceIndices = [0, 1] (since we're processing component[foo][2])
                         * key = "component"
                         * current[key] = the array of component on the instance so far
                         * So we should put the rule at the end of the component, which is effectiveIndex = 3
                         */
                        if (ruleIndex >= sliceIndices.length) {
                            effectiveIndex = ruleIndex - sliceIndices.length + current[pathPart.base].length;
                        }
                        else {
                            effectiveIndex = sliceIndices[ruleIndex];
                        }
                    }
                    else {
                        // This is an array entry that does not have a named slice (so a typical numeric index)
                        knownSlices.set(currentPath, Math.max(effectiveIndex + 1, (_g = knownSlices.get(currentPath)) !== null && _g !== void 0 ? _g : 0));
                    }
                    if (pathPart.brackets != null) {
                        currentPath += pathPart.brackets
                            .filter(b => b !== '0')
                            .map(b => `[${b}]`)
                            .join('');
                    }
                    // If the index doesn't exist in the array, add it and lesser indices
                    // Empty elements should be null, not undefined, according to https://www.hl7.org/fhir/json.html#primitive
                    for (let j = 0; j <= effectiveIndex; j++) {
                        if (j < current[key].length &&
                            j === effectiveIndex &&
                            current[key][effectiveIndex] == null) {
                            if (pathPart.primitive) {
                                current[pathPart.base][effectiveIndex] = {};
                                current[`_${pathPart.base}`][effectiveIndex] = {};
                            }
                            else {
                                current[key][effectiveIndex] = {};
                            }
                        }
                        else if (j >= current[key].length) {
                            if (sliceName) {
                                // _sliceName is used to later differentiate which slice an element represents
                                if (pathPart.primitive) {
                                    current[pathPart.base].push({ _sliceName: sliceName });
                                    current[`_${pathPart.base}`].push({ _sliceName: sliceName });
                                }
                                else {
                                    current[key].push({ _sliceName: sliceName });
                                }
                            }
                            else if (j === effectiveIndex) {
                                if (pathPart.primitive) {
                                    current[pathPart.base].push({});
                                    current[`_${pathPart.base}`].push({});
                                }
                                else {
                                    current[key].push({});
                                }
                            }
                            else {
                                if (pathPart.primitive) {
                                    current[pathPart.base].push(null);
                                    current[`_${pathPart.base}`].push(null);
                                }
                                else {
                                    current[key].push(null);
                                }
                            }
                        }
                    }
                    // If it isn't the last element, move on
                    if (i < pathParts.length - 1) {
                        current = current[key][effectiveIndex];
                    }
                }
                else if (i < pathParts.length - 1) {
                    // if we're not dealing with an array element, just traverse the element tree.
                    if (current[key] == null) {
                        current[key] = {};
                    }
                    current = current[key];
                }
            }
        }
    });
    return knownSlices;
}
/**
 * Looks through the rules on an instance to determine what slices will be created
 * when the instance is exported.
 * Returns the path of the slice including the slice name and the quantity (the minimum or the greatest index of the
 * slice that is used in a rule) of the slice.
 */
function determineKnownSlices(instanceOfStructureDefinition, ruleMap, fisher) {
    const knownSlices = new Map();
    ruleMap.forEach(({ pathParts }, path) => {
        var _a, _b;
        const nonNumericPath = path.replace(/\[[-+]?\d+\]/g, '');
        const element = instanceOfStructureDefinition.findElementByPath(nonNumericPath, fisher);
        if (element) {
            // go through the parts, and make sure that we have a useful index, and maybe a named slice
            let currentPath = '';
            for (const pathPart of pathParts) {
                currentPath += `${currentPath ? '.' : ''}${pathPart.base}`;
                const ruleIndex = getArrayIndex(pathPart);
                let sliceName;
                if (ruleIndex != null) {
                    sliceName = pathPart.brackets ? getSliceName(pathPart) : null;
                    if (sliceName) {
                        // Determine the path to the slice
                        const slicePath = currentPath + `[${sliceName.replace(/\//g, '][')}]`; // Include sliceName in the currentPath (which is a FSH path)
                        knownSlices.set(slicePath, Math.max(ruleIndex + 1, (_a = knownSlices.get(slicePath)) !== null && _a !== void 0 ? _a : 0));
                    }
                    else {
                        // This is an array entry that does not have a named slice (so a typical numeric index)
                        knownSlices.set(currentPath, Math.max(ruleIndex + 1, (_b = knownSlices.get(currentPath)) !== null && _b !== void 0 ? _b : 0));
                    }
                    if (pathPart.brackets != null) {
                        currentPath += pathPart.brackets
                            .filter(b => b !== '0')
                            .map(b => `[${b}]`)
                            .join('');
                    }
                }
            }
        }
    });
    return knownSlices;
}
/**
 * NOTE: There is a thorough explanation of this function in ./common-README.md
 * that will hopefully explain some of the intricacies of function.
 * Good luck out there.
 */
function setImpliedPropertiesOnInstance(instanceDef, instanceOfStructureDefinition, paths, assignedResourcePaths, fisher, knownSlices = new Map(), manualSliceOrdering = false) {
    var _a, _b;
    // normalize reslice style to multiple brackets
    paths = paths.map(p => p.replace(/\//g, ']['));
    // Record the values implied by the structure definition in sdRuleMap
    const sdRuleMap = new Map();
    const requirementRoots = new Map();
    // implied values may be applicable to slices
    const assignedValueStorage = new Map();
    const topLevelElements = instanceOfStructureDefinition.elements[0].children(true);
    const elementsToCheck = topLevelElements.map(el => {
        var _a;
        let requirementRoot;
        if (el.min > 0) {
            requirementRoot = '';
        }
        else {
            requirementRoot = splitOnPathPeriods(el.id).pop();
            if (requirementRoot.includes('[x]') && ((_a = el.type) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                requirementRoot = requirementRoot.replace(/\[x].*/, (0, lodash_1.upperFirst)(el.type[0].code));
            }
            // normalize reslice style to multiple brackets
            requirementRoot = requirementRoot.replace(/:(.*)$/, '[$1]').replace(/\//g, '][');
        }
        return {
            def: el,
            history: [],
            ghost: false,
            requirementRoot
        };
    });
    const effectiveMins = new Map();
    while (elementsToCheck.length > 0) {
        const currentElement = elementsToCheck.shift();
        let nextTracePart = splitOnPathPeriods(currentElement.def.id).slice(-1)[0];
        if (nextTracePart.includes('[x]') && ((_a = currentElement.def.type) === null || _a === void 0 ? void 0 : _a.length) === 1) {
            // if the type slice exists, and we end with [x], don't change it. otherwise, change it.
            // if value[x] and value[x]:valueIdentifier exist:
            //   value[x] stays the same, value[x]:valueIdentifier changes to valueIdentifier
            // if value[x] exists, but no choice slices of value[x] exist, and value[x] has only one type
            //   change value[x] to valueType
            if (currentElement.def.sliceName || currentElement.def.getSlices().length === 0) {
                nextTracePart = nextTracePart.replace(/\[x].*/, (0, lodash_1.upperFirst)(currentElement.def.type[0].code));
            }
        }
        // normalize reslice style to multiple brackets
        nextTracePart = nextTracePart.replace(/:(.*)$/, '[$1]').replace(/\//g, '][');
        const traceParts = [...currentElement.history, nextTracePart];
        const tracePath = traceParts.join('.');
        if (!effectiveMins.has(tracePath)) {
            const sliceTree = (0, sliceTree_1.buildSliceTree)(currentElement.def);
            let keyStart = currentElement.history.join('.');
            if (keyStart.length > 0) {
                keyStart += '.';
            }
            (0, sliceTree_1.calculateSliceTreeCounts)(sliceTree, knownSlices, keyStart);
            const visitList = [sliceTree];
            while (visitList.length > 0) {
                const next = visitList.shift();
                let traceKey = tracePath;
                // add the slice name for non-choice slices
                if (next.element.sliceName && !next.element.base.path.endsWith('[x]')) {
                    traceKey += `[${next.element.sliceName.replace(/\//g, '][')}]`;
                }
                effectiveMins.set(traceKey, next.count);
                visitList.push(...next.children);
            }
        }
        const finalMin = effectiveMins.get(tracePath);
        // does a rule path match the trace path?
        const matchingRule = paths.find(p => p === tracePath || p.startsWith(tracePath + '.'));
        // check for assigned values regardless of this element's effective min,
        // since it may have required slices that will need to know about the assigned value
        const assignedValueKey = Object.keys(currentElement.def).find(k => k.startsWith('fixed') || k.startsWith('pattern'));
        let foundAssignedValue = (0, lodash_1.cloneDeep)(currentElement.def[assignedValueKey]);
        const connectedElements = currentElement.def.findConnectedElements();
        if (foundAssignedValue == null) {
            // check assigned value storage
            foundAssignedValue = assignedValueStorage.get(currentElement.def.id);
        }
        else {
            // add to assigned value storage
            connectedElements.forEach(connectedEl => {
                assignedValueStorage.set(connectedEl.id, foundAssignedValue);
            });
        }
        // if our def has a min > 0, potentially update min on connected defs by reapplying our own cardinality
        if (currentElement.def.min > 0) {
            connectedElements.forEach(ce => {
                if (ce.min < currentElement.def.min && !ce.id.startsWith(currentElement.def.id)) {
                    ce.constrainCardinality(currentElement.def.min, '');
                    if (ce.children().length == 0) {
                        ce.unfold(fisher);
                    }
                }
            });
        }
        if (finalMin > 0) {
            if (foundAssignedValue != null && !currentElement.ghost) {
                let ip = tracePath;
                if (/\[x]/.test(ip)) {
                    // Fix any single-type choices to be type-specific (e.g., value[x] -> valueString)
                    const parts = splitOnPathPeriods(ip);
                    for (let i = 0; i < parts.length; i++) {
                        if (parts[i].endsWith('[x]')) {
                            const partEl = instanceOfStructureDefinition.findElementByPath(parts.slice(0, i + 1).join('.'), fisher);
                            if (((_b = partEl === null || partEl === void 0 ? void 0 : partEl.type) === null || _b === void 0 ? void 0 : _b.length) === 1) {
                                parts[i] = parts[i].replace('[x]', (0, lodash_1.upperFirst)(partEl.type[0].code));
                            }
                        }
                    }
                    ip = parts.join('.');
                    // If there is still a [x], we couldn't fix it, so skip it
                    if (/\[x]/.test(ip)) {
                        ip = null;
                    }
                }
                if (ip) {
                    // set it for each instance of this element
                    for (let idx = 0; idx < finalMin; idx++) {
                        const numericPath = ip + (idx > 0 ? `[${idx}]` : '');
                        sdRuleMap.set(numericPath, foundAssignedValue);
                        requirementRoots.set(numericPath, currentElement.requirementRoot);
                    }
                }
            }
            // check the children for instance of this element
            const children = currentElement.def.children(true);
            // special handling: if our current element has no slice name, we need guarantee the defined minimum
            // this is the only place where we do this, in order to accomodate cases where some named slices already exist
            let existingSliceCount = 0;
            if (finalMin < currentElement.def.min && currentElement.def.sliceName == null) {
                // our final min was lowered by slices, so add that to our indices.
                const slicePaths = currentElement.def
                    .getSlices()
                    .map(el => `${tracePath}[${el.sliceName}]`);
                slicePaths.forEach(slicePath => {
                    if (knownSlices.has(slicePath)) {
                        existingSliceCount += knownSlices.get(slicePath);
                    }
                });
            }
            for (let idx = 0; idx < finalMin; idx++) {
                const effectiveIdx = idx + existingSliceCount;
                const newHistory = traceParts.slice(-1)[0] + (effectiveIdx > 0 ? `[${effectiveIdx}]` : '');
                elementsToCheck.push(...children.map(child => ({
                    def: child,
                    history: [...currentElement.history, newHistory],
                    ghost: currentElement.ghost,
                    requirementRoot: currentElement.def.min > idx
                        ? currentElement.requirementRoot
                        : [...currentElement.history, newHistory].join('.')
                })));
            }
        }
        else if (matchingRule || currentElement.def.min > 0) {
            // the definition min could be > 0 when the final min is 0 if slices fill it all the way up
            if (matchingRule && foundAssignedValue != null && !currentElement.ghost) {
                sdRuleMap.set(tracePath, foundAssignedValue);
                requirementRoots.set(tracePath, currentElement.requirementRoot);
            }
            let children = currentElement.def.children(true);
            // if the matching rule assigns a resource, we don't need to dig into it any deeper
            if (children.length == 0 && !assignedResourcePaths.includes(matchingRule)) {
                currentElement.def.unfold(fisher);
                children = currentElement.def.children(true);
            }
            const newHistory = traceParts.slice(-1)[0];
            elementsToCheck.push(...children.map(child => ({
                def: child,
                history: [...currentElement.history, newHistory],
                ghost: matchingRule == null,
                requirementRoot: child.min > 0
                    ? currentElement.requirementRoot
                    : [...currentElement.history, newHistory].join('.')
            })));
        }
    }
    // we mostly want to assign rules in the order we get them, with one exception:
    // a path must come before its ancestors.
    // so, we build a tree of paths where each node's children are paths that start with that node's path.
    // then, we traverse the tree depth-first, postfix order to get the correct order.
    // in most cases, nothing will change, but it can come up when assigning to both a sliced element and a specific slice,
    // especially when complex types like CodeableConcept get involved.
    const originalKeys = Array.from(sdRuleMap.keys());
    const rulePaths = originalKeys.map(path => ({ path }));
    const pathTree = buildPathTree(rulePaths);
    const sortedRulePaths = traverseRulePathTree(pathTree);
    if (!manualSliceOrdering) {
        // This sort function simulates the original implementation of setImpliedPropertiesOnInstance
        sortedRulePaths.sort((a, b) => {
            const aRoot = requirementRoots.get(a);
            const bRoot = requirementRoots.get(b);
            if (aRoot === bRoot) {
                // the winner is whoever has more path overlap on the first rule appearance
                const firstRule = paths.find(path => path === aRoot || path.startsWith(`${aRoot}.`));
                if (firstRule != null) {
                    const firstRuleSplit = splitOnPathPeriods(firstRule);
                    const splitA = splitOnPathPeriods(a);
                    const splitB = splitOnPathPeriods(b);
                    for (const [firstPart, aPart, bPart] of (0, lodash_1.zip)(firstRuleSplit, splitA, splitB)) {
                        if (firstPart == null) {
                            return 0;
                        }
                        if (firstPart === aPart && firstPart !== bPart) {
                            return -1;
                        }
                        if (firstPart !== aPart && firstPart === bPart) {
                            return 1;
                        }
                        if (firstPart !== aPart && firstPart !== bPart) {
                            return 0;
                        }
                    }
                }
                return 0;
            }
            // if one is an ancestor of the other, use whichever appears first in the list of rules.
            // if the first appearance is the same rule for both, use the deeper element first
            const firstA = paths.findIndex(path => path === aRoot || path.startsWith(`${aRoot}.`));
            const firstB = paths.findIndex(path => path === bRoot || path.startsWith(`${bRoot}.`));
            if (firstA === firstB) {
                return bRoot.length - aRoot.length;
            }
            // if a and b have different requirement roots, but neither is an ancestor of the other, use rule order
            return firstA - firstB;
        });
    }
    sortedRulePaths.forEach(path => {
        const { pathParts } = instanceOfStructureDefinition.validateValueAtPath(path, null, fisher);
        setPropertyOnInstance(instanceDef, pathParts, sdRuleMap.get(path), fisher);
    });
}
function buildPathTree(paths) {
    const topLevelChildren = [];
    paths.forEach(p => insertIntoTree(topLevelChildren, p));
    return topLevelChildren;
}
function insertIntoTree(currentElements, el) {
    // if we find something that could be this element's parent, we traverse downwards
    const parent = currentElements.find(current => el.path.startsWith(current.path));
    if (parent != null) {
        insertIntoTree(parent.children, el);
    }
    else {
        // otherwise, we will add at the current level
        // the current level could contain elements that should be the new element's children
        const children = (0, lodash_1.remove)(currentElements, current => current.path.startsWith(el.path));
        el.children = children;
        currentElements.push(el);
    }
}
function traverseRulePathTree(elements) {
    const result = [];
    elements.forEach(el => {
        result.push(...traverseRulePathTree(el.children));
        result.push(el.path);
    });
    return result;
}
function setPropertyOnInstance(instance, pathParts, assignedValue, fisher) {
    var _a, _b, _c, _d, _e, _f;
    var _g, _h;
    if (assignedValue != null) {
        // If we can assign the value on the StructureDefinition StructureDefinition, then we can set the
        // instance property here
        let current = instance;
        for (const [i, pathPart] of pathParts.entries()) {
            // When a primitive has child elements, a _ is appended to the name of the primitive
            // According to https://www.hl7.org/fhir/json.html#primitive
            let key;
            if (pathPart.primitive && i < pathParts.length - 1) {
                key = `_${pathPart.base}`;
            }
            else {
                key = pathPart.base;
            }
            // If this part of the path indexes into an array, the index will be the last bracket
            let index = getArrayIndex(pathPart);
            let sliceName;
            if (index != null) {
                if (pathPart.primitive) {
                    // we may need to create or update one or both arrays
                    if (current[pathPart.base] == null) {
                        current[pathPart.base] =
                            (_b = (_a = current[`_${pathPart.base}`]) === null || _a === void 0 ? void 0 : _a.map((x) => (x === null || x === void 0 ? void 0 : x._sliceName) != null ? { _sliceName: x._sliceName } : null)) !== null && _b !== void 0 ? _b : [];
                    }
                    if (current[`_${pathPart.base}`] == null) {
                        current[`_${pathPart.base}`] = current[pathPart.base].map((x) => (x === null || x === void 0 ? void 0 : x._sliceName) != null ? { _sliceName: x._sliceName } : null);
                    }
                }
                else if (current[key] == null) {
                    // if the array doesn't exist, create it
                    current[key] = [];
                }
                sliceName = getSliceName(pathPart);
                if (sliceName) {
                    const sliceIndices = [];
                    // Find the indices where slices are placed
                    const sliceExtensionUrl = (_c = fisher.fishForMetadata(sliceName)) === null || _c === void 0 ? void 0 : _c.url;
                    (_d = current[pathPart.base]) === null || _d === void 0 ? void 0 : _d.forEach((el, i) => {
                        if ((el === null || el === void 0 ? void 0 : el._sliceName) === sliceName ||
                            (isExtension(pathPart.base) && (el === null || el === void 0 ? void 0 : el.url) && (el === null || el === void 0 ? void 0 : el.url) === sliceExtensionUrl)) {
                            sliceIndices.push(i);
                        }
                    });
                    // Convert the index in terms of the slice to the corresponding index in the overall array
                    if (index >= sliceIndices.length) {
                        index = index - sliceIndices.length + current[key].length;
                    }
                    else {
                        index = sliceIndices[index];
                    }
                }
                // If the index doesn't exist in the array, add it and lesser indices
                // Empty elements should be null, not undefined, according to https://www.hl7.org/fhir/json.html#primitive
                for (let j = 0; j <= index; j++) {
                    if (j < current[key].length && j === index && current[key][index] == null) {
                        if (pathPart.primitive) {
                            // a value may already exist on one of the arrays, so only assign an empty object if it is nullish
                            (_e = (_g = current[pathPart.base])[index]) !== null && _e !== void 0 ? _e : (_g[index] = {});
                            (_f = (_h = current[`_${pathPart.base}`])[index]) !== null && _f !== void 0 ? _f : (_h[index] = {});
                        }
                        else {
                            current[key][index] = {};
                        }
                    }
                    else if (j >= current[key].length) {
                        if (sliceName) {
                            // _sliceName is used to later differentiate which slice an element represents
                            if (pathPart.primitive) {
                                current[pathPart.base].push({ _sliceName: sliceName });
                                current[`_${pathPart.base}`].push({ _sliceName: sliceName });
                            }
                            else {
                                current[key].push({ _sliceName: sliceName });
                            }
                        }
                        else if (j === index) {
                            if (pathPart.primitive) {
                                current[pathPart.base].push({});
                                current[`_${pathPart.base}`].push({});
                            }
                            else {
                                current[key].push({});
                            }
                        }
                        else {
                            if (pathPart.primitive) {
                                current[pathPart.base].push(null);
                                current[`_${pathPart.base}`].push(null);
                            }
                            else {
                                current[key].push(null);
                            }
                        }
                    }
                }
                // If it isn't the last element, move on, if it is, set the value
                if (i < pathParts.length - 1) {
                    current = current[key][index];
                    if (sliceName) {
                        current._sliceName = sliceName;
                    }
                }
                else {
                    if (sliceName && typeof assignedValue !== 'object') {
                        // When an assignedValue is a primitive but also a slice, we convert to an object so that
                        // the sliceName field can be tracked on the object. The _primitive field marks the object
                        // to later be converted back to a primitive by replaceField in cleanResource
                        assignedValue = { assignedValue, _primitive: true };
                    }
                    if (typeof assignedValue === 'object') {
                        Object.assign(current[key][index], assignedValue);
                    }
                    else {
                        current[key][index] = assignedValue;
                    }
                }
            }
            else {
                // If it isn't the last element, move on, if it is, set the value
                if (i < pathParts.length - 1) {
                    if (current[key] == null)
                        current[key] = {};
                    current = current[key];
                }
                else {
                    // Check if the instance already has the element being defined
                    if (current[key] != null && typeof current[key] === 'object') {
                        // If the instance already has the element, we should merge it
                        // Cases where this applies:
                        // - Quantity elements that set a value and then set a code with the FSH code syntax
                        // - Reference elements that set other properties of reference (like identifier) directly
                        //   and set reference with the FSH Reference() keyword
                        // We have to be a little careful when assigning, in case array values are contained in the object
                        assignComplexValue(current[key], assignedValue);
                    }
                    else {
                        current[key] = assignedValue;
                    }
                }
            }
        }
    }
}
function assignComplexValue(current, assignedValue) {
    // checking that current is an array is a little redundant, but is useful for the type checker
    if (Array.isArray(assignedValue) && Array.isArray(current)) {
        // for each element of assignedValue, make a compatible element on current
        for (const assignedElement of assignedValue) {
            if (typeof assignedElement !== 'object') {
                // if assignedElement is not an object:
                // is there an existing element that is equal?
                // if so, we're good
                // if not, append
                if (!current.some((currentElement) => {
                    return ((typeof currentElement === 'object' &&
                        currentElement._primitive === true &&
                        currentElement.assignedValue === assignedValue) ||
                        currentElement === assignedElement);
                })) {
                    current.push(assignedElement);
                }
            }
            else {
                // if assignedElement is an object:
                // is there an existing element that has all the attributes?
                // if so, we're good.
                // if not, is there an existing (potentially null) element that we can add attributes to, to make compatible?
                // if so, assign at that index.
                // if not, append
                const perfectMatch = current.some(currentElement => {
                    return (currentElement != null &&
                        Object.keys(assignedElement).every(assignedKey => {
                            return (0, lodash_1.isEqual)(reversePrimitive(assignedElement[assignedKey]), reversePrimitive(currentElement[assignedKey]));
                        }));
                });
                if (!perfectMatch) {
                    const partialMatch = current.findIndex(currentElement => {
                        return (currentElement == null ||
                            Object.keys(assignedElement).every(assignedKey => {
                                return (currentElement[assignedKey] == null ||
                                    (0, lodash_1.isEqual)(reversePrimitive(assignedElement[assignedKey]), reversePrimitive(currentElement[assignedKey])));
                            }));
                    });
                    if (partialMatch > -1) {
                        // we may have found a partial match at a null element. if so, create an empty object
                        if (current[partialMatch] == null) {
                            current[partialMatch] = {};
                        }
                        assignComplexValue(current[partialMatch], assignedElement);
                    }
                    else {
                        current.push(assignedElement);
                    }
                }
            }
        }
    }
    else {
        // assignedValue is a non-array object,
        // so assign recursively
        for (const key of Object.keys(assignedValue)) {
            if (typeof assignedValue[key] === 'object') {
                if (current[key] == null) {
                    if (Array.isArray(assignedValue[key])) {
                        current[key] = [];
                    }
                    else {
                        current[key] = {};
                    }
                }
                assignComplexValue(current[key], assignedValue[key]);
            }
            else {
                if (typeof current[key] === 'object' && current[key]._primitive === true) {
                    current[key].assignedValue = assignedValue[key];
                }
                else {
                    current[key] = assignedValue[key];
                }
            }
        }
    }
}
// turn an assigned-primitive back into its primitive value
// if and only if it has no other properties
function reversePrimitive(element) {
    if (typeof element === 'object' &&
        element._primitive === true &&
        Object.keys(element).includes('assignedValue') &&
        Object.keys(element).length === 2) {
        return element.assignedValue;
    }
    else {
        return element;
    }
}
/**
 * Tests to see if the last bracket in a PathPart is a non-negative int, and if so returns it
 * @param {PathPart} pathPart - The part of the path to test
 * @returns {number} The index if it exists and is non-negative, otherwise undefined
 *
 */
function getArrayIndex(pathPart) {
    var _a;
    const lastBracket = (_a = pathPart.brackets) === null || _a === void 0 ? void 0 : _a.slice(-1)[0];
    let arrayIndex;
    if (/^[-+]?\d+$/.test(lastBracket)) {
        arrayIndex = parseInt(lastBracket);
    }
    return arrayIndex >= 0 ? arrayIndex : null;
}
/**
 * Replaces a reference to an item by name or id with the correct relative path to that item.
 * Replaces a reference to a local code system by the url for that code system.
 * @param {AssignmentRule} rule - The rule to replace references on
 * @param {FSHTank} tank - The tank holding the instances and code systems
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 * @returns {AssignmentRule} a clone of the rule if replacing is done, otherwise the original rule
 */
function replaceReferences(rule, tank, fisher) {
    var _a, _b, _c;
    let clone;
    const value = rule.value;
    if (value instanceof fshtypes_1.FshReference) {
        let type, id, instanceMeta;
        // Prefer resolving to instances, so look them up first
        const instance = tank.fish(value.reference, Fishable_1.Type.Instance);
        if (instance) {
            instanceMeta = fisher.fishForMetadata(instance === null || instance === void 0 ? void 0 : instance.instanceOf, Fishable_1.Type.Resource, Fishable_1.Type.Logical, Fishable_1.Type.Type, Fishable_1.Type.Profile, Fishable_1.Type.Extension);
            if (instanceMeta) {
                type = instanceMeta.sdType;
                id = instance.id;
            }
        }
        // If we didn't find an instance, check other definitions in the tank
        if (type == null) {
            const definition = tank.fish(value.reference, Fishable_1.Type.Profile, Fishable_1.Type.Extension, Fishable_1.Type.Logical, Fishable_1.Type.Resource, Fishable_1.Type.CodeSystem, Fishable_1.Type.ValueSet);
            if (definition) {
                if (definition instanceof fshtypes_1.Profile ||
                    definition instanceof fshtypes_1.Extension ||
                    definition instanceof fshtypes_1.Logical ||
                    definition instanceof fshtypes_1.Resource) {
                    type = 'StructureDefinition';
                }
                else if (definition instanceof fshtypes_1.FshCodeSystem) {
                    type = 'CodeSystem';
                }
                else if (definition instanceof fshtypes_1.FshValueSet) {
                    type = 'ValueSet';
                }
                id = definition.id;
            }
        }
        // If we still didn't find anything, broaden the scope to everything
        if (type == null) {
            const fhir = fisher.fishForFHIR(value.reference, Fishable_1.Type.Instance, Fishable_1.Type.Profile, Fishable_1.Type.Extension, Fishable_1.Type.Logical, Fishable_1.Type.Resource, Fishable_1.Type.CodeSystem, Fishable_1.Type.ValueSet);
            if (fhir && fhir.resourceType && fhir.id) {
                type = fhir.resourceType;
                id = fhir.id;
            }
        }
        if (type != null && id != null) {
            clone = (0, lodash_1.cloneDeep)(rule);
            const assignedReference = clone.value;
            // Set the sdType which will be used for type-checking during assignment
            assignedReference.sdType = type;
            // Only replace references that are specified using name or id. Absolute URLs or
            // relative URLs w/ a type should be left as-is to allow the user more control.
            if (!value.reference.includes('/')) {
                assignedReference.reference = `${type}/${id}`;
            }
            // if type is a logical, it needs to have can-be-target characteristic.
            // the canBeTarget metadata value is only defined for logicals.
            const typeMeta = instanceMeta !== null && instanceMeta !== void 0 ? instanceMeta : fisher.fishForMetadata(type);
            if (typeMeta.canBeTarget === false) {
                utils_1.logger.warn(`Referenced type ${(_b = (_a = typeMeta === null || typeMeta === void 0 ? void 0 : typeMeta.name) !== null && _a !== void 0 ? _a : typeMeta === null || typeMeta === void 0 ? void 0 : typeMeta.id) !== null && _b !== void 0 ? _b : type} for logical instance ${value.reference} does not specify that it can be the target of a reference.`, rule.sourceInfo);
            }
        }
        else {
            // if we still haven't found anything, there's one more possibility:
            // the reference includes a version, which it doesn't need.
            const firstPipe = value.reference.indexOf('|');
            if (firstPipe > -1) {
                utils_1.logger.warn('Reference assignments should not include a version.', rule.sourceInfo);
                clone = (0, lodash_1.cloneDeep)(rule);
                clone.value.reference = value.reference.slice(0, firstPipe);
                clone = replaceReferences(clone, tank, fisher);
            }
            else if (type == null && id == null && value.reference) {
                // if the reference to an entity is provided but is unable to be resolved
                if (!(value.reference.startsWith('urn:') || value.reference.includes('/'))) {
                    utils_1.logger.warn(`Cannot find the entity referenced at ${value.reference}. The provided reference value will be used, but this reference does not conform to the FHIR Reference format.`, rule.sourceInfo);
                }
            }
        }
    }
    else if (value instanceof fshtypes_1.FshCode) {
        // the version on a CodeSystem resource is not the same as the system's actual version out in the world.
        // so, they don't need to match.
        const baseSystem = (_c = value.system) === null || _c === void 0 ? void 0 : _c.split('|')[0];
        const codeSystemMeta = fisher.fishForMetadata(baseSystem, Fishable_1.Type.CodeSystem);
        if (codeSystemMeta) {
            clone = (0, lodash_1.cloneDeep)(rule);
            const assignedCode = clone.value;
            assignedCode.system = value.system.replace(/^[^|]+/, codeSystemMeta.url);
            // Find the code system using the returned metadata to avoid duplicate warnings if version mismatches
            const matchedCanonical = codeSystemMeta.url
                ? `${codeSystemMeta.url}${codeSystemMeta.version ? `|${codeSystemMeta.version}` : ''}`
                : value.system;
            const codeSystem = (0, utils_1.fishInTankBestVersion)(tank, matchedCanonical, rule.sourceInfo, Fishable_1.Type.CodeSystem);
            if (codeSystem && (codeSystem instanceof fshtypes_1.FshCodeSystem || codeSystem instanceof fshtypes_1.Instance)) {
                // if a local system was used, check to make sure the code is actually in that system
                listUndefinedLocalCodes(codeSystem, [assignedCode.code], tank, rule);
            }
        }
    }
    return clone !== null && clone !== void 0 ? clone : rule;
}
function listUndefinedLocalCodes(codeSystem, codes, tank, sourceEntity) {
    let undefinedCodes = [];
    applyInsertRules(codeSystem, tank);
    const conceptRulePath = /^(concept(\[\s*(\d+|\+|=)\s*\])?\.)+code$/;
    // if the CodeSystem content is complete, a code not present in this system should be listed as undefined.
    // if the CodeSystem content is not complete, then do not list any code as undefined.
    // in a FshCodeSystem, content is complete by default, so make sure it isn't set to something else.
    // in an Instance, content does not have a default value, so make sure there is a rule that sets it to complete.
    if (codeSystem instanceof fshtypes_1.FshCodeSystem &&
        !codeSystem.rules.some(rule => rule instanceof rules_1.CaretValueRule &&
            rule.path === '' &&
            rule.caretPath === 'content' &&
            rule.value instanceof fshtypes_1.FshCode &&
            rule.value.code !== 'complete')) {
        // a concept may have been added by a ConceptRule or by a CaretValueRule.
        // while ConceptRule is strongly preferred, CaretValueRule is still allowed.
        undefinedCodes = codes.filter(code => {
            return !codeSystem.rules.some(rule => (rule instanceof rules_1.ConceptRule && rule.code === code) ||
                (rule instanceof rules_1.CaretValueRule &&
                    rule.path === '' &&
                    conceptRulePath.test(rule.caretPath) &&
                    rule.value instanceof fshtypes_1.FshCode &&
                    rule.value.code === code));
        });
    }
    else if (codeSystem instanceof fshtypes_1.Instance &&
        codeSystem.usage == 'Definition' &&
        codeSystem.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
            rule.path === 'content' &&
            rule.value instanceof fshtypes_1.FshCode &&
            rule.value.code === 'complete')) {
        undefinedCodes = codes.filter(code => {
            return !codeSystem.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
                conceptRulePath.test(rule.path) &&
                rule.value instanceof fshtypes_1.FshCode &&
                rule.value.code === code);
        });
    }
    if (undefinedCodes.length > 0) {
        utils_1.logger.error(`Code${undefinedCodes.length > 1 ? 's' : ''} ${undefinedCodes
            .map(code => `"${code}"`)
            .join(', ')} ${undefinedCodes.length > 1 ? 'are' : 'is'} not defined for system ${codeSystem.name}.`, sourceEntity.sourceInfo);
    }
}
/**
 * Returns the sliceName for a set of pathParts
 * @param {PathPart} pathPart - The part of the path to get a sliceName for
 * @returns {string} The sliceName for the path part
 */
function getSliceName(pathPart) {
    const arrayIndex = getArrayIndex(pathPart);
    const nonNumericBrackets = arrayIndex == null ? pathPart.brackets : pathPart.brackets.slice(0, -1);
    return nonNumericBrackets.join('/');
}
/**
 * Replaces fields in an object that match a certain condition
 * @param { {[key: string]: any} } object - The object to replace fields on
 * @param {(object: { [key: string]: any }, prop: string) => boolean} matchFn - The function to match with
 * @param {(object: { [key: string]: any }, prop: string) => void} replaceFn - The function to replace with
 * @param {(object: { [key: string]: any }, prop: string) => boolean} skipFn - A function that returns true if a property should not be traversed
 */
function replaceField(object, matchFn, replaceFn, skipFn) {
    for (const prop in object) {
        if (matchFn(object, prop)) {
            replaceFn(object, prop);
        }
        else if (typeof object[prop] === 'object' && !skipFn(prop)) {
            replaceField(object[prop], matchFn, replaceFn, skipFn);
            // If the object[prop] was an array and all items were replaced by null using the replaceFn, get rid of the whole array
            if (Array.isArray(object[prop]) && object[prop].every((v) => v == null)) {
                delete object[prop];
            }
            // Since an array could have been deleted, the whole object[prop] could have ended up as empty.
            // So, check again if object[prop] matches the matchFn to see if the whole thing can be replaced using the replaceFn.
            if (matchFn(object, prop)) {
                replaceFn(object, prop);
            }
        }
    }
}
/**
 * Cleans up temporary properties that were added to the resource definition during processing
 * @param {StructureDefinition | InstanceDefinition | CodeSystem | ValueSet} resourceDef - The resource definition to clean
 * @param {string => boolean} skipFn - A function that returns true if a property should not be traversed
 */
function cleanResource(resourceDef, skipFn = () => false) {
    var _a;
    // Remove all _sliceName fields
    replaceField(resourceDef, (o, p) => p === '_sliceName', (o, p) => delete o[p], skipFn);
    // Change any {} to null
    replaceField(resourceDef, (o, p) => typeof o[p] === 'object' && o[p] !== null && (0, lodash_1.isEmpty)(o[p]), (o, p) => (o[p] = null), skipFn);
    // Change back any primitives that have been converted into objects by setPropertyOnInstance
    replaceField(resourceDef, (o, p) => typeof o[p] === 'object' && o[p] !== null && o[p]._primitive, (o, p) => (o[p] = o[p].assignedValue), skipFn);
    // Update references to any contained resources to be #id instead of resourceType/id
    (_a = resourceDef.contained) === null || _a === void 0 ? void 0 : _a.forEach((containedResource) => {
        const referenceString = containedResource
            ? `${containedResource.resourceType}/${containedResource.id}`
            : null;
        const referenceUrl = containedResource === null || containedResource === void 0 ? void 0 : containedResource.url;
        replaceField(resourceDef, (o, p) => /(^|\.)reference$/.test(p) &&
            (o[p] === referenceString || (referenceUrl && o[p] === referenceUrl)), (o, p) => (o[p] = `#${containedResource.id}`), skipFn);
    });
}
/**
 * Adds insert rules onto a Profile, Extension, or Instance
 * @param fshDefinition - The definition to apply rules on
 * @param tank - The FSHTank containing the fshDefinition
 */
function applyInsertRules(fshDefinition, tank, seenRuleSets = []) {
    const expandedRules = [];
    fshDefinition.rules.forEach(rule => {
        if (!(rule instanceof rules_1.InsertRule)) {
            expandedRules.push(rule);
            return;
        }
        const ruleSetIdentifier = JSON.stringify([rule.ruleSet, ...rule.params]);
        let ruleSet;
        if (rule.params.length) {
            ruleSet = tank.fishForAppliedRuleSet(ruleSetIdentifier);
        }
        else {
            ruleSet = tank.fish(rule.ruleSet, Fishable_1.Type.RuleSet);
        }
        if (ruleSet) {
            if (seenRuleSets.includes(ruleSetIdentifier)) {
                utils_1.logger.error(`Inserting ${ruleSet.name} will cause a circular dependency, so the rule will be ignored`, rule.sourceInfo);
                return;
            }
            // RuleSets may contain other RuleSets via insert rules on themselves, so before applying the rules
            // from a RuleSet, we must first recursively expand any insert rules on that RuleSet
            applyInsertRules(ruleSet, tank, [...seenRuleSets, ruleSetIdentifier]);
            let context = rule.path;
            let firstRule = true;
            ruleSet.rules.forEach(ruleSetRule => {
                ruleSetRule.sourceInfo.appliedFile = rule.sourceInfo.file;
                ruleSetRule.sourceInfo.appliedLocation = rule.sourceInfo.location;
                // On the import side, there are some rules that syntactically match both ConceptRule and
                // ValueSetConceptComponentRule. When this happens, a ConceptRule is created with a value
                // set on its system. If we are applying rules to a ValueSet, and the ConceptRule has a
                // system, create a ValueSetConceptComponent that corresponds to the ConceptRule, and use that.
                // BUT! If we have a ConceptRule with a system, and we are applying rules to a CodeSystem,
                // log an error to let the author know to not do that.
                if (ruleSetRule instanceof rules_1.ConceptRule && ruleSetRule.system) {
                    if (fshDefinition instanceof fshtypes_1.FshValueSet) {
                        const relatedCode = new fshtypes_1.FshCode(ruleSetRule.code, ruleSetRule.system, ruleSetRule.display);
                        ruleSetRule = new rules_1.ValueSetConceptComponentRule(true);
                        ruleSetRule.concepts = [relatedCode];
                        ruleSetRule.from.system = relatedCode.system;
                    }
                    else if (fshDefinition instanceof fshtypes_1.FshCodeSystem) {
                        utils_1.logger.error('Do not include the system when listing concepts for a code system.', ruleSetRule.sourceInfo);
                    }
                }
                if ((0, fshtypes_1.isAllowedRule)(fshDefinition, ruleSetRule)) {
                    const ruleSetRuleClone = (0, lodash_1.cloneDeep)(ruleSetRule);
                    if (context) {
                        let newPath = context;
                        if ((ruleSetRuleClone === null || ruleSetRuleClone === void 0 ? void 0 : ruleSetRuleClone.path) === '.') {
                            utils_1.logger.error("The special '.' path is only allowed in top-level rules. The rule will be processed as if it is not indented.", ruleSetRule.sourceInfo);
                            newPath = ruleSetRuleClone.path;
                        }
                        else if (ruleSetRuleClone.path) {
                            newPath += `.${ruleSetRuleClone.path}`;
                        }
                        ruleSetRuleClone.path = newPath;
                    }
                    if (rule.pathArray.length > 0) {
                        if (ruleSetRuleClone instanceof rules_1.ConceptRule) {
                            // strip the leading # when adding to the hierarchy
                            ruleSetRuleClone.hierarchy.unshift(...rule.pathArray.map(code => code.slice(1)));
                        }
                        else if (ruleSetRuleClone instanceof rules_1.CaretValueRule) {
                            ruleSetRuleClone.pathArray.unshift(...rule.pathArray);
                        }
                    }
                    if (ruleSetRuleClone instanceof rules_1.ConceptRule &&
                        fshDefinition instanceof fshtypes_1.FshCodeSystem &&
                        context) {
                        // ConceptRules should not have a path context, so if one exists, show an error.
                        // The concept is still added to the CodeSystem.
                        utils_1.logger.error('Do not insert a RuleSet at a path when the RuleSet adds a concept.', ruleSetRuleClone.sourceInfo);
                    }
                    expandedRules.push(ruleSetRuleClone);
                    if (firstRule) {
                        // Once one rule has been applied, all future rules should inherit the index used on that rule
                        // rather than continuing to increment the index with the [+] operator
                        context = context.replace(/\[\+\]/g, '[=]');
                        firstRule = false;
                    }
                }
                else {
                    utils_1.logger.error(`Rule of type ${ruleSetRule.constructorName} cannot be applied to entity of type ${fshDefinition.constructorName}`, ruleSetRule.sourceInfo);
                }
            });
        }
        else {
            utils_1.logger.error(`Unable to find definition for RuleSet ${rule.ruleSet}.`, rule.sourceInfo);
        }
    });
    fshDefinition.rules = expandedRules;
}
/**
 * Tests if resourceType is a valid FHIR resource that is a subtype of type. This is the case
 * if type is Resource, or if type is DomainResource and resourceType is one of the resources
 * that inherits from DomainResource, or if type is equal to resourceType.
 * @param {string} resourceType - The resourceType to test inheritance of
 * @param {string} type - The original type being inherited from
 * @param {Fishable} fisher - A fisher for finding FHIR definitions
 * @param {boolean} allowProfile - True if profiles of inherited resource should be allowed
 * @returns {boolean} true if resourceType is a valid sub-type of type, false otherwise
 */
function isInheritedResource(resourceType, type, fisher, allowProfile = false) {
    const types = allowProfile ? [Fishable_1.Type.Resource, Fishable_1.Type.Profile] : [Fishable_1.Type.Resource];
    const resource = fisher.fishForFHIR(resourceType, ...types);
    if (resource) {
        if (allowProfile) {
            resourceType = resource.resourceType;
        }
        return (type === 'Resource' ||
            (type === 'DomainResource' &&
                // These are the only 3 resources not inherited from DomainResource
                // https://www.hl7.org/fhir/domainresource.html#bnr
                !['Bundle', 'Parameters', 'Binary'].includes(resourceType)) ||
            type === resourceType);
    }
}
/**
 * Determines the formal FHIR URL to use to refer to this entity (for example when fishing).
 * If a caret value rule has been applied to the entity's url, use the value specified in that
 * rule. Otherwise, use the default url based on the configured canonical url.
 * Since a string should always be assigned here, only return the rule value if it is a string
 * and not an Instance.
 *
 * @param fshDefinition - The FSH definition that the returned URL refers to
 * @param canonical - The canonical URL for the FSH project
 * @returns The URL to use to refer to the FHIR entity
 */
function getUrlFromFshDefinition(fshDefinition, canonical) {
    const urlFromFshRules = (0, common_1.getValueFromRules)(fshDefinition, 'url', '', 'url');
    if (typeof (urlFromFshRules === null || urlFromFshRules === void 0 ? void 0 : urlFromFshRules.value) === 'string' && !(urlFromFshRules === null || urlFromFshRules === void 0 ? void 0 : urlFromFshRules.isInstance)) {
        return urlFromFshRules.value.toString();
    }
    let fhirType;
    if (fshDefinition instanceof fshtypes_1.FshValueSet) {
        fhirType = 'ValueSet';
    }
    else if (fshDefinition instanceof fshtypes_1.FshCodeSystem) {
        fhirType = 'CodeSystem';
    }
    else {
        fhirType = 'StructureDefinition';
    }
    return `${canonical}/${fhirType}/${fshDefinition.id}`;
}
/**
 * Determines the version of this entity.
 * If a caret value rule has been applied to the entity's version, use the value specified in that
 * rule. Otherwise, use the default version based on the configured version from the tank.
 * Since a string should always be assigned here, only return the rule value if it is a string
 * and not an Instance.
 *
 * @param fshDefinition - The FSH definition whose version is being determined
 * @param canonical - The version for the FSH project
 * @returns The version of the FHIR entity
 */
function getVersionFromFshDefinition(fshDefinition, version) {
    const versionFromFshRules = (0, common_1.getValueFromRules)(fshDefinition, 'version', '', 'version');
    if (typeof (versionFromFshRules === null || versionFromFshRules === void 0 ? void 0 : versionFromFshRules.value) === 'string' && !versionFromFshRules.isInstance) {
        return versionFromFshRules.value.toString();
    }
    return version;
}
/**
 * Determines the formal FHIR type to use to define to this entity for logical models and
 * resources. The type for profiles and extension should not be changed. If a caret value
 * rule has been applied to the entity's type, use the value specified in that rule.
 * Otherwise, use the appropriate default based on the fshDefinition.
 *
 * @param fshDefinition - The FSH definition (Logical or Resource) that the returned type refers to
 * @param parentSD - The parent StructureDefinition for the fshDefinition
 * @returns The type to specify in the StructureDefinition for this fshDefinition
 */
function getTypeFromFshDefinitionOrParent(fshDefinition, parentSD) {
    if (fshDefinition instanceof fshtypes_1.Profile || fshDefinition instanceof fshtypes_1.Extension) {
        return parentSD.type;
    }
    const fshRules = fshDefinition.rules;
    const caretValueRules = fshRules.filter(rule => rule instanceof rules_1.CaretValueRule && rule.path === '' && rule.caretPath === 'type');
    if (caretValueRules.length > 0) {
        // Select last CaretValueRule with caretPath === 'type' because rules processing
        // ends up applying the last rule in the processing order
        const lastCaretValueRule = caretValueRules[caretValueRules.length - 1];
        const type = lastCaretValueRule.value.toString();
        // this value should only be a string, but that might change at some point
        if (fshDefinition instanceof fshtypes_1.Logical && !(0, valid_url_1.isUri)(type)) {
            utils_1.logger.warn(`${type} is an invalid type. Logical models require that the type be an absolute URL.`, lastCaretValueRule.sourceInfo);
        }
        return type;
    }
    // Default type for logical model to the StructureDefinition url;
    // otherwise default to the id meta property.
    // Ref: https://chat.fhir.org/#narrow/pm-with/191469,210024,211704,239822-group/near/240237602
    return fshDefinition instanceof fshtypes_1.Logical ? parentSD.url : fshDefinition.id;
}
function isExtension(path) {
    return ['modifierExtension', 'extension'].includes(path);
}
function isModifierExtension(extension) {
    var _a;
    return (((_a = extension === null || extension === void 0 ? void 0 : extension.snapshot.element.find((el) => el.id === 'Extension')) === null || _a === void 0 ? void 0 : _a.isModifier) === true);
}
/**
 * Checks if a provided type can be treated as a Reference
 * @param type - The type being checked
 * @returns - True if the type can be treated as a reference, false otherwise
 */
function isReferenceType(type) {
    return ['Reference', 'CodeableReference'].includes(type);
}
/**
 * Use the raw value from a CaretValueRule to try to find an Instance to assign.
 * This is useful in cases where the Instance id is numeric or boolean.
 */
function validateInstanceFromRawValue(target, rule, instanceExporter, fisher, originalErr) {
    const instance = instanceExporter.fishForFHIR(rule.rawValue);
    if (instance == null) {
        utils_1.logger.error(originalErr.message, rule.sourceInfo);
        if (originalErr.stack) {
            utils_1.logger.debug(originalErr.stack);
        }
    }
    else {
        try {
            const targetSD = target.getOwnStructureDefinition(fisher);
            const path = rule.path.length > 1 ? `${rule.path}.${rule.caretPath}` : rule.caretPath;
            const { pathParts } = targetSD.validateValueAtPath(path, instance, fisher);
            return { instance, pathParts };
        }
        catch (instanceErr) {
            if (instanceErr instanceof errors_1.MismatchedTypeError) {
                utils_1.logger.error(originalErr.message, rule.sourceInfo);
                if (originalErr.stack) {
                    utils_1.logger.debug(originalErr.stack);
                }
            }
            else {
                utils_1.logger.error(instanceErr.message, rule.sourceInfo);
                if (instanceErr.stack) {
                    utils_1.logger.debug(instanceErr.stack);
                }
            }
        }
    }
    return { instance: null, pathParts: [] };
}
/**
 * Make a deep clone recursively, adding properties in the order expected for exported JSON.
 * If a list of keys is provided, use those properties from the input.
 * Otherwise, use all properties from the input.
 *
 * @param input - the value to clone
 * @param keys - optionally, the properties of the value to include in the clone, defaults to input keys if not specified
 * @returns {any} - a clone of the input, with reordered properties
 */
function orderedCloneDeep(input, keys) {
    // non-objects should be cloned normally
    // arrays should get a recursive call on their elements, but don't need reordering
    if (!(0, lodash_1.isObjectLike)(input)) {
        return (0, lodash_1.cloneDeep)(input);
    }
    else if (Array.isArray(input)) {
        return input.map(element => orderedCloneDeep(element));
    }
    else {
        if (keys == null) {
            keys = Object.keys(input);
        }
        const underscoreKeys = (0, lodash_1.remove)(keys, key => key.startsWith('_'));
        const orderedKeys = [];
        const result = {};
        keys.forEach(key => {
            orderedKeys.push(key);
            if (underscoreKeys.includes(`_${key}`)) {
                orderedKeys.push(`_${key}`);
                (0, lodash_1.pull)(underscoreKeys, `_${key}`);
            }
        });
        underscoreKeys.forEach(key => {
            orderedKeys.push(key);
        });
        orderedKeys.forEach(key => {
            result[key] = orderedCloneDeep(input[key]);
        });
        return result;
    }
}
function getAllConcepts(cs) {
    const allConcepts = [];
    if (cs.concept == null) {
        return allConcepts;
    }
    const conceptList = [...cs.concept];
    while (conceptList.length > 0) {
        const nextConcept = conceptList.shift();
        allConcepts.push(nextConcept.code);
        if (nextConcept.concept != null) {
            conceptList.unshift(...nextConcept.concept);
        }
    }
    return allConcepts;
}
/**
 * Find the profiles declared as impose profiles via the imposeProfile extension.
 * @param sd - the StructureDefinition to extract imposeProfiles from
 * @returns - a list of impose profile URLs or undefined if there are none
 */
function findImposeProfiles(sd) {
    var _a;
    const imposeProfiles = (_a = sd === null || sd === void 0 ? void 0 : sd.extension) === null || _a === void 0 ? void 0 : _a.filter((ext) => (ext === null || ext === void 0 ? void 0 : ext.url) === exports.IMPOSE_PROFILE_EXTENSION && ext.valueCanonical != null).map((ext) => ext.valueCanonical);
    if (imposeProfiles === null || imposeProfiles === void 0 ? void 0 : imposeProfiles.length) {
        return imposeProfiles;
    }
}
// Used to check if the entity used in Canonical() references a contained resource.
// Checks a list of validated rules at any contained path for a matching value from the
// Canonical() keyword and returns the matching resource's id.
function getMatchingContainedReferenceId(value, containedResources) {
    var _a, _b;
    const matchingContainedResource = containedResources.find(r => {
        var _a, _b, _c;
        return ((_a = r.assignedValue) === null || _a === void 0 ? void 0 : _a.url) === value ||
            ((_b = r.assignedValue) === null || _b === void 0 ? void 0 : _b.name) === value ||
            ((_c = r.assignedValue) === null || _c === void 0 ? void 0 : _c.id) === value;
    });
    if (matchingContainedResource != null) {
        return matchingContainedResource.assignedValue.id;
    }
    const matchingContainedResourceId = containedResources.find(r => r.pathParts.slice(-1)[0].base === 'id' && r.assignedValue === value);
    const matchingContainedResourceName = containedResources.find(r => r.pathParts.slice(-1)[0].base === 'name' && r.assignedValue === value);
    const matchingContainedResourceUrl = containedResources.find(r => r.pathParts.slice(-1)[0].base === 'url' && r.assignedValue === value);
    if (matchingContainedResourceId ||
        matchingContainedResourceName ||
        matchingContainedResourceUrl) {
        const pathParts = (_b = (_a = matchingContainedResourceId === null || matchingContainedResourceId === void 0 ? void 0 : matchingContainedResourceId.pathParts) !== null && _a !== void 0 ? _a : matchingContainedResourceName === null || matchingContainedResourceName === void 0 ? void 0 : matchingContainedResourceName.pathParts) !== null && _b !== void 0 ? _b : matchingContainedResourceUrl === null || matchingContainedResourceUrl === void 0 ? void 0 : matchingContainedResourceUrl.pathParts;
        const containedResourceId = containedResources.find(r => r.pathParts.slice(-1)[0].base === 'id' &&
            (0, lodash_1.isEqual)(r.pathParts.slice(0, -1), pathParts.slice(0, -1)));
        if (containedResourceId) {
            return containedResourceId.assignedValue;
        }
    }
}
//# sourceMappingURL=common.js.map