"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FHIRDefinitions = void 0;
const lodash_1 = require("lodash");
const fhir_package_loader_1 = require("fhir-package-loader");
const utils_1 = require("../utils");
const impliedExtensions_1 = require("./impliedExtensions");
const R5DefsForR4_1 = require("./R5DefsForR4");
const common_1 = require("../fhirtypes/common");
class FHIRDefinitions extends fhir_package_loader_1.FHIRDefinitions {
    constructor(isSupplementalFHIRDefinitions = false) {
        super();
        this.isSupplementalFHIRDefinitions = isSupplementalFHIRDefinitions;
        this.predefinedResources = new Map();
        this.supplementalFHIRDefinitions = new Map();
        // There are several R5 resources that are allowed for use in R4 and R4B.
        // Add them first so they're always available. If a later version is loaded
        // that has these definitions, it will overwrite them, so this should be safe.
        if (!isSupplementalFHIRDefinitions) {
            R5DefsForR4_1.R5_DEFINITIONS_NEEDED_IN_R4.forEach(def => this.add(def));
        }
    }
    // Expose the package.json files to support extracting the version when "latest" is used
    allPackageJsons() {
        var _a, _b;
        return Array.from((_b = (_a = this.packageJsons) === null || _a === void 0 ? void 0 : _a.values()) !== null && _b !== void 0 ? _b : []);
    }
    // This getter is only used in tests to verify what supplemental packages are loaded
    get supplementalFHIRPackages() {
        return (0, lodash_1.flatten)(Array.from(this.supplementalFHIRDefinitions.keys()));
    }
    allPredefinedResources(makeClone = true) {
        if (makeClone) {
            return Array.from(this.predefinedResources.values()).map(v => (0, lodash_1.cloneDeep)(v));
        }
        else {
            return Array.from(this.predefinedResources.values());
        }
    }
    add(definition) {
        // For supplemental FHIR versions, we only care about resources and types,
        // but for normal packages, we care about everything.
        if (this.isSupplementalFHIRDefinitions) {
            if (definition.resourceType === 'StructureDefinition' &&
                (definition.kind === 'primitive-type' ||
                    definition.kind === 'complex-type' ||
                    definition.kind === 'datatype' ||
                    (definition.kind === 'resource' && definition.derivation !== 'constraint'))) {
                super.add(definition);
            }
        }
        else {
            super.add(definition);
        }
    }
    addPredefinedResource(file, definition) {
        this.predefinedResources.set(file, definition);
    }
    getPredefinedResource(file) {
        return this.predefinedResources.get(file);
    }
    resetPredefinedResources() {
        this.predefinedResources = new Map();
    }
    addSupplementalFHIRDefinitions(fhirPackage, definitions) {
        this.supplementalFHIRDefinitions.set(fhirPackage, definitions);
    }
    getSupplementalFHIRDefinitions(fhirPackage) {
        return this.supplementalFHIRDefinitions.get(fhirPackage);
    }
    fishForPredefinedResource(item, ...types) {
        const resource = this.fishForFHIR(item, ...types);
        if (resource &&
            this.allPredefinedResources(false).find(predefResource => predefResource.id === resource.id &&
                predefResource.resourceType === resource.resourceType &&
                predefResource.url === resource.url)) {
            return resource;
        }
    }
    fishForPredefinedResourceMetadata(item, ...types) {
        const resource = this.fishForPredefinedResource(item, ...types);
        if (resource) {
            return {
                id: resource.id,
                name: resource.name,
                sdType: resource.type,
                url: resource.url,
                parent: resource.baseDefinition,
                imposeProfiles: (0, common_1.findImposeProfiles)(resource),
                abstract: resource.abstract,
                version: resource.version,
                resourceType: resource.resourceType
            };
        }
    }
    fishForFHIR(item, ...types) {
        const def = super.fishForFHIR(item, ...types);
        if (def) {
            return def;
        }
        // If it's an "implied extension", try to materialize it. See:http://hl7.org/fhir/versions.html#extensions
        if (impliedExtensions_1.IMPLIED_EXTENSION_REGEX.test(item) && types.some(t => t === utils_1.Type.Extension)) {
            return (0, impliedExtensions_1.materializeImpliedExtension)(item, this);
        }
    }
    fishForMetadata(item, ...types) {
        var _a, _b, _c, _d;
        const result = this.fishForFHIR(item, ...types);
        if (result) {
            let canBeTarget;
            let canBind;
            if (result.resourceType === 'StructureDefinition' && result.kind === 'logical') {
                canBeTarget =
                    (_b = (_a = result.extension) === null || _a === void 0 ? void 0 : _a.some((ext) => {
                        return (((ext === null || ext === void 0 ? void 0 : ext.url) === common_1.TYPE_CHARACTERISTICS_EXTENSION && (ext === null || ext === void 0 ? void 0 : ext.valueCode) === 'can-be-target') ||
                            ((ext === null || ext === void 0 ? void 0 : ext.url) === common_1.LOGICAL_TARGET_EXTENSION && (ext === null || ext === void 0 ? void 0 : ext.valueBoolean) === true));
                    })) !== null && _b !== void 0 ? _b : false;
                canBind =
                    (_d = (_c = result.extension) === null || _c === void 0 ? void 0 : _c.some((ext) => (ext === null || ext === void 0 ? void 0 : ext.url) === common_1.TYPE_CHARACTERISTICS_EXTENSION && (ext === null || ext === void 0 ? void 0 : ext.valueCode) === 'can-bind')) !== null && _d !== void 0 ? _d : false;
            }
            return {
                id: result.id,
                name: result.name,
                sdType: result.type,
                url: result.url,
                parent: result.baseDefinition,
                imposeProfiles: (0, common_1.findImposeProfiles)(result),
                abstract: result.abstract,
                version: result.version,
                resourceType: result.resourceType,
                canBeTarget,
                canBind
            };
        }
    }
}
exports.FHIRDefinitions = FHIRDefinitions;
//# sourceMappingURL=FHIRDefinitions.js.map