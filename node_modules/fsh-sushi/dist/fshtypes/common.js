"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeString = typeString;
exports.fshifyString = fshifyString;
exports.findAssignmentByPath = findAssignmentByPath;
exports.getValueFromRules = getValueFromRules;
exports.getNonInstanceValueFromRules = getNonInstanceValueFromRules;
const Instance_1 = require("./Instance");
const Invariant_1 = require("./Invariant");
const rules_1 = require("./rules");
const lodash_1 = require("lodash");
function typeString(types) {
    const references = [];
    const canonicals = [];
    const codeableReferences = [];
    const normals = [];
    types.forEach(t => {
        if (t.isReference) {
            references.push(t);
        }
        else if (t.isCanonical) {
            canonicals.push(t);
        }
        else if (t.isCodeableReference) {
            codeableReferences.push(t);
        }
        else {
            normals.push(t);
        }
    });
    const normalString = normals.map(t => t.type).join(' or ');
    const referenceString = references.length
        ? `Reference(${references.map(t => t.type).join(' or ')})`
        : '';
    const canonicalString = canonicals.length
        ? `Canonical(${canonicals.map(t => t.type).join(' or ')})`
        : '';
    const codeableReferenceString = codeableReferences.length
        ? `CodeableReference(${codeableReferences.map(t => t.type).join(' or ')})`
        : '';
    return [normalString, referenceString, canonicalString, codeableReferenceString]
        .filter(s => s)
        .join(' or ');
}
// Adds expected backslash-escapes to a string to make it a FSH string
function fshifyString(input) {
    return input
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\t/g, '\\t');
}
function findAssignmentByPath(fshDefinition, assignmentRulePath, caretRulePath, caretRuleCaretPath) {
    if (fshDefinition instanceof Instance_1.Instance || fshDefinition instanceof Invariant_1.Invariant) {
        return (0, lodash_1.findLast)(fshDefinition.rules, rule => rule instanceof rules_1.AssignmentRule && rule.path === assignmentRulePath);
    }
    else {
        return (0, lodash_1.findLast)(fshDefinition.rules, rule => rule instanceof rules_1.CaretValueRule &&
            rule.path === caretRulePath &&
            rule.caretPath === caretRuleCaretPath);
    }
}
/**
 * A helper function used to determine the value of either an assignment rule or a caret value rule
 * @param fshDefinition  the FSH definition
 * @param assignmentRulePath the path of the assignment rule whose value we want
 * @param caretRulePath the path of the caret value rule whose value we want
 * @param caretRuleCaretPath the caret path of the caret value rule
 * @returns an object with the value set by either the assignment rule or the caret value rule, and whether or not the value represents an instance,
 * or undefined if neither rule is set on the definition
 */
function getValueFromRules(fshDefinition, assignmentRulePath, caretRulePath, caretRuleCaretPath) {
    const foundRule = findAssignmentByPath(fshDefinition, assignmentRulePath, caretRulePath, caretRuleCaretPath);
    if (foundRule) {
        return { value: foundRule.value, isInstance: foundRule.isInstance };
    }
}
function getNonInstanceValueFromRules(fshDefinition, assignmentRulePath, caretRulePath, caretRuleCaretPath) {
    const foundValue = getValueFromRules(fshDefinition, assignmentRulePath, caretRulePath, caretRuleCaretPath);
    if (foundValue && !foundValue.isInstance) {
        return foundValue.value;
    }
}
//# sourceMappingURL=common.js.map