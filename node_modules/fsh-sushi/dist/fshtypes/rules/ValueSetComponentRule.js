"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueSetFilterComponentRule = exports.ValueSetConceptComponentRule = exports.ValueSetComponentRule = void 0;
const Rule_1 = require("./Rule");
const os_1 = require("os");
class ValueSetComponentRule extends Rule_1.Rule {
    constructor(inclusion) {
        super('');
        this.inclusion = inclusion;
        this.from = {};
    }
    get constructorName() {
        return 'ValueSetComponentRule';
    }
    toFSH() {
        return `* ${this.inclusion ? 'include' : 'exclude'} codes${fromString(this.from)}`;
    }
}
exports.ValueSetComponentRule = ValueSetComponentRule;
class ValueSetConceptComponentRule extends ValueSetComponentRule {
    constructor() {
        super(...arguments);
        this.concepts = [];
    }
    get constructorName() {
        return 'ValueSetConceptComponentRule';
    }
    toFSH() {
        var _a;
        // each code needs to be its own line of FSH
        if (((_a = this.from.valueSets) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            // no need for the include keyword when we're just including one code at a time
            const inclusionPart = `* ${this.inclusion ? '' : 'exclude '}`;
            const originalFromPart = fromValueSetsString(this.from);
            return this.concepts
                .map(concept => {
                const conceptPart = concept.toString();
                let fromPart = originalFromPart;
                // if the result is more than 100 characters long, build it again, but with linebreaks
                if (inclusionPart.length + conceptPart.length + fromPart.length > 100) {
                    fromPart = `${os_1.EOL}   ` + fromValueSetsString(this.from, ` and${os_1.EOL}    `);
                }
                return `${inclusionPart}${conceptPart}${fromPart}`;
            })
                .join(os_1.EOL);
        }
        else {
            const inclusionPart = `* ${this.inclusion ? '' : 'exclude '}`;
            return this.concepts
                .map(concept => {
                if (!concept.system && this.from.system) {
                    concept.system = this.from.system;
                }
                return `${inclusionPart}${concept}`;
            })
                .join(os_1.EOL);
        }
    }
}
exports.ValueSetConceptComponentRule = ValueSetConceptComponentRule;
class ValueSetFilterComponentRule extends ValueSetComponentRule {
    constructor() {
        super(...arguments);
        this.filters = [];
    }
    get constructorName() {
        return 'ValueSetFilterComponentRule';
    }
    toFSH() {
        const inclusionPart = `* ${this.inclusion ? 'include' : 'exclude'} codes`;
        let fromPart = fromString(this.from);
        let filterPart = this.buildFilterString();
        // if the result is more than 100 characters long, build it again, but with linebreaks
        if (inclusionPart.length + fromPart.length + filterPart.length > 100) {
            fromPart = fromString(this.from, ` and${os_1.EOL}    `);
            filterPart = `${os_1.EOL}   ` + this.buildFilterString(` and${os_1.EOL}    `);
        }
        return `${inclusionPart}${fromPart}${filterPart}`;
    }
    buildFilterString(separator = ' and ') {
        if (this.filters.length) {
            return (' where ' +
                this.filters
                    .map(filter => `${filter.property} ${filter.operator} ${typeof filter.value === 'string'
                    ? `"${filter.value.toString()}"`
                    : filter.value.toString()}`)
                    .join(separator));
        }
        else {
            return '';
        }
    }
}
exports.ValueSetFilterComponentRule = ValueSetFilterComponentRule;
function fromString(from, separator = ' and ') {
    if (from.system == null && from.valueSets == null)
        return '';
    let fromString = ' from ';
    if (from.system) {
        fromString += `system ${from.system}`;
    }
    if (from.valueSets) {
        fromString += `${from.system ? separator : ''}valueset ${from.valueSets.join(separator)}`;
    }
    return fromString;
}
function fromValueSetsString(from, separator = ' and ') {
    if (from.valueSets == null)
        return '';
    return ` from valueset ${from.valueSets.join(separator)}`;
}
//# sourceMappingURL=ValueSetComponentRule.js.map