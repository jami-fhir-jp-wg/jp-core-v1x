"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FISHING_ORDER = exports.Type = exports.FHIRDefinitions = void 0;
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
/** Class representing the FHIR definitions in one or more FHIR packages */
class FHIRDefinitions {
    /** Create a FHIRDefinitions */
    constructor() {
        this.package = '';
        this.resources = new utils_1.DoubleMap();
        this.logicals = new utils_1.DoubleMap();
        this.profiles = new utils_1.DoubleMap();
        this.extensions = new utils_1.DoubleMap();
        this.types = new utils_1.DoubleMap();
        this.valueSets = new utils_1.DoubleMap();
        this.codeSystems = new utils_1.DoubleMap();
        this.implementationGuides = new utils_1.DoubleMap();
        this.packageJsons = new utils_1.DoubleMap();
        this.childFHIRDefs = [];
        this.unsuccessfulPackageLoad = false;
    }
    /** Get the total number of definitions */
    size() {
        return (this.allResources().length +
            this.allLogicals().length +
            this.allProfiles().length +
            this.allExtensions().length +
            this.allTypes().length +
            this.allValueSets().length +
            this.allCodeSystems().length +
            this.allImplementationGuides().length);
    }
    // NOTE: These all return clones of the JSON to prevent the source values from being overwritten
    /**
     * Get all resources. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of resources
     */
    allResources(fhirPackage) {
        if ((this.resources.size > 0 && this.childFHIRDefs.length > 0) ||
            this.childFHIRDefs.length > 1) {
            return (0, lodash_1.uniqWith)(this.collectResources(fhirPackage), lodash_1.isEqual);
        }
        return this.collectResources(fhirPackage);
    }
    collectResources(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectResources(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        let resources = this.resources;
        if (fhirPackage) {
            resources = new Map();
            if (this.package === fhirPackage) {
                resources = this.resources;
            }
        }
        return cloneJsonMapValues(resources).concat(childValues);
    }
    /**
     * Get all logicals. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of logicals
     */
    allLogicals(fhirPackage) {
        if ((this.logicals.size > 0 && this.childFHIRDefs.length > 0) ||
            this.childFHIRDefs.length > 1) {
            return (0, lodash_1.uniqWith)(this.collectLogicals(fhirPackage), lodash_1.isEqual);
        }
        return (0, lodash_1.uniqWith)(this.collectLogicals(fhirPackage), lodash_1.isEqual);
    }
    collectLogicals(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectLogicals(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        let logicals = this.logicals;
        if (fhirPackage) {
            logicals = new Map();
            if (this.package === fhirPackage) {
                logicals = this.logicals;
            }
        }
        return cloneJsonMapValues(logicals).concat(childValues);
    }
    /**
     * Get all profiles. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of profiles
     */
    allProfiles(fhirPackage) {
        if ((this.profiles.size > 0 && this.childFHIRDefs.length > 0) ||
            this.childFHIRDefs.length > 1) {
            return (0, lodash_1.uniqWith)(this.collectProfiles(fhirPackage), lodash_1.isEqual);
        }
        return this.collectProfiles(fhirPackage);
    }
    collectProfiles(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectProfiles(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        let profiles = this.profiles;
        if (fhirPackage) {
            profiles = new Map();
            if (this.package === fhirPackage) {
                profiles = this.profiles;
            }
        }
        return cloneJsonMapValues(profiles).concat(childValues);
    }
    /**
     * Get all extensions. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of extensions
     */
    allExtensions(fhirPackage) {
        if ((this.extensions.size > 0 && this.childFHIRDefs.length > 0) ||
            this.childFHIRDefs.length > 1) {
            return (0, lodash_1.uniqWith)(this.collectExtensions(fhirPackage), lodash_1.isEqual);
        }
        return this.collectExtensions(fhirPackage);
    }
    collectExtensions(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectExtensions(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        let extensions = this.extensions;
        if (fhirPackage) {
            extensions = new Map();
            if (this.package === fhirPackage) {
                extensions = this.extensions;
            }
        }
        return cloneJsonMapValues(extensions).concat(childValues);
    }
    /**
     * Get all types. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of types
     */
    allTypes(fhirPackage) {
        if ((this.types.size > 0 && this.childFHIRDefs.length > 0) || this.childFHIRDefs.length > 1) {
            return (0, lodash_1.uniqWith)(this.collectTypes(fhirPackage), lodash_1.isEqual);
        }
        return this.collectTypes(fhirPackage);
    }
    collectTypes(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectTypes(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        let types = this.types;
        if (fhirPackage) {
            types = new Map();
            if (this.package === fhirPackage) {
                types = this.types;
            }
        }
        return cloneJsonMapValues(types).concat(childValues);
    }
    /**
     * Get all value sets. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of value sets
     */
    allValueSets(fhirPackage) {
        if ((this.valueSets.size > 0 && this.childFHIRDefs.length > 0) ||
            this.childFHIRDefs.length > 1) {
            return (0, lodash_1.uniqWith)(this.collectValueSets(fhirPackage), lodash_1.isEqual);
        }
        return this.collectValueSets(fhirPackage);
    }
    collectValueSets(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectValueSets(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        let valueSets = this.valueSets;
        if (fhirPackage) {
            valueSets = new Map();
            if (this.package === fhirPackage) {
                valueSets = this.valueSets;
            }
        }
        return cloneJsonMapValues(valueSets).concat(childValues);
    }
    /**
     * Get all code systems. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of code systems
     */
    allCodeSystems(fhirPackage) {
        if ((this.codeSystems.size > 0 && this.childFHIRDefs.length > 0) ||
            this.childFHIRDefs.length > 1) {
            return (0, lodash_1.uniqWith)(this.collectCodeSystems(fhirPackage), lodash_1.isEqual);
        }
        return this.collectCodeSystems(fhirPackage);
    }
    collectCodeSystems(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectCodeSystems(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        let codeSystems = this.codeSystems;
        if (fhirPackage) {
            codeSystems = new Map();
            if (this.package === fhirPackage) {
                codeSystems = this.codeSystems;
            }
        }
        return cloneJsonMapValues(codeSystems).concat(childValues);
    }
    /**
     * Get all implementation guides. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of implementation guides
     */
    allImplementationGuides(fhirPackage) {
        if ((this.implementationGuides.size > 0 && this.childFHIRDefs.length > 0) ||
            this.childFHIRDefs.length > 1) {
            return (0, lodash_1.uniqWith)(this.collectImplementationGuides(fhirPackage), lodash_1.isEqual);
        }
        return this.collectImplementationGuides(fhirPackage);
    }
    collectImplementationGuides(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectImplementationGuides(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        let implementationGuides = this.implementationGuides;
        if (fhirPackage) {
            implementationGuides = new Map();
            if (this.package === fhirPackage) {
                implementationGuides = this.implementationGuides;
            }
        }
        return cloneJsonMapValues(implementationGuides).concat(childValues);
    }
    /**
     * Get a list of packages that encountered errors while downloaded and were not loaded
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of packages (packageId#version) that were not successfully loaded
     */
    allUnsuccessfulPackageLoads(fhirPackage) {
        return (0, lodash_1.uniq)(this.collectUnsuccessfulPackageLoads(fhirPackage));
    }
    collectUnsuccessfulPackageLoads(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectUnsuccessfulPackageLoads(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        if (fhirPackage) {
            if (this.package === fhirPackage && this.unsuccessfulPackageLoad) {
                return childValues.concat(this.package);
            }
        }
        else if (this.unsuccessfulPackageLoad) {
            return childValues.concat(this.package);
        }
        return childValues;
    }
    /**
     * Get a list of all packages that are contained in this FHIRDefinitions
     * @param {string} [fhirPackage] The package (packageId#version) to get all packages from. If not provided, all packages are returned.
     * @returns array of packages (packageId#version) that are loaded
     */
    allPackages(fhirPackage) {
        return (0, lodash_1.uniq)(this.collectPackages(fhirPackage));
    }
    collectPackages(fhirPackage) {
        const childValues = this.childFHIRDefs
            .map(def => def.collectPackages(fhirPackage))
            .reduce((a, b) => a.concat(b), []);
        if (fhirPackage) {
            if (this.package === fhirPackage && this.package !== '') {
                return childValues.concat(this.package);
            }
        }
        else if (this.package !== '') {
            return childValues.concat(this.package);
        }
        return childValues;
    }
    /**
     * Add a definition
     * @param definition - The definition to add
     */
    add(definition) {
        if (definition.resourceType === 'StructureDefinition') {
            if (definition.type === 'Extension' &&
                definition.baseDefinition !== 'http://hl7.org/fhir/StructureDefinition/Element') {
                addDefinitionToMap(definition, this.extensions);
            }
            else if (definition.kind === 'primitive-type' ||
                definition.kind === 'complex-type' ||
                definition.kind === 'datatype') {
                addDefinitionToMap(definition, this.types);
            }
            else if (definition.kind === 'resource') {
                if (definition.derivation === 'constraint') {
                    addDefinitionToMap(definition, this.profiles);
                }
                else {
                    addDefinitionToMap(definition, this.resources);
                }
            }
            else if (definition.kind === 'logical') {
                if (definition.derivation === 'specialization') {
                    addDefinitionToMap(definition, this.logicals);
                }
                else {
                    addDefinitionToMap(definition, this.profiles);
                }
            }
        }
        else if (definition.resourceType === 'ValueSet') {
            addDefinitionToMap(definition, this.valueSets);
        }
        else if (definition.resourceType === 'CodeSystem') {
            addDefinitionToMap(definition, this.codeSystems);
        }
        else if (definition.resourceType === 'ImplementationGuide') {
            addDefinitionToMap(definition, this.implementationGuides);
        }
    }
    /**
     * Add a package.json
     * @param {string} id - package id
     * @param {string} definition - package JSON definition
     */
    addPackageJson(id, definition) {
        this.packageJsons.set(id, definition);
    }
    /**
     * Get a package's package.json
     * @param {string} id - package id
     * @returns package.json definition
     */
    getPackageJson(id) {
        return this.packageJsons.get(id);
    }
    /**
     * Private function for search through current FHIRDefinitions and all childFHIRDefs
     * for a specified definition. Uses get for efficient retrieves.
     * Breath-first search through childFHIRDefinitions for the item.
     * @param item name, id, or url of definition to find
     * @param map name of the map to search in
     * @returns definition or undefined if it is not found
     */
    getDefinition(item, map) {
        var _a;
        const defsToSearch = [this];
        while (defsToSearch.length > 0) {
            const currentFHIRDefs = defsToSearch.shift();
            const [base, ...versionParts] = (_a = item === null || item === void 0 ? void 0 : item.split('|')) !== null && _a !== void 0 ? _a : ['', ''];
            const version = versionParts.join('|') || null;
            const def = currentFHIRDefs[map].get(base);
            if (def) {
                if (version == null || version === (def === null || def === void 0 ? void 0 : def.version)) {
                    // Only return the found definition if the version matches (if provided)
                    return def;
                }
            }
            if (currentFHIRDefs.childFHIRDefs.length > 0) {
                defsToSearch.push(...currentFHIRDefs.childFHIRDefs);
            }
        }
        return;
    }
    /**
     * Search for a definition based on the type it could be
     * @param {string} item - the item to search for
     * @param {Type[]} types - the possible type the item could be
     * @returns the definition that is returned or undefined if none is found
     */
    fishForFHIR(item, ...types) {
        // No types passed in means to search ALL supported types
        if (types.length === 0) {
            types = exports.FISHING_ORDER;
        }
        else {
            types.sort((a, b) => exports.FISHING_ORDER.indexOf(a) - exports.FISHING_ORDER.indexOf(b));
        }
        for (const type of types) {
            let def;
            switch (type) {
                case Type.Resource:
                    def = (0, lodash_1.cloneDeep)(this.getDefinition(item, 'resources'));
                    break;
                case Type.Logical:
                    def = (0, lodash_1.cloneDeep)(this.getDefinition(item, 'logicals'));
                    break;
                case Type.Type:
                    def = (0, lodash_1.cloneDeep)(this.getDefinition(item, 'types'));
                    break;
                case Type.Profile:
                    def = (0, lodash_1.cloneDeep)(this.getDefinition(item, 'profiles'));
                    break;
                case Type.Extension:
                    def = (0, lodash_1.cloneDeep)(this.getDefinition(item, 'extensions'));
                    break;
                case Type.ValueSet:
                    def = (0, lodash_1.cloneDeep)(this.getDefinition(item, 'valueSets'));
                    break;
                case Type.CodeSystem:
                    def = (0, lodash_1.cloneDeep)(this.getDefinition(item, 'codeSystems'));
                    break;
                case Type.Instance: // don't support resolving to FHIR instances
                default:
                    break;
            }
            if (def) {
                return def;
            }
        }
    }
}
exports.FHIRDefinitions = FHIRDefinitions;
function addDefinitionToMap(def, defMap) {
    if (def.id) {
        defMap.set(def.id, def);
    }
    if (def.url) {
        defMap.set(def.url, def);
    }
    if (def.name) {
        defMap.set(def.name, def);
    }
}
function cloneJsonMapValues(map) {
    return Array.from(map.values()).map(v => (0, lodash_1.cloneDeep)(v));
}
var Type;
(function (Type) {
    Type["Profile"] = "Profile";
    Type["Extension"] = "Extension";
    Type["ValueSet"] = "ValueSet";
    Type["CodeSystem"] = "CodeSystem";
    Type["Instance"] = "Instance";
    Type["Invariant"] = "Invariant";
    Type["RuleSet"] = "RuleSet";
    Type["Mapping"] = "Mapping";
    Type["Resource"] = "Resource";
    Type["Type"] = "Type";
    Type["Logical"] = "Logical";
})(Type || (exports.Type = Type = {}));
exports.FISHING_ORDER = [
    Type.Resource,
    Type.Logical,
    Type.Type,
    Type.Profile,
    Type.Extension,
    Type.ValueSet,
    Type.CodeSystem
];
//# sourceMappingURL=FHIRDefinitions.js.map