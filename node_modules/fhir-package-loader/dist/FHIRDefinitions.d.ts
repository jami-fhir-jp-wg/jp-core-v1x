/** Class representing the FHIR definitions in one or more FHIR packages */
export declare class FHIRDefinitions {
    protected resources: Map<string, any>;
    protected logicals: Map<string, any>;
    protected profiles: Map<string, any>;
    protected extensions: Map<string, any>;
    protected types: Map<string, any>;
    protected valueSets: Map<string, any>;
    protected codeSystems: Map<string, any>;
    protected implementationGuides: Map<string, any>;
    protected packageJsons: Map<string, any>;
    childFHIRDefs: FHIRDefinitions[];
    package: string;
    unsuccessfulPackageLoad: boolean;
    /** Create a FHIRDefinitions */
    constructor();
    /** Get the total number of definitions */
    size(): number;
    /**
     * Get all resources. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of resources
     */
    allResources(fhirPackage?: string): any[];
    protected collectResources(fhirPackage?: string): any[];
    /**
     * Get all logicals. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of logicals
     */
    allLogicals(fhirPackage?: string): any[];
    protected collectLogicals(fhirPackage?: string): any[];
    /**
     * Get all profiles. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of profiles
     */
    allProfiles(fhirPackage?: string): any[];
    protected collectProfiles(fhirPackage?: string): any[];
    /**
     * Get all extensions. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of extensions
     */
    allExtensions(fhirPackage?: string): any[];
    protected collectExtensions(fhirPackage?: string): any[];
    /**
     * Get all types. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of types
     */
    allTypes(fhirPackage?: string): any[];
    protected collectTypes(fhirPackage?: string): any[];
    /**
     * Get all value sets. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of value sets
     */
    allValueSets(fhirPackage?: string): any[];
    protected collectValueSets(fhirPackage?: string): any[];
    /**
     * Get all code systems. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of code systems
     */
    allCodeSystems(fhirPackage?: string): any[];
    protected collectCodeSystems(fhirPackage?: string): any[];
    /**
     * Get all implementation guides. The array will not contain duplicates.
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of implementation guides
     */
    allImplementationGuides(fhirPackage?: string): any[];
    protected collectImplementationGuides(fhirPackage?: string): any[];
    /**
     * Get a list of packages that encountered errors while downloaded and were not loaded
     * @param {string} [fhirPackage] - The package (packageId#version) to search in. If not provided, searches all packages.
     * @returns array of packages (packageId#version) that were not successfully loaded
     */
    allUnsuccessfulPackageLoads(fhirPackage?: string): string[];
    protected collectUnsuccessfulPackageLoads(fhirPackage?: string): string[];
    /**
     * Get a list of all packages that are contained in this FHIRDefinitions
     * @param {string} [fhirPackage] The package (packageId#version) to get all packages from. If not provided, all packages are returned.
     * @returns array of packages (packageId#version) that are loaded
     */
    allPackages(fhirPackage?: string): string[];
    protected collectPackages(fhirPackage?: string): string[];
    /**
     * Add a definition
     * @param definition - The definition to add
     */
    add(definition: any): void;
    /**
     * Add a package.json
     * @param {string} id - package id
     * @param {string} definition - package JSON definition
     */
    addPackageJson(id: string, definition: any): void;
    /**
     * Get a package's package.json
     * @param {string} id - package id
     * @returns package.json definition
     */
    getPackageJson(id: string): any;
    /**
     * Private function for search through current FHIRDefinitions and all childFHIRDefs
     * for a specified definition. Uses get for efficient retrieves.
     * Breath-first search through childFHIRDefinitions for the item.
     * @param item name, id, or url of definition to find
     * @param map name of the map to search in
     * @returns definition or undefined if it is not found
     */
    private getDefinition;
    /**
     * Search for a definition based on the type it could be
     * @param {string} item - the item to search for
     * @param {Type[]} types - the possible type the item could be
     * @returns the definition that is returned or undefined if none is found
     */
    fishForFHIR(item: string, ...types: Type[]): any | undefined;
}
export declare enum Type {
    Profile = "Profile",
    Extension = "Extension",
    ValueSet = "ValueSet",
    CodeSystem = "CodeSystem",
    Instance = "Instance",
    Invariant = "Invariant",// NOTE: only defined in FSHTanks, not FHIR defs
    RuleSet = "RuleSet",// NOTE: only defined in FSHTanks, not FHIR defs
    Mapping = "Mapping",// NOTE: only defined in FSHTanks, not FHIR defs
    Resource = "Resource",
    Type = "Type",// NOTE: only defined in FHIR defs, not FSHTanks
    Logical = "Logical"
}
export declare const FISHING_ORDER: Type[];
